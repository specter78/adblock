/*
 * AGTree v2.1.2 (build date: Thu, 19 Sep 2024 15:44:40 GMT)
 * (c) 2024 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
import zod from 'zod';

/**
 * @file Common options for all parsers.
 */
/**
 * Common options for all parsers.
 */
interface ParserOptions {
    /**
     * If `true`, then the parser will not throw an error if the rule is syntactically invalid, instead it will
     * return an `InvalidRule` object with the error attached to it.
     */
    tolerant?: boolean;
    /**
     * Whether to include location information in the AST nodes.
     */
    isLocIncluded?: boolean;
    /**
     * Whether to parse AdBlock-specific rules.
     */
    parseAbpSpecificRules?: boolean;
    /**
     * Whether to parse uBlock Origin-specific rules.
     */
    parseUboSpecificRules?: boolean;
    /**
     * Whether to parse raw parts.
     */
    includeRaws?: boolean;
    /**
     * Whether to ignore comment-rules.
     */
    ignoreComments?: boolean;
    /**
     * Whether to parse host rules.
     */
    parseHostRules?: boolean;
}
/**
 * Default parser options.
 */
declare const defaultParserOptions: ParserOptions;

/**
 * @file Possible adblock syntaxes are listed here.
 */
/**
 * Possible adblock syntaxes (supported by this library)
 */
declare enum AdblockSyntax {
    /**
     * Common syntax, which is supported by more than one adblocker (or by all adblockers).
     *
     * We typically use this syntax when we cannot determine the concrete syntax of the rule,
     * because the syntax is used by more than one adblocker natively.
     *
     * @example
     * - `||example.org^$important` is a common syntax, since it is used by all adblockers natively, and
     * we cannot determine at parsing level whether `important` is a valid option or not, and if it is valid,
     * then which adblocker supports it.
     */
    Common = "Common",
    /**
     * Adblock Plus syntax.
     *
     * @example
     * - `example.org#$#abort-on-property-read alert` is an Adblock Plus syntax, since it is not used by any other
     * adblockers directly (probably supported by some on-the-fly conversion, but this is not the native syntax).
     * @see {@link https://adblockplus.org/}
     */
    Abp = "AdblockPlus",
    /**
     * uBlock Origin syntax.
     *
     * @example
     * - `example.com##+js(set, atob, noopFunc)` is an uBlock Origin syntax, since it is not used by any other
     * adblockers directly (probably supported by some on-the-fly conversion, but this is not the native syntax).
     * @see {@link https://github.com/gorhill/uBlock}
     */
    Ubo = "UblockOrigin",
    /**
     * AdGuard syntax.
     *
     * @example
     * - `example.org#%#//scriptlet("abort-on-property-read", "alert")` is an AdGuard syntax, since it is not used
     * by any other adblockers directly (probably supported by some on-the-fly conversion, but this is not the native
     * syntax).
     * @see {@link https://adguard.com/}
     */
    Adg = "AdGuard"
}

declare const ADG_SCRIPTLET_MASK = "//scriptlet";
declare const UBO_SCRIPTLET_MASK = "+js";
declare const MODIFIERS_SEPARATOR = ",";
declare const MODIFIER_ASSIGN_OPERATOR = "=";
declare const NEGATION_MARKER = "~";
/**
 * Classic domain separator.
 *
 * @example
 * ```adblock
 * ! Domains are separated by ",":
 * example.com,~example.org##.ads
 * ```
 */
declare const COMMA_DOMAIN_LIST_SEPARATOR = ",";
/**
 * Modifier separator for $app, $denyallow, $domain, $method.
 *
 * @example
 * ```adblock
 * ! Domains are separated by "|":
 * ads.js^$script,domains=example.com|~example.org
 * ```
 */
declare const PIPE_MODIFIER_SEPARATOR = "|";
declare const HINT_MARKER = "!+";
declare const NETWORK_RULE_EXCEPTION_MARKER = "@@";
declare const NETWORK_RULE_SEPARATOR = "$";
declare const AGLINT_COMMAND_PREFIX = "aglint";
declare const PREPROCESSOR_MARKER = "!#";
declare const SAFARI_CB_AFFINITY = "safari_cb_affinity";
declare const IF = "if";
declare const INCLUDE = "include";

/**
 * Possible operators in the logical expression.
 */
declare const enum OperatorValue {
    Not = "!",
    And = "&&",
    Or = "||"
}
/**
 * Represents possible new line types.
 */
type NewLine = 'crlf' | 'lf' | 'cr';
/**
 * Represents any kind of logical expression node.
 */
type AnyExpressionNode = ExpressionVariableNode | ExpressionOperatorNode | ExpressionParenthesisNode;
/**
 * Represents any kind of adblock rule.
 */
type AnyRule = EmptyRule | AnyCommentRule | AnyCosmeticRule | AnyNetworkRule | InvalidRule;
/**
 * Represents any comment-like adblock rule.
 */
type AnyCommentRule = AgentCommentRule | CommentRule | ConfigCommentRule | HintCommentRule | MetadataCommentRule | PreProcessorCommentRule;
/**
 * Represents any cosmetic adblock rule.
 */
type AnyCosmeticRule = CssInjectionRule | ElementHidingRule | ScriptletInjectionRule | HtmlFilteringRule | JsInjectionRule;
/**
 * Represents any network adblock rule.
 */
type AnyNetworkRule = NetworkRule | HostRule;
/**
 * Represents the different comment markers that can be used in an adblock rule.
 *
 * @example
 * - If the rule is `! This is just a comment`, then the marker will be `!`.
 * - If the rule is `# This is just a comment`, then the marker will be `#`.
 */
declare const enum CommentMarker {
    /**
     * Regular comment marker. It is supported by all ad blockers.
     */
    Regular = "!",
    /**
     * Hashmark comment marker. It is supported by uBlock Origin and AdGuard,
     * and also used in hosts files.
     */
    Hashmark = "#"
}
/**
 * Represents the main categories that an adblock rule can belong to.
 * Of course, these include additional subcategories.
 */
declare enum RuleCategory {
    /**
     * Empty "rules" that are only containing whitespaces. These rules are handled just for convenience.
     */
    Empty = "Empty",
    /**
     * Syntactically invalid rules (tolerant mode only).
     */
    Invalid = "Invalid",
    /**
     * Comment rules, such as comment rules, metadata rules, preprocessor rules, etc.
     */
    Comment = "Comment",
    /**
     * Cosmetic rules, such as element hiding rules, CSS rules, scriptlet rules, HTML rules, and JS rules.
     */
    Cosmetic = "Cosmetic",
    /**
     * Network rules, such as basic network rules, header remover network rules, redirect network rules,
     * response header filtering rules, etc.
     */
    Network = "Network"
}
/**
 * Represents similar types of modifiers values
 * which may be separated by a comma `,` (only for DomainList) or a pipe `|`.
 */
declare const enum ListNodeType {
    Unknown = "Unknown",
    AppList = "AppList",
    DomainList = "DomainList",
    MethodList = "MethodList",
    StealthOptionList = "StealthOptionList"
}
/**
 * Represents child items for {@link ListNodeType}.
 */
declare enum ListItemNodeType {
    Unknown = "Unknown",
    App = "App",
    Domain = "Domain",
    Method = "Method",
    StealthOption = "StealthOption"
}
/**
 * Represents possible comment types.
 */
declare enum CommentRuleType {
    AgentCommentRule = "AgentCommentRule",
    CommentRule = "CommentRule",
    ConfigCommentRule = "ConfigCommentRule",
    HintCommentRule = "HintCommentRule",
    MetadataCommentRule = "MetadataCommentRule",
    PreProcessorCommentRule = "PreProcessorCommentRule"
}
/**
 * Represents possible cosmetic rule types.
 */
declare enum CosmeticRuleType {
    ElementHidingRule = "ElementHidingRule",
    CssInjectionRule = "CssInjectionRule",
    ScriptletInjectionRule = "ScriptletInjectionRule",
    HtmlFilteringRule = "HtmlFilteringRule",
    JsInjectionRule = "JsInjectionRule"
}
/**
 * Represents possible cosmetic rule separators.
 */
declare const enum CosmeticRuleSeparator {
    /**
     * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#elemhide_basic}
     */
    ElementHiding = "##",
    /**
     * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#elemhide_basic}
     */
    ElementHidingException = "#@#",
    /**
     * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#elemhide_basic}
     */
    ExtendedElementHiding = "#?#",
    /**
     * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#elemhide_basic}
     */
    ExtendedElementHidingException = "#@?#",
    /**
     * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#elemhide_basic}
     */
    AbpSnippet = "#$#",
    /**
     * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#elemhide_basic}
     */
    AbpSnippetException = "#@$#",
    /**
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-css-rules}
     */
    AdgCssInjection = "#$#",
    /**
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-css-rules}
     */
    AdgCssInjectionException = "#@$#",
    /**
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-css-rules}
     */
    AdgExtendedCssInjection = "#$?#",
    /**
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-css-rules}
     */
    AdgExtendedCssInjectionException = "#@$?#",
    /**
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#scriptlets}
     */
    AdgJsInjection = "#%#",
    /**
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#scriptlets}
     */
    AdgJsInjectionException = "#@%#",
    /**
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#html-filtering-rules}
     */
    AdgHtmlFiltering = "$$",
    /**
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#html-filtering-rules}
     */
    AdgHtmlFilteringException = "$@$"
}
/**
 * Represents a basic node in the AST.
 */
interface Node {
    /**
     * The type of the node. Every node should have a type.
     */
    type: string;
    /**
     * Optionally the raw representation of the node in the source code.
     */
    raw?: string;
    /**
     * Start offset of the node.
     */
    start?: number;
    /**
     * End offset of the node.
     */
    end?: number;
}
/**
 * Represents a location in the source code.
 */
interface Location {
    /**
     * Zero-based index of the first character of the parsed source region.
     */
    offset: number;
    /**
     * One-based line index of the first character of the parsed source region.
     */
    line: number;
    /**
     * One-based column index of the first character of the parsed source region.
     */
    column: number;
}
/**
 * Represents a location range in the source code.
 */
interface LocationRange {
    /**
     * The start location of the node.
     */
    start: Location;
    /**
     * The end location of the node.
     */
    end: Location;
}
/**
 * Represents a basic value node in the AST.
 */
interface Value<T = string> extends Node {
    type: 'Value';
    /**
     * Value of the node.
     */
    value: T;
}
/**
 * Represents a list of parameters.
 */
interface ParameterList extends Node {
    type: 'ParameterList';
    /**
     * List of values
     *
     * @note `null` values are allowed in the list, they represent empty parameters.
     */
    children: (Value | null)[];
}
/**
 * Represents a logical expression variable node in the AST.
 */
interface ExpressionVariableNode extends Node {
    type: 'Variable';
    name: string;
}
/**
 * Represents a logical expression operator node in the AST.
 */
interface ExpressionOperatorNode extends Node {
    type: 'Operator';
    operator: OperatorValue;
    left: AnyExpressionNode;
    right?: AnyExpressionNode;
}
/**
 * Represents a logical expression parenthesis node in the AST.
 */
interface ExpressionParenthesisNode extends Node {
    type: 'Parenthesis';
    expression: AnyExpressionNode;
}
/**
 * Represents a filter list (list of rules).
 */
interface FilterList extends Node {
    type: 'FilterList';
    /**
     * List of rules
     */
    children: AnyRule[];
}
/**
 * Represents a basic adblock rule. Every adblock rule should extend this interface.
 * We don't use this interface directly, so we don't specify the `type` property.
 */
interface RuleBase extends Node {
    /**
     * Syntax of the adblock rule. If we are not able to determine the syntax of the rule,
     * we should use `AdblockSyntax.Common` as the value.
     */
    syntax: AdblockSyntax;
    /**
     * Category of the adblock rule
     */
    category: RuleCategory;
    /**
     * Raw data of the rule
     */
    raws?: {
        /**
         * Original rule text
         */
        text?: string;
        /**
         * Newline character used in the rule (if any)
         */
        nl?: NewLine;
    };
}
interface InvalidRuleError extends Node {
    type: 'InvalidRuleError';
    /**
     * Error name
     */
    name: string;
    /**
     * Error message
     */
    message: string;
}
/**
 * Represents an invalid rule (used by tolerant mode).
 */
interface InvalidRule extends RuleBase {
    type: 'InvalidRule';
    /**
     * Category of the adblock rule
     */
    category: RuleCategory.Invalid;
    /**
     * Raw rule text
     */
    raw: string;
    /**
     * Error details
     */
    error: InvalidRuleError;
}
/**
 * Represents an "empty rule" (practically an empty line)
 */
interface EmptyRule extends RuleBase {
    /**
     * Type of the adblock rule (should be always present)
     */
    type: 'EmptyRule';
    /**
     * Category of the adblock rule
     */
    category: RuleCategory.Empty;
}
/**
 * Represents the basic comment rule interface.
 */
interface CommentBase extends RuleBase {
    category: RuleCategory.Comment;
    type: CommentRuleType;
}
/**
 * Represents a simple comment.
 *
 * @example
 * Example rules:
 *   - ```adblock
 *     ! This is just a comment
 *     ```
 *   - ```adblock
 *     # This is just a comment
 *     ```
 */
interface CommentRule extends CommentBase {
    type: CommentRuleType.CommentRule;
    /**
     * Comment marker.
     *
     * @example
     * - If the rule is `! This is just a comment`, then the marker will be `!`.
     * - If the rule is `# This is just a comment`, then the marker will be `#`.
     */
    marker: Value;
    /**
     * Comment text.
     *
     * @example
     * If the rule is `! This is just a comment`, then the text will be `This is just a comment`.
     */
    text: Value;
}
/**
 * Represents a metadata comment rule. This is a special comment that specifies
 * the name and value of the metadata header.
 *
 * @example
 * For example, in the case of
 * ```adblock
 * ! Title: My List
 * ```
 * the name of the header is `Title`, and the value is `My List`.
 */
interface MetadataCommentRule extends CommentBase {
    type: CommentRuleType.MetadataCommentRule;
    /**
     * Comment marker.
     */
    marker: Value;
    /**
     * Metadata header name.
     */
    header: Value;
    /**
     * Metadata header value (always should present).
     */
    value: Value;
}
/**
 * Represents an AGLint configuration node.
 *
 * Used within config comments.
 *
 * @example
 * ```adblock
 * ! aglint "rule-1": ["warn", { "option1": "value1" }], "rule-2": "off"
 * !        ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑
 * ```
 */
interface ConfigNode extends Node {
    type: 'ConfigNode';
    value: object;
}
/**
 * Represents an inline linter configuration comment.
 *
 * @example
 * For example, if the comment is
 * ```adblock
 * ! aglint-disable some-rule another-rule
 * ```
 * then the command is `aglint-disable` and its params is `["some-rule", "another-rule"]`.
 */
interface ConfigCommentRule extends CommentBase {
    category: RuleCategory.Comment;
    type: CommentRuleType.ConfigCommentRule;
    /**
     * The marker for the comment. It can be `!` or `#`. It is always the first non-whitespace character in the comment.
     */
    marker: Value;
    /**
     * The command for the comment. It is always begins with the `aglint` prefix.
     *
     * @example
     * ```adblock
     * ! aglint-disable-next-line
     * ```
     */
    command: Value;
    /**
     * Params for the command. Can be a rule configuration object or a list of rule names.
     *
     * @example
     * For the following comment:
     * ```adblock
     * ! aglint-disable some-rule another-rule
     * ```
     * the params would be `["some-rule", "another-rule"]`.
     */
    params?: ConfigNode | ParameterList;
    /**
     * Config comment text. The idea is generally the same as in ESLint.
     *
     * @example
     * You can use the following syntax to specify a comment for a config comment:
     * `! aglint-enable -- this is the comment`
     */
    comment?: Value;
}
/**
 * Represents a preprocessor comment.
 *
 * @example
 * For example, if the comment is
 * ```adblock
 * !#if (adguard)
 * ```
 * then the directive's name is `if` and its value is `(adguard)`.
 *
 * In such a case, the parameters must be submitted for further parsing and validation, as this parser only handles
 * the general syntax.
 */
interface PreProcessorCommentRule extends CommentBase {
    category: RuleCategory.Comment;
    type: CommentRuleType.PreProcessorCommentRule;
    /**
     * Name of the directive
     */
    name: Value;
    /**
     * Params (optional)
     */
    params?: Value | ParameterList | AnyExpressionNode;
}
/**
 * Represents an adblock agent.
 */
interface Agent extends Node {
    type: 'Agent';
    /**
     * Adblock name.
     */
    adblock: Value;
    /**
     * Adblock version (if specified).
     */
    version?: Value;
    /**
     * Needed for network rules modifier validation.
     */
    syntax: AdblockSyntax;
}
/**
 * Represents an agent comment rule.
 *
 * @example
 * - ```adblock
 *   [Adblock Plus 2.0]
 *   ```
 * - ```adblock
 *   [uBlock Origin 1.16.4; AdGuard 1.0]
 *   ```
 */
interface AgentCommentRule extends RuleBase {
    category: RuleCategory.Comment;
    type: CommentRuleType.AgentCommentRule;
    /**
     * Agent list.
     */
    children: Agent[];
}
/**
 * Represents a hint.
 *
 * @example
 * ```adblock
 * !+ PLATFORM(windows, mac)
 * ```
 * the name would be `PLATFORM` and the params would be `["windows", "mac"]`.
 */
interface Hint extends Node {
    type: 'Hint';
    /**
     * Hint name.
     *
     * @example
     * For `PLATFORM(windows, mac)` the name would be `PLATFORM`.
     */
    name: Value;
    /**
     * Hint parameters.
     *
     * @example
     * For `PLATFORM(windows, mac)` the params would be `["windows", "mac"]`.
     */
    params?: ParameterList;
}
/**
 * Represents a hint comment rule.
 *
 * There can be several hints in a hint rule.
 *
 * @example
 * If the rule is
 * ```adblock
 * !+ NOT_OPTIMIZED PLATFORM(windows)
 * ```
 * then there are two hint members: `NOT_OPTIMIZED` and `PLATFORM`.
 */
interface HintCommentRule extends RuleBase {
    category: RuleCategory.Comment;
    type: CommentRuleType.HintCommentRule;
    /**
     * Currently only AdGuard supports hints.
     */
    syntax: AdblockSyntax;
    /**
     * List of hints.
     */
    children: Hint[];
}
/**
 * Represents a modifier list.
 *
 * @example
 * If the rule is
 * ```adblock
 * some-rule$script,domain=example.com
 * ```
 * then the list of modifiers will be `script,domain=example.com`.
 */
interface ModifierList extends Node {
    type: 'ModifierList';
    /**
     * List of modifiers.
     */
    children: Modifier[];
}
/**
 * Represents a modifier.
 *
 * @example
 * If the modifier is `third-party`, the value of the modifier property
 * will be `third-party`, but the value will remain undefined.
 *
 * But if the modifier is `domain=example.com`, then the modifier property will be
 * `domain` and the value property will be `example.com`.
 */
interface Modifier extends Node {
    /**
     * Modifier name
     */
    name: Value;
    /**
     * Is this modifier an exception? For example, `~third-party` is an exception
     */
    exception?: boolean;
    /**
     * Modifier value (optional)
     */
    value?: Value;
}
/**
 * Represents the separator used for various modifier values.
 *
 * @example
 * `||example.com^$app=com.test1.app|TestApp.exe`
 */
type PipeSeparator = typeof PIPE_MODIFIER_SEPARATOR;
/**
 * Represents the separator used for basic rules domain list.
 *
 * @example
 * `example.com,example.org###banner`
 */
type CommaSeparator = typeof COMMA_DOMAIN_LIST_SEPARATOR;
/**
 * Represents the separator used in a domain list.
 *
 * @example
 * - `,` — for the classic domain list,
 * - `|` — for the $domain modifier value
 */
type DomainListSeparator = CommaSeparator | PipeSeparator;
/**
 * Common interface for a list item of $app, $denyallow, $domain, $method
 * which have similar syntax.
 */
interface ListItem<T extends ListItemNodeType> extends Node {
    type: T;
    /**
     * Value of the node.
     */
    value: string;
    /**
     * If the value is an negated.
     *
     * @example
     * `~example.com` is negated, but `example.com` is not. `~` is the exception marker here.
     */
    exception: boolean;
}
/**
 * Represents an element of the app list — $app.
 */
type App = ListItem<ListItemNodeType.App>;
/**
 * Represents an element of the domain list — $domain, $denyallow.
 */
type Domain = ListItem<ListItemNodeType.Domain>;
/**
 * Represents an element of the method list — $method.
 */
type Method = ListItem<ListItemNodeType.Method>;
/**
 * Represents an element of the stealth option list — $stealth.
 */
type StealthOption = ListItem<ListItemNodeType.StealthOption>;
/**
 * Represents a list of domains.
 * Needed for $domain and $denyallow.
 *
 * @example
 * `example.com,~example.net` or `example.com|~example.net`
 */
interface DomainList extends Node {
    /**
     * Type of the node. Basically, the idea is that each main AST part should have a type
     */
    type: ListNodeType.DomainList;
    /**
     * Separator used in the domain list.
     */
    separator: DomainListSeparator;
    /**
     * List of domains
     */
    children: Domain[];
}
/**
 * Represents a list of apps.
 * Needed for $app.
 *
 * @example
 * `Example.exe|com.example.osx`.
 */
interface AppList extends Node {
    /**
     * Type of the node. Basically, the idea is that each main AST part should have a type
     */
    type: ListNodeType.AppList;
    /**
     * Separator used in the app list.
     */
    separator: PipeSeparator;
    /**
     * List of apps
     */
    children: App[];
}
/**
 * Represents a list of methods.
 * Needed for $method.
 *
 * @example
 * `get|post|put`.
 */
interface MethodList extends Node {
    /**
     * Type of the node. Basically, the idea is that each main AST part should have a type
     */
    type: ListNodeType.MethodList;
    /**
     * Separator used in the method list.
     */
    separator: PipeSeparator;
    /**
     * List of methods
     */
    children: Method[];
}
/**
 * Represents a list of stealth options.
 * Needed for $stealth.
 *
 * @example
 * `referrer|ip`.
 */
interface StealthOptionList extends Node {
    /**
     * Type of the node. Basically, the idea is that each main AST part should have a type
     */
    type: ListNodeType.StealthOptionList;
    /**
     * Separator used in the stealth option list.
     */
    separator: PipeSeparator;
    /**
     * List of stealth options
     */
    children: StealthOption[];
}
/**
 * Represents a CSS injection body.
 */
interface CssInjectionRuleBody extends Node {
    type: 'CssInjectionRuleBody';
    /**
     * Media query, if any.
     *
     * @example
     *
     * ```text
     * @media (max-width: 768px) { ... }
     *         ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑
     * ```
     */
    mediaQueryList?: Value;
    /**
     * CSS selector list.
     *
     * @example
     * section:has(> .ad) { display: none; }
     * ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑
     * section:has(> .ad), article > p[advert] { display: none; }
     * ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑
     */
    selectorList: Value;
    /**
     * Declaration list.
     *
     * @example
     * section:has(> .ad) { display: none; }
     *                      ↑↑↑↑↑↑↑↑↑↑↑↑↑↑
     * section:has(> .ad), article > p[advert] { display: none; }
     *                                           ↑↑↑↑↑↑↑↑↑↑↑↑↑↑
     * div[ad] { padding-top: 10px; padding-bottom: 10px; }
     *           ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑
     */
    declarationList?: Value;
    /**
     * Remove flag
     */
    remove?: boolean;
}
/**
 * Represents an element hiding rule body. There can even be several selectors in a rule,
 * but the best practice is to place the selectors in separate rules.
 */
interface ElementHidingRuleBody extends Node {
    type: 'ElementHidingRuleBody';
    /**
     * Element hiding rule selector(s).
     */
    selectorList: Value;
}
/**
 * Represents a scriptlet injection rule body.
 */
interface ScriptletInjectionRuleBody extends Node {
    type: 'ScriptletInjectionRuleBody';
    /**
     * List of scriptlets (list of parameter lists).
     */
    children: ParameterList[];
}
/**
 * Represents an HTML filtering rule body.
 */
interface HtmlFilteringRuleBody extends Node {
    type: 'HtmlFilteringRuleBody';
    /**
     * HTML rule selector(s).
     */
    body: Value;
}
/**
 * A generic representation of a cosmetic rule.
 *
 * Regarding the categories, there is only a difference in the body,
 * all other properties can be defined at this level.
 */
interface CosmeticRule extends RuleBase {
    category: RuleCategory.Cosmetic;
    type: CosmeticRuleType;
    /**
     * List of modifiers (optional)
     */
    modifiers?: ModifierList;
    /**
     * List of domains.
     */
    domains: DomainList;
    /**
     * Separator between pattern and body. For example, in the following rule:
     * ```adblock
     * example.com##.ads
     * ```
     * then the separator is `##`.
     */
    separator: Value;
    /**
     * If the rule is an exception. For example, in the following rule:
     * ```adblock
     * example.com#@#.ads
     * ```
     * then the rule is an exception and @ is the exception marker.
     */
    exception: boolean;
    /**
     * Body of the rule. It can be a CSS rule, an element hiding rule, a scriptlet rule, etc.
     */
    body: unknown;
}
/**
 * Representation of an element hiding rule.
 *
 * Example rules:
 * - ```adblock
 *   example.com##.ads
 *   ```
 * - ```adblock
 *   example.com#@#.ads
 *   ```
 * - ```adblock
 *   example.com#?#.ads:has(> .something)
 *   ```
 * - ```adblock
 *   example.com#@?#.ads:has(> .something)
 *   ```
 */
interface ElementHidingRule extends CosmeticRule {
    type: CosmeticRuleType.ElementHidingRule;
    body: ElementHidingRuleBody;
}
/**
 * Representation of a CSS injection rule.
 *
 * Example rules (AdGuard):
 *  - ```adblock
 *    example.com#$#body { padding-top: 0 !important; }
 *    ```
 *  - ```adblock
 *    example.com#$#@media (min-width: 1024px) { body { padding-top: 0 !important; } }
 *    ```
 *  - ```adblock
 *    example.com#$?#@media (min-width: 1024px) { .something:has(.ads) { padding-top: 0 !important; } }
 *    ```
 *  - ```adblock
 *    example.com#$#.ads { remove: true; }
 *    ```
 *
 * Example rules (uBlock Origin):
 *  - ```adblock
 *    example.com##body:style(padding-top: 0 !important;)
 *    ```
 *  - ```adblock
 *    example.com##.ads:remove()
 *    ```
 */
interface CssInjectionRule extends CosmeticRule {
    type: CosmeticRuleType.CssInjectionRule;
    body: CssInjectionRuleBody;
}
/**
 * Representation of a scriptlet injection rule.
 *
 * Example rules (AdGuard):
 *  - ```adblock
 *    example.com#%#//scriptlet('scriptlet-name', 'arg0', 'arg1')
 *    ```
 *  - ```adblock
 *    example.com#@%#//scriptlet('scriptlet-name', 'arg0', 'arg1')
 *    ```
 *
 * Example rules (uBlock Origin):
 *  - ```adblock
 *    example.com##+js(scriptlet-name, arg0, arg1)
 *    ```
 *  - ```adblock
 *    example.com#@#+js(scriptlet-name, arg0, arg1)
 *    ```
 *
 * Example rules (Adblock Plus):
 *  - ```adblock
 *    example.com#$#scriptlet-name arg0 arg1
 *    ```
 *  - ```adblock
 *    example.com#@$#scriptlet-name arg0 arg1
 *    ```
 *  - ```adblock
 *    example.com#$#scriptlet0 arg00 arg01; scriptlet1 arg10 arg11
 *    ```
 */
interface ScriptletInjectionRule extends CosmeticRule {
    type: CosmeticRuleType.ScriptletInjectionRule;
    body: ScriptletInjectionRuleBody;
}
/**
 * Representation of a HTML filtering rule.
 *
 * Example rules (AdGuard):
 *  - ```adblock
 *    example.com$$script[tag-content="detect"]
 *    ```
 *  - ```adblock
 *    example.com$@$script[tag-content="detect"]
 *    ```
 *
 * Example rules (uBlock Origin):
 *  - ```adblock
 *    example.com##^script:has-text(detect)
 *    ```
 *  - ```adblock
 *    example.com#@#^script:has-text(detect)
 *    ```
 */
interface HtmlFilteringRule extends CosmeticRule {
    type: CosmeticRuleType.HtmlFilteringRule;
    body: Value;
}
/**
 * Representation of a JS injection rule.
 *
 * Example rules (AdGuard):
 *  - ```adblock
 *    example.com#%#let a = 2;
 *    ```
 *  - ```adblock
 *    example.com#@%#let a = 2;
 *    ```
 */
interface JsInjectionRule extends CosmeticRule {
    type: CosmeticRuleType.JsInjectionRule;
    body: Value;
}
/**
 * Represents the different types of network rules.
 */
declare enum NetworkRuleType {
    NetworkRule = "NetworkRule",
    HostRule = "HostRule"
}
/**
 * Represents the common properties of network rules
 */
interface NetworkRuleBase extends RuleBase {
    /**
     * Category of the adblock rule.
     */
    category: RuleCategory.Network;
    /**
     * Type of the network rule.
     */
    type: NetworkRuleType;
    /**
     * Syntax of the adblock rule. If we are not able to determine the syntax of the rule,
     * we should use `AdblockSyntax.Common` as the value.
     */
    syntax: AdblockSyntax;
}
/**
 * Represents the common properties of network rules
 */
interface NetworkRule extends NetworkRuleBase {
    /**
     * Type of the node.
     */
    type: NetworkRuleType.NetworkRule;
    /**
     * If the rule is an exception rule. If the rule begins with `@@`, it means that it is an exception rule.
     *
     * @example
     * The following rule is an exception rule:
     * ```adblock
     * @@||example.org^
     * ```
     * since it begins with `@@`, which is the exception marker.
     *
     * But the following rule is not an exception rule:
     * ```adblock
     * ||example.org^
     * ```
     * since it does not begins with `@@`.
     */
    exception: boolean;
    /**
     * The rule pattern.
     *
     * @example
     * - Let's say we have the following rule:
     *   ```adblock
     *   ||example.org^
     *   ```
     *   then the pattern of this rule is `||example.org^`.
     * - But let's say we have the following rule:
     *   ```adblock
     *   ||example.org^$third-party,script
     *   ```
     *   then the pattern of this rule is also `||example.org^`.
     */
    pattern: Value;
    /**
     * The rule modifiers.
     *
     * @example
     * - Let's say we have the following rule:
     *   ```adblock
     *   ||example.org^$third-party
     *   ```
     *   then the modifiers of this rule are `["third-party"]`.
     */
    modifiers?: ModifierList;
}
/**
 * Represents a list of hostnames.
 */
interface HostnameList extends Node {
    /**
     * Type of the node.
     */
    type: 'HostnameList';
    /**
     * List of hostnames.
     */
    children: Value[];
}
/**
 * Represents the common properties of host rules.
 *
 * @see https://adguard-dns.io/kb/general/dns-filtering-syntax/#etc-hosts-syntax
 */
interface HostRule extends NetworkRuleBase {
    /**
     * Type of the node.
     */
    type: NetworkRuleType.HostRule;
    /**
     * IP address. It can be an IPv4 or IPv6 address.
     *
     * @example
     * ```text
     * 127.0.0.1 example.com example.org
     * ↑↑↑↑↑↑↑↑↑
     * ```
     * @note If IP is not specified in the rule, it parsed as null IP: `0.0.0.0`.
     */
    ip: Value;
    /**
     * Hostnames.
     *
     * @example
     * ```text
     * 127.0.0.1 example.com example.org
     *           ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑
     * ```
     */
    hostnames: HostnameList;
    /**
     * Comment (optional).
     *
     * @example
     * ```text
     * 127.0.0.1 localhost # This is just a comment
     *                     ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑
     * ```
     */
    comment?: Value;
}

/**
 * @file Core ByteBuffer implementation for handling binary data in chunks.
 */
/**
 * Core ByteBuffer implementation for handling binary data in chunks.
 * This class allows for efficient byte storage and manipulation by organizing data into chunks
 * and providing methods to read and write bytes.
 */
declare class ByteBuffer {
    /**
     * The size of each chunk in bytes (32 KB).
     */
    static readonly CHUNK_SIZE = 32768;
    /**
     * An array of Uint8Array chunks that make up the buffer.
     */
    protected chunks: Uint8Array[];
    /**
     * The total number of chunks in the buffer.
     */
    protected chunksLength: number;
    /**
     * Constructs a new ByteBuffer instance.
     *
     * @param chunks Optional array of chunks to initialize the ByteBuffer with.
     * @param cloneChunks Flag indicating if the chunks should be cloned. For performance reasons,
     * its default value is `false`. If the original chunks are guaranteed not to change,
     * leave this flag as `false` to avoid unnecessary copying.
     */
    constructor(chunks?: Uint8Array[], cloneChunks?: boolean);
    /**
     * Ensures that the buffer has enough capacity to accommodate a given position.
     * This method adjusts the `chunks` array size to ensure it can hold the specified position.
     *
     * @param position The position to ensure capacity for.
     */
    protected ensureCapacity(position: number): void;
    /**
     * Writes a byte to the buffer at the specified position.
     * If the position is outside of the buffer's current size, the buffer is resized to accommodate it.
     *
     * @param position The position at which to write the byte.
     * @param value The byte value to write (0-255).
     */
    protected writeByte(position: number, value: number): void;
    /**
     * Reads a byte from the specified position in the buffer.
     * Returns `undefined` if the position is outside of the buffer's current size.
     *
     * @param position The position from which to read the byte.
     * @returns The read byte value, or `undefined` if the position is out of bounds.
     */
    protected readByte(position: number): number | undefined;
}

/**
 * @file Represents a storage interface for reading and writing data.
 */
/**
 * Represents a storage interface for reading and writing data.
 */
interface Storage<K = string, V = unknown> {
    /**
     * Writes the given data to the storage with the specified key.
     *
     * @param key The key to identify the data in the storage.
     * @param chunks The data to write to the storage.
     * @returns A promise that resolves when the write operation is complete.
     */
    set(key: K, data: V): Promise<void>;
    /**
     * Reads the data from the storage with the specified key.
     *
     * @param key The key to identify the data in the storage.
     * @returns A promise that resolves with the data read from the storage.
     */
    get(key: K): Promise<V | undefined>;
}

/**
 * @file Input byte buffer for reading binary data.
 */

/**
 * Input byte buffer for reading binary data.
 *
 * @note Internally, this class uses a {@link ByteBuffer} instance, just providing a convenient API for reading data.
 */
declare class InputByteBuffer extends ByteBuffer {
    /**
     * Current offset in the buffer for reading.
     */
    private offset;
    /**
     * Shared native decoder for decoding strings.
     */
    private readonly sharedNativeDecoder;
    /**
     * Flag indicating if the current environment is Chromium.
     * This is used for performance optimizations, because Chromium's TextEncoder/TextDecoder has a relatively
     * large marshalling overhead for small strings.
     */
    private readonly isChromium;
    /**
     * Constructs a new `InputByteBuffer` instance.
     *
     * @param chunks Array of chunks to initialize the ByteBuffer with.
     * @param cloneChunks Flag indicating if the chunks should be cloned. For performance reasons,
     * its default value is `false`. If the original chunks are guaranteed not to change,
     * leave this flag as `false` to avoid unnecessary copying.
     * @param initialOffset Initial offset in the buffer for reading.
     *
     * @throws If the specified chunks array is empty.
     * @throws If the binary schema version in the buffer is not equal to the expected version.
     * @throws If the initial offset is out of bounds.
     */
    constructor(chunks: Uint8Array[], cloneChunks?: boolean, initialOffset?: number);
    /**
     * Creates a new InputByteBuffer instance from a Storage instance by reading chunks from the storage.
     *
     * @param storage Storage instance.
     * @param key Key to read from the storage.
     * @returns New InputByteBuffer instance.
     * @note For performance reasons, chunks are passed by reference and not copied.
     */
    static createFromStorage(storage: Storage, key: string): Promise<InputByteBuffer>;
    /**
     * Reads a 8-bit unsigned integer from the buffer.
     *
     * @returns 8-bit unsigned integer from the buffer.
     */
    readUint8(): number;
    /**
     * Reads a 16-bit unsigned integer from the buffer.
     *
     * @returns 16-bit unsigned integer from the buffer.
     */
    readUint16(): number;
    /**
     * Reads a 32-bit unsigned integer from the buffer at the specified index.
     *
     * @param index Index to read the 32-bit unsigned integer from.
     *
     * @returns 32-bit unsigned integer from the buffer.
     */
    private readUint32FromIndex;
    /**
     * Reads a 32-bit unsigned integer from the buffer.
     *
     * @returns 32-bit unsigned integer from the buffer.
     */
    readUint32(): number;
    /**
     * Reads schema version from the buffer.
     *
     * @returns 32-bit unsigned integer from the buffer.
     * @note Schema version is always stored at the beginning of the buffer.
     */
    readSchemaVersion(): number;
    /**
     * Reads a 32-bit signed integer from the buffer.
     *
     * @returns 32-bit signed integer from the buffer.
     */
    readInt32(): number;
    /**
     * Reads an optimized unsigned integer from the buffer.
     * 'Optimized' means that the integer is stored in a variable number of bytes, depending on its value,
     * so that smaller numbers occupy less space.
     *
     * @returns Decoded unsigned integer from the buffer.
     */
    readOptimizedUint(): number;
    /**
     * Reads a string from the buffer.
     *
     * @returns Decoded string from the buffer.
     */
    readString(): string;
    /**
     * Reads a 8-bit unsigned integer from the buffer without advancing the offset.
     *
     * @returns 8-bit unsigned integer from the buffer.
     */
    peekUint8(): number;
    /**
     * Helper method for asserting the next 8-bit unsigned integer in the buffer.
     *
     * @param value Expected value.
     * @throws If the next value in the buffer is not equal to the expected value.
     */
    assertUint8(value: number): void;
    /**
     * Creates a new `InputByteBuffer` instance with the given initial offset.
     *
     * @param initialOffset Initial offset for the new buffer.
     * @param cloneChunks Flag indicating if the chunks should be cloned. For performance reasons,
     * its default value is `false`. If the original chunks are guaranteed not to change,
     * leave this flag as `false` to avoid unnecessary copying.
     *
     * @returns New `InputByteBuffer` instance with the given initial offset.
     *
     * @note This method is useful if you want to read some data from a specific index.
     */
    createCopyWithOffset(initialOffset: number, cloneChunks?: boolean): InputByteBuffer;
    /**
     * Gets the current offset in the buffer for reading.
     *
     * @returns Current offset in the buffer for reading.
     */
    get currentOffset(): number;
    /**
     * Gets the capacity of the buffer.
     *
     * @returns Capacity of the buffer.
     */
    get capacity(): number;
}

/**
 * Output byte buffer for writing binary data.
 *
 * @note Internally, this class uses a {@link ByteBuffer} instance, just providing a convenient API for reading data.
 */
declare class OutputByteBuffer extends ByteBuffer {
    /**
     * Current offset in the buffer for writing.
     */
    private offset;
    /**
     * Size of the shared buffer for encoding strings in bytes.
     * This is a divisor of ByteBuffer.CHUNK_SIZE and experience shows that this value works optimally.
     * This is sufficient for most strings that occur in filter lists (we checked average string length in popular
     * filter lists).
     */
    private static readonly ENCODER_BUFFER_SIZE;
    /**
     * Length threshold for using a shared buffer for encoding strings.
     * This temp buffer is needed because we write the short strings in it
     * (so there is no need to constantly allocate a new buffer).
     * The reason for dividing ENCODER_BUFFER_SIZE by 4 is to ensure that the encoded string fits in the buffer,
     * if we also take into account the worst possible case (each character is encoded with 4 bytes).
     */
    private static readonly SHORT_STRING_THRESHOLD;
    /**
     * Represents the maximum value that can be written as a 'storage optimized' unsigned integer.
     * 0x1FFFFFFF means 29 bits — 32 bits minus 3 bits — because the last bit in each byte is a flag indicating
     * if there are more bytes (except for the last byte).
     */
    static MAX_OPTIMIZED_UINT: number;
    /**
     * Shared buffer for encoding strings.
     */
    private readonly sharedBuffer;
    /**
     * Shared native encoder for encoding strings.
     */
    private readonly sharedNativeEncoder;
    /**
     * Flag indicating if the current environment is Chromium.
     * This is used for performance optimizations, because Chromium's TextEncoder/TextDecoder has a relatively
     * large marshalling overhead for small strings.
     */
    private readonly isChromium;
    /**
     * Constructs a new OutputByteBuffer instance.
     */
    constructor();
    /**
     * Writes a 8-bit unsigned integer to the buffer.
     *
     * @param value Value to write.
     * @returns Number of bytes written to the buffer.
     */
    writeUint8(value: number): number;
    /**
     * Writes a 16-bit unsigned integer to the buffer.
     *
     * @param value Value to write.
     * @returns Number of bytes written to the buffer.
     */
    writeUint16(value: number): number;
    /**
     * Writes a 32-bit unsigned integer to the buffer at a specific index.
     *
     * @param value Value to write.
     * @param index Index to write the value to.
     * @returns Number of bytes written to the buffer.
     */
    private writeUint32ToIndex;
    /**
     * Writes a 32-bit unsigned integer to the buffer.
     *
     * @param value Value to write.
     * @returns Number of bytes written to the buffer.
     */
    writeUint32(value: number): number;
    /**
     * Writes a 32-bit signed integer to the buffer.
     *
     * @param value Value to write.
     * @returns Number of bytes written to the buffer.
     */
    writeInt32(value: number): number;
    /**
     * Writes a Uint8Array to the byte buffer.
     *
     * @param buffer Buffer to write.
     */
    private writeBuffer;
    /**
     * Writes a string to the buffer.
     *
     * @param value Value to write.
     * @returns Number of bytes written to the buffer.
     */
    writeString(value: string): number;
    /**
     * Writes chunks to the storage.
     *
     * @param storage Storage to write the chunks to.
     * @param key Key to write the chunks to.
     * @note For performance reasons, chunks are passed by reference and not copied.
     * @throws If the storage write operation throws.
     */
    writeChunksToStorage(storage: Storage, key: string): Promise<void>;
    /**
     * Writes an 'optimized' unsigned integer to the buffer.
     * 'Optimized' means smaller storage usage for smaller numbers.
     * Except for the last byte, each byte's most significant bit is a flag indicating if there are more bytes.
     *
     * @param value Value to write.
     * @returns Number of bytes written to the buffer.
     * @throws If the value exceeds the 29-bit limit.
     */
    writeOptimizedUint(value: number): number;
    /**
     * Gets the current offset in the buffer for writing.
     *
     * @returns Current offset in the buffer for writing.
     */
    get currentOffset(): number;
}

/**
 * Base class for parsers. Each parser should extend this class.
 */
declare class ParserBase {
    /**
     * Parses the input string and returns the AST node.
     *
     * @param input Input string to parse.
     * @param options Parser options, see {@link ParserOptions}.
     * @param baseOffset Base offset. Locations in the AST node will be relative to this offset.
     * @param args Additional, parser-specific arguments, if needed.
     */
    static parse(input: string, options: ParserOptions, baseOffset: number, ...args: unknown[]): Node | null;
    /**
     * Generates a string from the AST node.
     *
     * @param node AST node to generate a string from.
     */
    static generate(node: Node): string;
    /**
     * Serializes the AST node to a byte buffer.
     *
     * @param node AST node to serialize.
     * @param buffer Output byte buffer to write to.
     * @param args Additional, parser-specific arguments, if needed.
     */
    static serialize(node: Node, buffer: OutputByteBuffer, ...args: unknown[]): void;
    /**
     * Deserializes the AST node from a byte buffer.
     *
     * @param buffer Input byte buffer to read from.
     * @param node Destination node to write to.
     * @param args Additional, parser-specific arguments, if needed.
     */
    static deserialize(buffer: InputByteBuffer, node: Partial<Node>, ...args: unknown[]): void;
}

/**
 * `RuleParser` is responsible for parsing the rules.
 *
 * It automatically determines the category and syntax of the rule, so you can pass any kind of rule to it.
 */
declare class RuleParser extends ParserBase {
    /**
     * Helper method to parse host rules if the `parseHostRules` option is enabled, otherwise it will
     * parse network rules.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Host rule or network rule node.
     */
    private static parseHostOrNetworkRule;
    /**
     * Parse an adblock rule. You can pass any kind of rule to this method, since it will automatically determine
     * the category and syntax. If the rule is syntactically invalid, then an error will be thrown. If the
     * syntax / compatibility cannot be determined clearly, then the value of the `syntax` property will be
     * `Common`.
     *
     * For example, let's have this network rule:
     * ```adblock
     * ||example.org^$important
     * ```
     * The `syntax` property will be `Common`, since the rule is syntactically correct in every adblockers, but we
     * cannot determine at parsing level whether `important` is an existing option or not, nor if it exists, then
     * which adblocker supports it. This is why the `syntax` property is simply `Common` at this point.
     * The concrete COMPATIBILITY of the rule will be determined later, in a different, higher-level layer, called
     * "Compatibility table".
     *
     * But we can determinate the concrete syntax of this rule:
     * ```adblock
     * example.org#%#//scriptlet("scriptlet0", "arg0")
     * ```
     * since it is clearly an AdGuard-specific rule and no other adblockers uses this syntax natively. However, we also
     * cannot determine the COMPATIBILITY of this rule, as it is not clear at this point whether the `scriptlet0`
     * scriptlet is supported by AdGuard or not. This is also the task of the "Compatibility table". Here, we simply
     * mark the rule with the `AdGuard` syntax in this case.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Adblock rule node
     * @throws If the input matches a pattern but syntactically invalid
     * @example
     * Take a look at the following example:
     * ```js
     * // Parse a network rule
     * const ast1 = RuleParser.parse("||example.org^$important");
     *
     * // Parse another network rule
     * const ast2 = RuleParser.parse("/ads.js^$important,third-party,domain=example.org|~example.com");
     *
     * // Parse a cosmetic rule
     * const ast2 = RuleParser.parse("example.org##.banner");
     *
     * // Parse another cosmetic rule
     * const ast3 = RuleParser.parse("example.org#?#.banner:-abp-has(.ad)");
     *
     * // Parse a comment rule
     * const ast4 = RuleParser.parse("! Comment");
     *
     * // Parse an empty rule
     * const ast5 = RuleParser.parse("");
     *
     * // Parse a comment rule (with metadata)
     * const ast6 = RuleParser.parse("! Title: Example");
     *
     * // Parse a pre-processor rule
     * const ast7 = RuleParser.parse("!#if (adguard)");
     * ```
     */
    static parse(raw: string, options?: ParserOptions, baseOffset?: number): AnyRule;
    /**
     * Converts a rule AST to a string.
     *
     * @param ast - Adblock rule AST
     * @returns Raw string
     * @example
     * Take a look at the following example:
     * ```js
     * // Parse the rule to the AST
     * const ast = RuleParser.parse("example.org##.banner");
     * // Generate the rule from the AST
     * const raw = RuleParser.generate(ast);
     * // Print the generated rule
     * console.log(raw); // "example.org##.banner"
     * ```
     */
    static generate(ast: AnyRule): string;
    /**
     * Serializes an empty rule node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serializeEmptyRule(node: EmptyRule, buffer: OutputByteBuffer): void;
    /**
     * Deserializes an empty rule node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserializeEmptyRule(buffer: InputByteBuffer, node: EmptyRule): void;
    /**
     * Serializes an invalid rule error node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serializeInvalidRuleErrorNode(node: InvalidRuleError, buffer: OutputByteBuffer): void;
    /**
     * Deserializes an invalid rule error node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserializeInvalidRuleErrorNode(buffer: InputByteBuffer, node: Partial<InvalidRuleError>): void;
    /**
     * Serializes an invalid rule node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serializeInvalidRule(node: InvalidRule, buffer: OutputByteBuffer): void;
    /**
     * Deserializes an invalid rule node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserializeInvalidRule(buffer: InputByteBuffer, node: InvalidRule): void;
    /**
     * Serializes a rule node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node: AnyRule, buffer: OutputByteBuffer): void;
    /**
     * Deserializes a rule node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer: InputByteBuffer, node: Partial<AnyRule>): void;
}

/**
 * @file Customized syntax error class for Adblock Filter Parser.
 */
/**
 * Customized syntax error class for Adblock Filter Parser,
 * which contains the location range of the error.
 */
declare class AdblockSyntaxError extends SyntaxError {
    /**
     * Start offset of the error.
     */
    start: number;
    /**
     * End offset of the error.
     */
    end: number;
    /**
     * Constructs a new `AdblockSyntaxError` instance.
     *
     * @param message Error message.
     * @param start Start offset of the error.
     * @param end End offset of the error.
     */
    constructor(message: string, start: number, end: number);
}

/**
 * `AgentParser` is responsible for parsing an Adblock agent rules.
 * Adblock agent comment marks that the filter list is supposed to
 * be used by the specified ad blockers.
 *
 * @example
 *  - ```adblock
 *    [AdGuard]
 *    ```
 *  - ```adblock
 *    [Adblock Plus 2.0]
 *    ```
 *  - ```adblock
 *    [uBlock Origin]
 *    ```
 *  - ```adblock
 *    [uBlock Origin 1.45.3]
 *    ```
 *  - ```adblock
 *    [Adblock Plus 2.0; AdGuard]
 *    ```
 */
declare class AgentCommentRuleParser extends ParserBase {
    /**
     * Checks if the raw rule is an adblock agent comment.
     *
     * @param raw Raw rule
     * @returns `true` if the rule is an adblock agent, `false` otherwise
     */
    static isAgentRule(raw: string): boolean;
    /**
     * Parses a raw rule as an adblock agent comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Agent rule AST or null (if the raw rule cannot be parsed as an adblock agent comment)
     */
    static parse(raw: string, options?: ParserOptions, baseOffset?: number): AgentCommentRule | null;
    /**
     * Converts an adblock agent AST to a string.
     *
     * @param ast Agent rule AST
     * @returns Raw string
     */
    static generate(ast: AgentCommentRule): string;
    /**
     * Serializes an adblock agent list node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node: AgentCommentRule, buffer: OutputByteBuffer): void;
    /**
     * Deserializes an agent list node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer: InputByteBuffer, node: Partial<AgentCommentRule>): void;
}

/**
 * `AgentParser` is responsible for parsing single adblock agent elements.
 *
 * @example
 * If the adblock agent rule is
 * ```adblock
 * [Adblock Plus 2.0; AdGuard]
 * ```
 * then the adblock agents are `Adblock Plus 2.0` and `AdGuard`, and this
 * class is responsible for parsing them. The rule itself is parsed by
 * `AgentCommentRuleParser`, which uses this class to parse single agents.
 */
declare class AgentParser extends ParserBase {
    /**
     * Checks if the string is a valid version.
     *
     * @param str String to check
     * @returns `true` if the string is a valid version, `false` otherwise
     */
    private static isValidVersion;
    /**
     * Parses a raw rule as an adblock agent comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Agent rule AST
     * @throws {AdblockSyntaxError} If the raw rule cannot be parsed as an adblock agent
     */
    static parse(raw: string, options?: ParserOptions, baseOffset?: number): Agent;
    /**
     * Converts an adblock agent node to a string.
     *
     * @param value Agent node
     * @returns Raw string
     */
    static generate(value: Agent): string;
    /**
     * Serializes an agent node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node: Agent, buffer: OutputByteBuffer): void;
    /**
     * Deserializes an agent node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer: InputByteBuffer, node: Partial<Agent>): void;
}

/**
 * `CommentParser` is responsible for parsing any comment-like adblock rules.
 *
 * @example
 * Example rules:
 *  - Adblock agent rules:
 *      - ```adblock
 *        [AdGuard]
 *        ```
 *      - ```adblock
 *        [Adblock Plus 2.0]
 *        ```
 *      - etc.
 *  - AdGuard hint rules:
 *      - ```adblock
 *        !+ NOT_OPTIMIZED
 *        ```
 *      - ```adblock
 *        !+ NOT_OPTIMIZED PLATFORM(windows)
 *        ```
 *      - etc.
 *  - Pre-processor rules:
 *      - ```adblock
 *        !#if (adguard)
 *        ```
 *      - ```adblock
 *        !#endif
 *        ```
 *      - etc.
 *  - Metadata rules:
 *      - ```adblock
 *        ! Title: My List
 *        ```
 *      - ```adblock
 *        ! Version: 2.0.150
 *        ```
 *      - etc.
 *  - AGLint inline config rules:
 *      - ```adblock
 *        ! aglint-enable some-rule
 *        ```
 *      - ```adblock
 *        ! aglint-disable some-rule
 *        ```
 *      - etc.
 *  - Simple comments:
 *      - Regular version:
 *        ```adblock
 *        ! This is just a comment
 *        ```
 *      - uBlock Origin / "hostlist" version:
 *        ```adblock
 *        # This is just a comment
 *        ```
 *      - etc.
 */
declare class CommentRuleParser extends ParserBase {
    /**
     * Checks whether a rule is a comment.
     *
     * @param raw Raw rule
     * @returns `true` if the rule is a comment, `false` otherwise
     */
    static isCommentRule(raw: string): boolean;
    /**
     * Parses a raw rule as comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Comment AST or null (if the raw rule cannot be parsed as comment)
     */
    static parse(raw: string, options?: ParserOptions, baseOffset?: number): AnyCommentRule | null;
    /**
     * Converts a comment rule node to a string.
     *
     * @param node Comment rule node
     * @returns Raw string
     */
    static generate(node: AnyCommentRule): string;
    /**
     * Serializes a comment rule node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node: AnyCommentRule, buffer: OutputByteBuffer): void;
    /**
     * Deserializes a comment rule node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer: InputByteBuffer, node: Partial<AnyCommentRule>): void;
}

/**
 * `ConfigCommentParser` is responsible for parsing inline AGLint configuration rules.
 * Generally, the idea is inspired by ESLint inline configuration comments.
 *
 * @see {@link https://eslint.org/docs/latest/user-guide/configuring/rules#using-configuration-comments}
 */
declare class ConfigCommentRuleParser extends ParserBase {
    /**
     * Checks if the raw rule is an inline configuration comment rule.
     *
     * @param raw Raw rule
     * @returns `true` if the rule is an inline configuration comment rule, otherwise `false`.
     */
    static isConfigComment(raw: string): boolean;
    /**
     * Parses a raw rule as an inline configuration comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns
     * Inline configuration comment AST or null (if the raw rule cannot be parsed as configuration comment)
     */
    static parse(raw: string, options?: ParserOptions, baseOffset?: number): ConfigCommentRule | null;
    /**
     * Converts an inline configuration comment node to a string.
     *
     * @param node Inline configuration comment node
     * @returns Raw string
     */
    static generate(node: ConfigCommentRule): string;
    /**
     * Serializes a config node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    private static serializeConfigNode;
    /**
     * Deserializes a metadata comment node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    private static deserializeConfigNode;
    /**
     * Serializes a metadata comment node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node: ConfigCommentRule, buffer: OutputByteBuffer): void;
    /**
     * Deserializes a metadata comment node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer: InputByteBuffer, node: Partial<ConfigCommentRule>): void;
}

/**
 * `CosmeticRuleParser` is responsible for parsing cosmetic rules.
 *
 * Where possible, it automatically detects the difference between supported syntaxes:
 *  - AdGuard
 *  - uBlock Origin
 *  - Adblock Plus
 *
 * If the syntax is common / cannot be determined, the parser gives `Common` syntax.
 *
 * Please note that syntactically correct rules are parsed even if they are not actually
 * compatible with the given adblocker. This is a completely natural behavior, meaningful
 * checking of compatibility is not done at the parser level.
 */
declare class CosmeticRuleParser extends ParserBase {
    /**
     * Determines whether a rule is a cosmetic rule. The rule is considered cosmetic if it
     * contains a cosmetic rule separator.
     *
     * @param raw Raw rule
     * @returns `true` if the rule is a cosmetic rule, `false` otherwise
     */
    static isCosmeticRule(raw: string): boolean;
    /**
     * Parses a cosmetic rule. The structure of the cosmetic rules:
     *  - pattern (AdGuard pattern can have modifiers, other syntaxes don't)
     *  - separator
     *  - body
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns
     * Parsed cosmetic rule AST or null if it failed to parse based on the known cosmetic rules
     * @throws If the input matches the cosmetic rule pattern but syntactically invalid
     */
    static parse(raw: string, options?: ParserOptions, baseOffset?: number): AnyCosmeticRule | null;
    /**
     * Generates the rule pattern from the AST.
     *
     * @param node Cosmetic rule node
     * @returns Raw rule pattern
     * @example
     * - '##.foo' → ''
     * - 'example.com,example.org##.foo' → 'example.com,example.org'
     * - '[$path=/foo/bar]example.com##.foo' → '[$path=/foo/bar]example.com'
     */
    static generatePattern(node: AnyCosmeticRule): string;
    /**
     * Generates the rule body from the node.
     *
     * @param node Cosmetic rule node
     * @returns Raw rule body
     * @example
     * - '##.foo' → '.foo'
     * - 'example.com,example.org##.foo' → '.foo'
     * - 'example.com#%#//scriptlet('foo')' → '//scriptlet('foo')'
     */
    static generateBody(node: AnyCosmeticRule): string;
    /**
     * Converts a cosmetic rule AST into a string.
     *
     * @param node Cosmetic rule AST
     * @returns Raw string
     */
    static generate(node: AnyCosmeticRule): string;
    /**
     * Serializes an element hiding rule body node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    private static serializeElementHidingBody;
    /**
     * Deserializes an element hiding rule body node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    private static deserializeElementHidingBody;
    /**
     * Serializes a CSS injection rule body node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    private static serializeCssInjectionBody;
    /**
     * Deserializes CSS injection rule body node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    private static deserializeCssInjectionBody;
    /**
     * Serializes a cosmetic rule node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node: AnyCosmeticRule, buffer: OutputByteBuffer): void;
    /**
     * Deserializes a cosmetic rule node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer: InputByteBuffer, node: Partial<AnyCosmeticRule>): void;
}

/**
 * `AppListParser` is responsible for parsing an app list.
 *
 * @see {@link https://adguard.app/kb/general/ad-filtering/create-own-filters/#app-modifier}
 */
declare class AppListParser extends ParserBase {
    /**
     * Parses an app list which items are separated by `|`,
     * e.g. `Example.exe|com.example.osx`.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     *
     * @returns App list AST.
     * @throws An {@link AdblockSyntaxError} if the app list is syntactically invalid.
     * @throws An {@link Error} if the options are invalid.
     */
    static parse(raw: string, options?: ParserOptions, baseOffset?: number): AppList;
}

/**
 * `DomainListParser` is responsible for parsing a domain list.
 *
 * @example
 * - If the rule is `example.com,~example.net##.ads`, the domain list is `example.com,~example.net`.
 * - If the rule is `ads.js^$script,domains=example.com|~example.org`, the domain list is `example.com|~example.org`.
 * This parser is responsible for parsing these domain lists.
 * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#elemhide_domains}
 */
declare class DomainListParser extends ParserBase {
    /**
     * Parses a domain list, eg. `example.com,example.org,~example.org`
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @param separator Separator character (default: comma)
     *
     * @returns Domain list AST.
     * @throws An {@link AdblockSyntaxError} if the domain list is syntactically invalid.
     * @throws An {@link Error} if the options are invalid.
     */
    static parse(raw: string, options?: ParserOptions, baseOffset?: number, separator?: string): DomainList;
    /**
     * Converts a domain list node to a string.
     *
     * @param node Domain list node.
     *
     * @returns Raw string.
     */
    static generate(node: DomainList): string;
    /**
     * Serializes a domain list node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node: DomainList, buffer: OutputByteBuffer): void;
    /**
     * Deserializes a modifier list node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer: InputByteBuffer, node: DomainList): void;
}

/**
 * `MethodListParser` is responsible for parsing a method list.
 *
 * @see {@link https://adguard.app/kb/general/ad-filtering/create-own-filters/#method-modifier}
 */
declare class MethodListParser extends ParserBase {
    /**
     * Parses a method list which items are separated by `|`,
     * e.g. `get|post|put`.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     *
     * @returns Method list AST.
     * @throws An {@link AdblockSyntaxError} if the method list is syntactically invalid.
     * @throws An {@link Error} if the options are invalid.
     */
    static parse(raw: string, options?: ParserOptions, baseOffset?: number): MethodList;
}

/**
 * `StealthOptionListParser` is responsible for parsing a list of stealth options.
 *
 * @see {@link https://adguard.app/kb/general/ad-filtering/create-own-filters/#stealth-modifier}
 */
declare class StealthOptionListParser extends ParserBase {
    /**
     * Parses a stealth option list which items are separated by `|`,
     * e.g. `dpi|ip`.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     *
     * @returns Stealth option list AST.
     * @throws An {@link AdblockSyntaxError} if the stealth option list is syntactically invalid.
     * @throws An {@link Error} if the options are invalid.
     */
    static parse(raw: string, options?: ParserOptions, baseOffset?: number): StealthOptionList;
}

/**
 * `FilterListParser` is responsible for parsing a whole adblock filter list (list of rules).
 * It is a wrapper around `RuleParser` which parses each line separately.
 */
declare class FilterListParser extends ParserBase {
    /**
     * Parses a whole adblock filter list (list of rules).
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns AST of the source code (list of rules)
     * @example
     * ```js
     * import { readFileSync } from 'fs';
     * import { FilterListParser } from '@adguard/agtree';
     *
     * // Read filter list content from file
     * const content = readFileSync('your-adblock-filter-list.txt', 'utf-8');
     *
     * // Parse the filter list content, then do something with the AST
     * const ast = FilterListParser.parse(content);
     * ```
     * @throws If one of the rules is syntactically invalid (if `tolerant` is `false`)
     */
    static parse(raw: string, options?: ParserOptions, baseOffset?: number): FilterList;
    /**
     * Serializes a whole adblock filter list (list of rules).
     *
     * @param ast AST to generate
     * @param preferRaw If `true`, then the parser will use `raws.text` property of each rule
     * if it is available. Default is `false`.
     * @returns Serialized filter list
     */
    static generate(ast: FilterList, preferRaw?: boolean): string;
    /**
     * Serializes a filter list node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node: FilterList, buffer: OutputByteBuffer): void;
    /**
     * Deserializes a filter list node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer: InputByteBuffer, node: Partial<FilterList>): void;
    /**
     * Helper method to jump to the children of the filter list node.
     *
     * Filter lists serialized in binary format are structured as follows:
     * - `FilterListNode` filter list node indicator (1 byte)
     * - Properties:
     *      - `Children` (1 byte) - children count, followed by children nodes
     *      - `Start` (1 byte) - start offset, if present, followed by the value
     *      - `End` (1 byte) - end offset, if present, followed by the value
     *      - `NULL` (1 byte) - closing indicator
     *
     * This method skips indicators, reads the children count and returns it.
     * This way the buffer is positioned at the beginning of the children nodes.
     *
     * @param buffer Reference to the input byte buffer.
     * @returns Number of children nodes.
     */
    static jumpToChildren(buffer: InputByteBuffer): number;
}

/**
 * `HintRuleParser` is responsible for parsing AdGuard hint rules.
 *
 * @example
 * The following hint rule
 * ```adblock
 * !+ NOT_OPTIMIZED PLATFORM(windows)
 * ```
 * contains two hints: `NOT_OPTIMIZED` and `PLATFORM`.
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#hints}
 */
declare class HintCommentRuleParser extends ParserBase {
    /**
     * Checks if the raw rule is a hint rule.
     *
     * @param raw Raw rule
     * @returns `true` if the rule is a hint rule, `false` otherwise
     */
    static isHintRule(raw: string): boolean;
    /**
     * Parses a raw rule as a hint comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Hint AST or null (if the raw rule cannot be parsed as a hint comment)
     * @throws If the input matches the HINT pattern but syntactically invalid
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#hints-1}
     */
    static parse(raw: string, options?: ParserOptions, baseOffset?: number): HintCommentRule | null;
    /**
     * Converts a hint rule node to a raw string.
     *
     * @param node Hint rule node
     * @returns Raw string
     */
    static generate(node: HintCommentRule): string;
    /**
     * Serializes a hint rule node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node: HintCommentRule, buffer: OutputByteBuffer): void;
    /**
     * Deserializes a hint rule node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer: InputByteBuffer, node: Partial<HintCommentRule>): void;
}

/**
 * `HintParser` is responsible for parsing AdGuard hints.
 *
 * @example
 * If the hint rule is
 * ```adblock
 * !+ NOT_OPTIMIZED PLATFORM(windows)
 * ```
 * then the hints are `NOT_OPTIMIZED` and `PLATFORM(windows)`, and this
 * class is responsible for parsing them. The rule itself is parsed by
 * the `HintRuleParser`, which uses this class to parse single hints.
 */
declare class HintParser extends ParserBase {
    /**
     * Parses a raw rule as a hint.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Hint rule AST or null
     * @throws If the syntax is invalid
     */
    static parse(raw: string, options?: ParserOptions, baseOffset?: number): Hint;
    /**
     * Converts a single hint AST to a string.
     *
     * @param hint Hint AST
     * @returns Hint string
     */
    static generate(hint: Hint): string;
    /**
     * Serializes a hint node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node: Hint, buffer: OutputByteBuffer): void;
    /**
     * Deserializes a hint node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer: InputByteBuffer, node: Partial<Hint>): void;
}

/**
 * `LogicalExpressionParser` is responsible for parsing logical expressions.
 *
 * @example
 * From the following rule:
 * ```adblock
 * !#if (adguard_ext_android_cb || adguard_ext_safari)
 * ```
 * this parser will parse the expression `(adguard_ext_android_cb || adguard_ext_safari)`.
 */
declare class LogicalExpressionParser extends ParserBase {
    /**
     * Split the expression into tokens.
     *
     * @param raw Source code of the expression
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Token list
     * @throws {AdblockSyntaxError} If the expression is invalid
     */
    private static tokenize;
    /**
     * Parses a logical expression.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Parsed expression
     * @throws {AdblockSyntaxError} If the expression is invalid
     */
    static parse(raw: string, options?: ParserOptions, baseOffset?: number): AnyExpressionNode;
    /**
     * Generates a string representation of the logical expression (serialization).
     *
     * @param node Expression node
     * @returns String representation of the logical expression
     */
    static generate(node: AnyExpressionNode): string;
    /**
     * Serializes a variable node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    private static serializeVariableNode;
    /**
     * Serializes a parenthesis node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    private static serializeParenthesisNode;
    /**
     * Serializes an operator node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    private static serializeOperatorNode;
    /**
     * Serializes a logical expression node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node: AnyExpressionNode, buffer: OutputByteBuffer): void;
    /**
     * Deserializes a variable node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    private static deserializeVariableNode;
    /**
     * Deserializes a parenthesis node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    private static deserializeParenthesisNode;
    /**
     * Deserializes an operator node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    private static deserializeOperatorNode;
    /**
     * Deserializes a logical expression node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer: InputByteBuffer, node: Partial<AnyExpressionNode>): void;
}

/**
 * Known metadata headers.
 */
declare const KNOWN_METADATA_HEADERS: string[];
/**
 * `MetadataParser` is responsible for parsing metadata comments.
 * Metadata comments are special comments that specify some properties of the list.
 *
 * @example
 * For example, in the case of
 * ```adblock
 * ! Title: My List
 * ```
 * the name of the header is `Title`, and the value is `My List`, which means that
 * the list title is `My List`, and it can be used in the adblocker UI.
 * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#special-comments}
 */
declare class MetadataCommentRuleParser extends ParserBase {
    /**
     * Parses a raw rule as a metadata comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Metadata comment AST or null (if the raw rule cannot be parsed as a metadata comment)
     */
    static parse(raw: string, options?: ParserOptions, baseOffset?: number): MetadataCommentRule | null;
    /**
     * Converts a metadata comment rule node to a string.
     *
     * @param node Metadata comment rule node.
     * @returns Raw string.
     */
    static generate(node: MetadataCommentRule): string;
    /**
     * Serializes a metadata comment node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node: MetadataCommentRule, buffer: OutputByteBuffer): void;
    /**
     * Deserializes a metadata comment node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer: InputByteBuffer, node: Partial<MetadataCommentRule>): void;
}

/**
 * `ModifierListParser` is responsible for parsing modifier lists. Please note that the name is not
 * uniform, "modifiers" are also known as "options".
 *
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules-modifiers}
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#non-basic-rules-modifiers}
 * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#options}
 */
declare class ModifierListParser extends ParserBase {
    /**
     * Parses the cosmetic rule modifiers, eg. `third-party,domain=example.com|~example.org`.
     *
     * _Note:_ you should remove `$` separator before passing the raw modifiers to this function,
     *  or it will be parsed in the first modifier.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Parsed modifiers interface
     */
    static parse(raw: string, options?: ParserOptions, baseOffset?: number): ModifierList;
    /**
     * Converts a modifier list AST to a string.
     *
     * @param ast Modifier list AST
     * @returns Raw string
     */
    static generate(ast: ModifierList): string;
    /**
     * Serializes a modifier list node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node: ModifierList, buffer: OutputByteBuffer): void;
    /**
     * Deserializes a modifier list node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer: InputByteBuffer, node: ModifierList): void;
}

/**
 * `ModifierParser` is responsible for parsing modifiers.
 *
 * @example
 * `match-case`, `~third-party`, `domain=example.com|~example.org`
 */
declare class ModifierParser extends ParserBase {
    /**
     * Parses a modifier.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     *
     * @returns Parsed modifier
     * @throws An error if modifier name or value is empty.
     */
    static parse(raw: string, options?: ParserOptions, baseOffset?: number): Modifier;
    /**
     * Generates a string from a modifier (serializes it).
     *
     * @param modifier Modifier to generate string from
     * @returns String representation of the modifier
     */
    static generate(modifier: Modifier): string;
    /**
     * Serializes a modifier node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node: Modifier, buffer: OutputByteBuffer): void;
    /**
     * Deserializes a modifier node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer: InputByteBuffer, node: Partial<Modifier>): void;
}

/**
 * `NetworkRuleParser` is responsible for parsing network rules.
 *
 * Please note that this will parse all syntactically correct network rules.
 * Modifier compatibility is not checked at the parser level.
 *
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules}
 * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#basic}
 */
declare class NetworkRuleParser extends ParserBase {
    /**
     * Parses a network rule (also known as basic rule).
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Network rule AST
     *
     * @throws If the rule is syntactically incorrect.
     */
    static parse(raw: string, options?: ParserOptions, baseOffset?: number): NetworkRule;
    /**
     * Finds the index of the separator character in a network rule.
     *
     * @param rule Network rule to check
     * @returns The index of the separator character, or -1 if there is no separator
     */
    private static findNetworkRuleSeparatorIndex;
    /**
     * Converts a network rule (basic rule) AST to a string.
     *
     * @param node Network rule node
     * @returns Raw string
     */
    static generate(node: NetworkRule): string;
    /**
     * Serializes a network rule node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node: NetworkRule, buffer: OutputByteBuffer): void;
    /**
     * Deserializes a modifier node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer: InputByteBuffer, node: Partial<NetworkRule>): void;
}

/**
 * @file Customized error class for not implemented features.
 */
/**
 * Customized error class for not implemented features.
 */
declare class NotImplementedError extends Error {
    /**
     * Constructs a new `NotImplementedError` instance.
     *
     * @param message Additional error message (optional)
     */
    constructor(message?: string | undefined);
}

declare class ParameterListParser extends ParserBase {
    /**
     * Parses a raw parameter list.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @param separator Separator character (default: comma)
     * @returns Parameter list AST
     */
    static parse(raw: string, options?: ParserOptions, baseOffset?: number, separator?: string): ParameterList;
    /**
     * Converts a parameter list AST to a string.
     *
     * @param params Parameter list AST
     * @param separator Separator character (default: comma)
     * @returns String representation of the parameter list
     */
    static generate(params: ParameterList, separator?: string): string;
    /**
     * Serializes a parameter list node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     * @param frequentValuesMap Optional map of frequent values.
     * @param toLower Whether to lowercase the value before the frequent value match (defaults to `false`).
     */
    static serialize(node: ParameterList, buffer: OutputByteBuffer, frequentValuesMap?: Map<string, number>, toLower?: boolean): void;
    /**
     * Deserializes a parameter list node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @param frequentValuesMap Optional map of frequent values.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer: InputByteBuffer, node: ParameterList, frequentValuesMap?: Map<number, string>): void;
}

/**
 * `HostRuleParser` is responsible for parsing hosts-like rules.
 *
 * HostRule is a structure for simple host-level rules (i.e. /etc/hosts syntax).
 * It also supports "just domain" syntax. In this case, the IP will be set to 0.0.0.0.
 *
 * Rules syntax looks like this:
 * ```text
 * IP_address canonical_hostname [aliases...]
 * ```
 *
 * @example
 * `192.168.1.13 bar.mydomain.org bar` -- ipv4
 * `ff02::1 ip6-allnodes` -- ipv6
 * `::1 localhost ip6-localhost ip6-loopback` -- ipv6 aliases
 * `example.org` -- "just domain" syntax
 * @see {@link http://man7.org/linux/man-pages/man5/hosts.5.html}
 */
declare class HostRuleParser extends ParserBase {
    static readonly NULL_IP = "0.0.0.0";
    static readonly COMMENT_MARKER = "#";
    /**
     * Parses an etc/hosts-like rule.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Host rule node.
     *
     * @throws If the input contains invalid data.
     */
    static parse(raw: string, options?: ParserOptions, baseOffset?: number): HostRule;
    /**
     * Converts a host rule node to a raw string.
     *
     * @param node Host rule node.
     * @returns Raw string.
     */
    static generate(node: HostRule): string;
    /**
     * Serializes a hostname list node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    private static serializeHostnameList;
    /**
     * Deserializes a hostname list node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    private static deserializeHostnameList;
    /**
     * Serializes a host rule node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node: HostRule, buffer: OutputByteBuffer): void;
    /**
     * Deserializes a modifier node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer: InputByteBuffer, node: Partial<HostRule>): void;
}

/**
 * `PreProcessorParser` is responsible for parsing preprocessor rules.
 * Pre-processor comments are special comments that are used to control the behavior of the filter list processor.
 * Please note that this parser only handles general syntax for now, and does not validate the parameters at
 * the parsing stage.
 *
 * @example
 * If your rule is
 * ```adblock
 * !#if (adguard)
 * ```
 * then the directive's name is `if` and its value is `(adguard)`, but the parameter list
 * is not parsed / validated further.
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#pre-processor-directives}
 * @see {@link https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#pre-parsing-directives}
 */
declare class PreProcessorCommentRuleParser extends ParserBase {
    /**
     * Determines whether the rule is a pre-processor rule.
     *
     * @param raw Raw rule
     * @returns `true` if the rule is a pre-processor rule, `false` otherwise
     */
    static isPreProcessorRule(raw: string): boolean;
    /**
     * Parses a raw rule as a pre-processor comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns
     * Pre-processor comment AST or null (if the raw rule cannot be parsed as a pre-processor comment)
     */
    static parse(raw: string, options?: ParserOptions, baseOffset?: number): PreProcessorCommentRule | null;
    /**
     * Converts a pre-processor comment node to a string.
     *
     * @param node Pre-processor comment node
     * @returns Raw string
     */
    static generate(node: PreProcessorCommentRule): string;
    /**
     * Serializes a pre-processor comment node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node: PreProcessorCommentRule, buffer: OutputByteBuffer): void;
    /**
     * Deserializes a pre-processor comment node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer: InputByteBuffer, node: Partial<PreProcessorCommentRule>): void;
}

/**
 * @file Customized error class for conversion errors.
 */
/**
 * Customized error class for conversion errors.
 */
declare class RuleConversionError extends Error {
    /**
     * Constructs a new `RuleConversionError` instance.
     *
     * @param message Error message
     */
    constructor(message: string);
}

/**
 * @file Customized error for binary schema mismatch.
 */
/**
 * Customized error for binary schema mismatch.
 */
declare class BinarySchemaMismatchError extends Error {
    /**
     * Expected schema version.
     */
    expectedVersion: number;
    /**
     * Actual schema version.
     */
    actualVersion: number;
    /**
     * Constructs a new `BinarySchemaMismatchError` instance.
     *
     * @param expectedVersion Expected schema version.
     * @param actualVersion Actual schema version.
     */
    constructor(expectedVersion: number, actualVersion: number);
}

/**
 * Result of modifier validation:
 * - `{ valid: true }` for valid and _fully supported_ modifier;
 * - `{ valid: true, warn: <deprecation notice> }` for valid
 *   and _still supported but deprecated_ modifier;
 * - otherwise `{ valid: true, error: <invalidity reason> }`
 */
type ValidationResult = {
    valid: boolean;
    error?: string;
    warn?: string;
};

/**
 * @file Validator for modifiers.
 */

/**
 * Modifier validator class.
 */
declare class ModifierValidator {
    /**
     * Simply checks whether the modifier exists in any adblocker.
     *
     * **Deprecated** and **removed** modifiers are considered as **existent**.
     *
     * @param modifier Already parsed modifier AST node.
     *
     * @returns True if modifier exists, false otherwise.
     */
    exists: (modifier: Modifier) => boolean;
    /**
     * Checks whether the given `modifier` is valid for specified `syntax`.
     *
     * For `Common` syntax it simply checks whether the modifier exists.
     * For specific syntax the validation is more complex —
     * deprecated, assignable, negatable and other requirements are checked.
     *
     * @param syntax Adblock syntax to check the modifier for.
     * @param rawModifier Modifier AST node.
     * @param isException Whether the modifier is used in exception rule, default to false.
     * Needed to check whether the modifier is allowed only in blocking or exception rules.
     *
     * @returns Result of modifier validation.
     */
    validate: (syntax: AdblockSyntax, rawModifier: Modifier, isException?: boolean) => ValidationResult;
}
declare const modifierValidator: ModifierValidator;

/**
 * @file Conversion result interface and helper functions
 */

/**
 * Common conversion result interface
 *
 * @template T Type of the item to convert
 * @template U Type of the conversion result (defaults to `T`, but can be `T[]` as well)
 */
interface ConversionResult<T, U extends T | T[] = T> {
    /**
     * Conversion result
     */
    result: U;
    /**
     * Indicates whether the input item was converted
     */
    isConverted: boolean;
}
/**
 * Adblock rule node conversion result interface, where the conversion result is an array of rules
 */
type NodeConversionResult<T extends Node> = ConversionResult<T, T[]>;

/**
 * @file Base class for converters
 *
 * TS doesn't support abstract static methods, so we should use
 * a workaround and extend this class instead of implementing it
 */

/**
 * Basic class for rule converters
 */
declare class ConverterBase {
    /**
     * Converts some data to AdGuard format
     *
     * @param data Data to convert
     * @returns An object which follows the {@link ConversionResult} interface. Its `result` property contains
     * the converted node, and its `isConverted` flag indicates whether the original node was converted.
     * If the node was not converted, the result will contain the original node with the same object reference
     * @throws If the data is invalid or incompatible
     */
    static convertToAdg(data: unknown): ConversionResult<unknown>;
    /**
     * Converts some data to Adblock Plus format
     *
     * @param data Data to convert
     * @returns An object which follows the {@link ConversionResult} interface. Its `result` property contains
     * the converted node, and its `isConverted` flag indicates whether the original node was converted.
     * If the node was not converted, the result will contain the original node with the same object reference
     * @throws If the data is invalid or incompatible
     */
    static convertToAbp(data: unknown): ConversionResult<unknown>;
    /**
     * Converts some data to uBlock Origin format
     *
     * @param data Data to convert
     * @returns An object which follows the {@link ConversionResult} interface. Its `result` property contains
     * the converted node, and its `isConverted` flag indicates whether the original node was converted.
     * If the node was not converted, the result will contain the original node with the same object reference
     * @throws If the data is invalid or incompatible
     */
    static convertToUbo(data: unknown): ConversionResult<unknown>;
}

/**
 * @file Adblock filter list converter
 */

/**
 * Adblock filter list converter class
 *
 * This class just provides an extra layer on top of the {@link RuleConverter}
 * and can be used to convert entire filter lists.
 *
 * @todo Implement `convertToUbo` and `convertToAbp`
 * @todo Implement tolerant mode, which will allow to convert a filter list
 * even if some of its rules are invalid
 */
declare class FilterListConverter extends ConverterBase {
    /**
     * Converts an adblock filter list to AdGuard format, if possible.
     *
     * @param filterListNode Filter list node to convert
     * @param tolerant Indicates whether the converter should be tolerant to invalid rules. If enabled and a rule is
     * invalid, it will be left as is. If disabled and a rule is invalid, the whole filter list will be failed.
     * Defaults to `true`.
     * @returns An object which follows the {@link ConversionResult} interface. Its `result` property contains
     * the converted node, and its `isConverted` flag indicates whether the original node was converted.
     * If the node was not converted, the result will contain the original node with the same object reference
     * @throws If the filter list is invalid or cannot be converted (if the tolerant mode is disabled)
     */
    static convertToAdg(filterListNode: FilterList, tolerant?: boolean): ConversionResult<FilterList>;
}

/**
 * @file Filter list converter for raw filter lists
 *
 * Technically, this is a wrapper around `FilterListConverter` that works with nodes instead of strings.
 */

/**
 * Adblock filter list converter class.
 *
 * You can use this class to convert string-based filter lists, since most of the converters work with nodes.
 * This class just provides an extra layer on top of the {@link FilterListConverter} and calls the parser/serializer
 * before/after the conversion internally.
 *
 * @todo Implement `convertToUbo` and `convertToAbp`
 */
declare class RawFilterListConverter extends ConverterBase {
    /**
     * Converts an adblock filter list text to AdGuard format, if possible.
     *
     * @param rawFilterList Raw filter list text to convert
     * @param tolerant Indicates whether the converter should be tolerant to invalid rules. If enabled and a rule is
     * invalid, it will be left as is. If disabled and a rule is invalid, the whole filter list will be failed.
     * Defaults to `true`.
     * @returns An object which follows the {@link ConversionResult} interface. Its `result` property contains
     * the array of converted filter list text, and its `isConverted` flag indicates whether the original rule was
     * converted. If the rule was not converted, the original filter list text will be returned
     * @throws If the filter list is invalid or cannot be converted (if the tolerant mode is disabled)
     */
    static convertToAdg(rawFilterList: string, tolerant?: boolean): ConversionResult<string>;
}

/**
 * @file Rule converter for raw rules
 *
 * Technically, this is a wrapper around `RuleConverter` that works with nodes instead of strings.
 */

/**
 * Adblock filtering rule converter class.
 *
 * You can use this class to convert string-based adblock rules, since most of the converters work with nodes.
 * This class just provides an extra layer on top of the {@link RuleConverter} and calls the parser/serializer
 * before/after the conversion internally.
 *
 * @todo Implement `convertToUbo` and `convertToAbp`
 */
declare class RawRuleConverter extends ConverterBase {
    /**
     * Converts an adblock filtering rule to AdGuard format, if possible.
     *
     * @param rawRule Raw rule text to convert
     * @returns An object which follows the {@link ConversionResult} interface. Its `result` property contains
     * the array of converted rule texts, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the original rule text will be returned
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToAdg(rawRule: string): ConversionResult<string, string[]>;
}

/**
 * @file Base class for rule converters
 *
 * TS doesn't support abstract static methods, so we should use
 * a workaround and extend this class instead of implementing it
 */

/**
 * Basic class for rule converters
 */
declare class RuleConverterBase extends ConverterBase {
    /**
     * Converts an adblock filtering rule to AdGuard format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToAdg(rule: Node): NodeConversionResult<Node>;
    /**
     * Converts an adblock filtering rule to Adblock Plus format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToAbp(rule: Node): NodeConversionResult<Node>;
    /**
     * Converts an adblock filtering rule to uBlock Origin format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToUbo(rule: Node): NodeConversionResult<Node>;
}

/**
 * @file Adblock rule converter
 *
 * This file is the entry point for all rule converters
 * which automatically detects the rule type and calls
 * the corresponding "sub-converter".
 */

/**
 * Adblock filtering rule converter class
 *
 * @todo Implement `convertToUbo` and `convertToAbp`
 */
declare class RuleConverter extends RuleConverterBase {
    /**
     * Converts an adblock filtering rule to AdGuard format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToAdg(rule: AnyRule): NodeConversionResult<AnyRule>;
    /**
     * Converts an adblock filtering rule to uBlock Origin format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToUbo(rule: AnyRule): NodeConversionResult<AnyRule>;
}

/**
 * @file Binary schema version.
 */
/**
 * Binary schema version.
 * This version number is used to ensure that the binary format is compatible with the current library version.
 * We increment this number if the serialized format changes in a way that is not backwards-compatible.
 */
declare const BINARY_SCHEMA_VERSION = 1;

/**
 * @file Cosmetic rule separator finder and categorizer
 */

interface CosmeticRuleSeparatorFinderResult {
    /**
     * Separator type
     */
    separator: CosmeticRuleSeparator;
    /**
     * Separator start position
     */
    start: number;
    /**
     * Separator end position
     */
    end: number;
}
/**
 * Utility class for cosmetic rule separators.
 */
declare class CosmeticRuleSeparatorUtils {
    /**
     * Checks whether the specified separator is an exception.
     *
     * @param separator Separator to check
     * @returns `true` if the separator is an exception, `false` otherwise
     */
    static isException(separator: CosmeticRuleSeparator): boolean;
    /**
     * Checks whether the specified separator is marks an Extended CSS cosmetic rule.
     *
     * @param separator Separator to check
     * @returns `true` if the separator is marks an Extended CSS cosmetic rule, `false` otherwise
     */
    static isExtendedCssMarker(separator: CosmeticRuleSeparator): boolean;
    /**
     * Looks for the cosmetic rule separator in the rule. This is a simplified version that
     * masks the recursive function.
     *
     * @param rule Raw rule
     * @returns Separator result or null if no separator was found
     */
    static find(rule: string): CosmeticRuleSeparatorFinderResult | null;
}

declare class DomainUtils {
    /**
     * Check if the input is a valid domain or hostname.
     *
     * @param domain Domain to check
     * @returns `true` if the domain is valid, `false` otherwise
     */
    static isValidDomainOrHostname(domain: string): boolean;
}

/**
 * @file Utility functions for logical expression node.
 */

/**
 * Variable table. Key is variable name, value is boolean.
 */
type VariableTable = {
    [key: string]: boolean;
};
/**
 * Utility functions for logical expression node.
 */
declare class LogicalExpressionUtils {
    /**
     * Get all variables in the expression.
     *
     * @param node Logical expression node
     * @returns List of variables in the expression (nodes)
     * @example
     * If the expression is `a && b || c`, the returned list will be
     * nodes for `a`, `b`, and `c`.
     */
    static getVariables(node: AnyExpressionNode): ExpressionVariableNode[];
    /**
     * Evaluate the parsed logical expression. You'll need to provide a
     * variable table.
     *
     * @param node Logical expression node
     * @param table Variable table (key: variable name, value: boolean)
     * @returns Evaluation result
     * @example
     * If the expression is `a && b`, and the variable table is
     * `{ a: true, b: false }`, the result will be `false`.
     *
     * Example code:
     * ```js
     * LogicalExpressionUtils.evaluate(
     *     LogicalExpressionParser.parse('a && b'),
     *     { a: true, b: false }
     * );
     * ```
     */
    static evaluate(node: AnyExpressionNode, table: VariableTable): boolean;
}

declare const ADBLOCK_URL_START: string;
declare const ADBLOCK_URL_START_REGEX = "^(http|https|ws|wss)://([a-z0-9-_.]+\\.)?";
declare const ADBLOCK_URL_SEPARATOR = "^";
declare const ADBLOCK_URL_SEPARATOR_REGEX = "([^ a-zA-Z0-9.%_-]|$)";
declare const ADBLOCK_WILDCARD = "*";
declare const ADBLOCK_WILDCARD_REGEX: string;
/**
 * Special RegExp symbols
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#special-escape
 */
declare const SPECIAL_REGEX_SYMBOLS: Set<string>;
/**
 * Utility functions for working with RegExp patterns
 */
declare class RegExpUtils {
    /**
     * Checks whether a string possibly is a RegExp pattern.
     * Flags are not supported.
     *
     * Note: it does not perform a full validation of the pattern,
     * it just checks if the string starts and ends with a slash.
     *
     * @param pattern - Pattern to check
     * @returns `true` if the string is a RegExp pattern, `false` otherwise
     */
    static isRegexPattern(pattern: string): boolean;
    /**
     * Negates a RegExp pattern. Technically, this method wraps the pattern in `^((?!` and `).)*$`.
     *
     * RegExp modifiers are not supported.
     *
     * @param pattern Pattern to negate (can be wrapped in slashes or not)
     * @returns Negated RegExp pattern
     */
    static negateRegexPattern(pattern: string): string;
    /**
     * Converts a basic adblock rule pattern to a RegExp pattern. Based on
     * https://github.com/AdguardTeam/tsurlfilter/blob/9b26e0b4a0e30b87690bc60f7cf377d112c3085c/packages/tsurlfilter/src/rules/simple-regex.ts#L219
     *
     * @param pattern Pattern to convert
     * @returns RegExp equivalent of the pattern
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules}
     */
    static patternToRegexp(pattern: string): string;
}

/**
 * Possible quote types for scriptlet parameters
 */
declare enum QuoteType {
    /**
     * No quotes at all
     */
    None = "none",
    /**
     * Single quotes (`'`)
     */
    Single = "single",
    /**
     * Double quotes (`"`)
     */
    Double = "double",
    /**
     * Backtick quotes (`` ` ``)
     */
    Backtick = "backtick"
}
/**
 * Utility functions for working with quotes
 */
declare class QuoteUtils {
    /**
     * Escape all unescaped occurrences of the character
     *
     * @param string String to escape
     * @param char Character to escape
     * @returns Escaped string
     */
    static escapeUnescapedOccurrences(string: string, char: string): string;
    /**
     * Unescape all single escaped occurrences of the character
     *
     * @param string String to unescape
     * @param char Character to unescape
     * @returns Unescaped string
     */
    static unescapeSingleEscapedOccurrences(string: string, char: string): string;
    /**
     * Get quote type of the string
     *
     * @param string String to check
     * @returns Quote type of the string
     */
    static getStringQuoteType(string: string): QuoteType;
    /**
     * Set quote type of the string
     *
     * @param string String to set quote type of
     * @param quoteType Quote type to set
     * @returns String with the specified quote type
     */
    static setStringQuoteType(string: string, quoteType: QuoteType): string;
    /**
     * Removes bounding quotes from a string, if any
     *
     * @param string Input string
     * @returns String without quotes
     */
    static removeQuotes(string: string): string;
    /**
     * Removes bounding quotes from a string, if any, and unescapes the escaped quotes,
     * like transforming `'abc\'def'` to `abc'def`.
     *
     * @param string Input string
     * @returns String without quotes
     */
    static removeQuotesAndUnescape(string: string): string;
    /**
     * Wraps given `strings` with `quote` (defaults to single quote `'`)
     * and joins them with `separator` (defaults to comma+space `, `).
     *
     * @param strings Strings to quote and join.
     * @param quoteType Quote to use.
     * @param separator Separator to use.
     *
     * @returns String with joined items.
     *
     * @example
     * ['abc', 'def']: strings[]  ->  "'abc', 'def'": string
     */
    static quoteAndJoinStrings(strings: string[], quoteType?: QuoteType, separator?: string): string;
}

/**
 * @file Position provider class.
 */
/**
 * Represents a position in the source code.
 */
interface Position {
    /**
     * 1-based line number
     */
    line: number;
    /**
     * 1-based column number
     */
    column: number;
}
/**
 * Class responsible for converting a character offset in source code into a line and column position.
 * This conversion is particularly needed in linters and VSCode extensions,
 * where line and column numbers are more human-friendly and intuitive than character offsets.
 * Moreover, the VSCode diagnostics API does not directly support character offsets,
 * it also requires line and column numbers.
 */
declare class PositionProvider {
    /**
     * Maps a character offset to a line number.
     */
    private offsetToLine;
    /**
     * Maps a line number to the starting character offset of that line.
     */
    private lineStartOffsets;
    /**
     * Constructs a new PositionProvider instance.
     *
     * @param sourceCode The source code as a string.
     */
    constructor(sourceCode: string);
    /**
     * Converts a character offset to a line and column position.
     *
     * @param offset The zero-based character offset in the source code.
     * @returns A Position object containing the 1-based line and column number, or null if the offset is out of range.
     */
    convertOffsetToPosition(offset: number): Position | null;
}

/**
 * @file Utility for encoding strings to byte sequences.
 */
interface TextEncoderPolyfillResult {
    readonly written: number;
    readonly read: number;
}
/**
 * Encodes an UTF-8 string into a byte sequence according to the WHATWG spec.
 *
 * @param str String to encode.
 * @param buffer Buffer to write the encoded bytes to.
 * @returns Number of bytes written to the buffer.
 * @see {@link https://encoding.spec.whatwg.org/#utf-8-encoder}
 * @note Bytes written maybe larger than the string length, but never smaller.
 * For example, the string '你好' has a length of 2, but its byte representation has a length of 6.
 */
declare const encodeIntoPolyfill: (str: string, buffer: Uint8Array) => TextEncoderPolyfillResult;

/**
 * @file Optimized utility for decoding strings from byte sequences.
 */
/**
 * Decodes a byte sequence into an UTF-8 string according to the WHATWG spec.
 * Optimized for performance.
 *
 * @param buffer Buffer to read the bytes from.
 * @param start Start offset in the buffer.
 * @param end End offset in the buffer.
 * @returns Decoded string.
 * @see {@link https://encoding.spec.whatwg.org/#utf-8-decoder}
 */
declare const decodeTextPolyfill: (buffer: Uint8Array, start?: number, end?: number) => string;

/**
 * Utility functions for categorizing rules.
 */
declare class RuleCategorizer {
    /**
     * Determines the type of a given raw cosmetic rule.
     *
     * @param rawRule Raw rule to check.
     *
     * @returns Type of the cosmetic rule or `null` if the rule is cannot be parsed as a cosmetic rule.
     */
    static getCosmeticRuleType(rawRule: string): CosmeticRuleType | null;
}

/**
 * _ALL_ known Extended CSS pseudo-classes. Please, keep this list sorted.
 * It includes strict pseudo-classes and additional pseudo-classes that may be
 * supported by some browsers natively.
 */
declare const EXT_CSS_PSEUDO_CLASSES: Set<string>;
/**
 * Known legacy Extended CSS attributes. These attributes are deprecated and
 * should be replaced with the corresponding pseudo-classes. In a long term,
 * these attributes will be COMPLETELY removed from the Extended CSS syntax.
 *
 * Please, keep this list sorted.
 */
declare const EXT_CSS_LEGACY_ATTRIBUTES: Set<string>;
/**
 * Known CSS functions that aren't allowed in CSS injection rules, because they
 * able to load external resources. Please, keep this list sorted.
 */
declare const FORBIDDEN_CSS_FUNCTIONS: Set<string>;

/**
 * @file Base compatibility data schema, which is commonly used in compatibility tables.
 */

/**
 * Zod schema for base compatibility data with camelCase properties.
 */
declare const baseCompatibilityDataSchemaCamelCase: zod.ZodEffects<zod.ZodTypeAny, {
    name: string;
    description: string | null;
    aliases: string[] | null;
    docs: string | null;
    versionAdded: string | null;
    versionRemoved: string | null;
    deprecated: boolean;
    deprecationMessage: string | null;
    removed: boolean;
    removalMessage: string | null;
}, any>;
/**
 * Type of the base compatibility data schema.
 */
type BaseCompatibilityDataSchema = zod.infer<typeof baseCompatibilityDataSchemaCamelCase>;

/**
 * @file Schema for modifier data.
 */

/**
 * Zod schema for modifier data.
 */
declare const modifierDataSchema: zod.ZodEffects<zod.ZodTypeAny, {
    name: string;
    description: string | null;
    aliases: string[] | null;
    docs: string | null;
    versionAdded: string | null;
    versionRemoved: string | null;
    deprecated: boolean;
    deprecationMessage: string | null;
    removed: boolean;
    removalMessage: string | null;
    conflicts: string[] | null;
    inverseConflicts: boolean;
    assignable: boolean;
    negatable: boolean;
    blockOnly: boolean;
    exceptionOnly: boolean;
    valueOptional: boolean;
    valueFormat: string | null;
}, any>;
/**
 * Type of the modifier data schema.
 */
type ModifierDataSchema = zod.infer<typeof modifierDataSchema>;

/**
 * @file Resource type schema.
 */

/**
 * Resource type.
 *
 * @see {@link https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-ResourceType}
 */
declare enum ResourceType {
    MainFrame = "main_frame",
    SubFrame = "sub_frame",
    Stylesheet = "stylesheet",
    Script = "script",
    Image = "image",
    Font = "font",
    Object = "object",
    XmlHttpRequest = "xmlhttprequest",
    Ping = "ping",
    Media = "media",
    WebSocket = "websocket",
    Other = "other"
}

/**
 * Zod schema for redirect data.
 */
declare const redirectDataSchema: zod.ZodEffects<zod.ZodTypeAny, {
    name: string;
    description: string | null;
    aliases: string[] | null;
    docs: string | null;
    versionAdded: string | null;
    versionRemoved: string | null;
    deprecated: boolean;
    deprecationMessage: string | null;
    removed: boolean;
    removalMessage: string | null;
    isBlocking: boolean;
    resourceTypes: ResourceType[];
}, any>;
/**
 * Type of the redirect data schema.
 */
type RedirectDataSchema = zod.infer<typeof redirectDataSchema>;

/**
 * @file Schema for scriptlet data.
 */

/**
 * Zod schema for scriptlet data.
 */
declare const scriptletDataSchema: zod.ZodEffects<zod.ZodTypeAny, {
    name: string;
    description: string | null;
    aliases: string[] | null;
    docs: string | null;
    versionAdded: string | null;
    versionRemoved: string | null;
    deprecated: boolean;
    deprecationMessage: string | null;
    removed: boolean;
    removalMessage: string | null;
    parameters?: {
        name: string;
        debug: boolean;
        pattern: string | null;
        description: string | null;
        default: string | null;
        required: boolean;
    }[] | undefined;
}, any>;
/**
 * Type of the scriptlet data schema.
 */
type ScriptletDataSchema = zod.infer<typeof scriptletDataSchema>;

/**
 * @file Platform schema.
 */

/**
 * Parses a raw platform string into a platform bitmask.
 *
 * @param rawPlatforms Raw platform string, e.g. 'adg_safari_any|adg_os_any'.
 *
 * @returns Platform bitmask.
 */
declare const parseRawPlatforms: (rawPlatforms: string) => number;

/**
 * @file Provides platform enums.
 * The difference between specific and generic platforms is that specific platforms are individual platforms
 * (e.g. AdGuard for Windows, AdGuard for Android, etc.),
 * while generic platforms are groups of specific platforms
 * (e.g. AdGuard for any OS, AdGuard for any Chromium-based extension, etc.).
 */
/**
 * List of specific platforms.
 */
declare enum SpecificPlatform {
    AdgOsWindows = 1,
    AdgOsMac = 2,
    AdgOsAndroid = 4,
    AdgExtChrome = 8,
    AdgExtOpera = 16,
    AdgExtEdge = 32,
    AdgExtFirefox = 64,
    AdgCbAndroid = 128,
    AdgCbIos = 256,
    AdgCbSafari = 512,
    UboExtChrome = 1024,
    UboExtOpera = 2048,
    UboExtEdge = 4096,
    UboExtFirefox = 8192,
    AbpExtChrome = 16384,
    AbpExtOpera = 32768,
    AbpExtEdge = 65536,
    AbpExtFirefox = 131072
}
/**
 * List of generic platforms (combinations of specific platforms).
 */
declare enum GenericPlatform {
    AdgOsAny = 7,
    AdgSafariAny = 768,
    AdgExtChromium = 56,
    AdgExtAny = 120,
    AdgAny = 1023,
    UboExtChromium = 7168,
    UboExtAny = 15360,
    UboAny = 15360,
    AbpExtChromium = 114688,
    AbpExtAny = 245760,
    AbpAny = 245760,
    Any = 262143
}

/**
 * @file Compatibility tables types.
 */
/**
 * Map with shared storage.
 * The idea is to avoid storing the same value multiple times in the map,
 * so the value is stored in the `shared` array and the map refers to the index in the `shared` array.
 *
 * @template K Type of the map keys.
 * @template V Type of the map values.
 */
interface MapWithSharedStorage<K extends string | number | symbol, V> {
    /**
     * Shared storage.
     */
    shared: V[];
    /**
     * Map of the values where the value is a pointer to the shared storage (refers to the index in the `shared` array).
     */
    map: Record<K, number>;
}
/**
 * Compatibility table row.
 *
 * @template T Type of the compatibility data.
 */
type CompatibilityTableRow<T> = MapWithSharedStorage<number, T>;
/**
 * Compatibility table.
 *
 * @template T Type of the compatibility data.
 */
type CompatibilityTable<T> = MapWithSharedStorage<string, CompatibilityTableRow<T>>;

/**
 * @file Provides common compatibility table methods.
 */

/**
 * Lists all supported entity records by a product.
 *
 * Keys are compatibility flags, values are compatibility data records.
 *
 * @template T Compatibility data schema.
 */
type ProductRecords<T> = {
    [key: string]: T;
};
/**
 * Defines a compatibility table row by product.
 *
 * Keys are Adblock syntaxes, values are product records.
 *
 * @template T Compatibility data schema.
 */
type RowByProduct<T> = {
    [AdblockSyntax.Adg]: ProductRecords<T>;
    [AdblockSyntax.Ubo]: ProductRecords<T>;
    [AdblockSyntax.Abp]: ProductRecords<T>;
};
/**
 * Defines multiple compatibility table rows by product.
 *
 * @template T Compatibility data schema.
 */
type RowsByProduct<T> = RowByProduct<T>[];
/**
 * Single platform records type.
 *
 * Keys are platform enums values, values are compatibility data records.
 *
 * @template T Compatibility data schema.
 */
type SinglePlatformRecords<T> = {
    [key: string]: T;
};
/**
 * Name transformer function type. This function is used to normalize compatibility data names before processing them,
 * e.g. converting to lowercase, remove unnecessary prefixes, etc.
 *
 * @param name Compatibility data name.
 *
 * @returns Normalized name.
 */
type NameTransformer = (name: string) => string;
/**
 * Base compatibility table class which provides common methods to work with compatibility data.
 *
 * @template T Compatibility data schema.
 */
declare abstract class CompatibilityTableBase<T extends BaseCompatibilityDataSchema> {
    /**
     * Compatibility table data.
     */
    private data;
    /**
     * Optional name transformer function. If provided,
     * it will be called in all methods before processing compatibility data names.
     */
    private readonly nameTransformer;
    /**
     * Creates a new instance of the common compatibility table.
     *
     * @param data Compatibility table data.
     * @param nameTransformer Optional name transformer function.
     */
    constructor(data: CompatibilityTable<T>, nameTransformer?: NameTransformer | null);
    /**
     * Helper method to get a 'row' from the compatibility table data by name.
     *
     * @param name Compatibility data name.
     * @returns Compatibility table row storage or `null` if not found.
     */
    private getRowStorage;
    /**
     * Checks whether a compatibility data `name` exists for any platform.
     *
     * @note Technically, do the same as `exists()` method with generic platform _any_
     * but it is faster because it does not apply complex logic.
     *
     * @param name Compatibility data name.
     *
     * @returns True if the compatibility data exists, false otherwise.
     */
    existsAny(name: string): boolean;
    /**
     * Checks whether a compatibility data `name` exists for a specified platform.
     *
     * @param name Compatibility data name.
     * @param platform Specific or generic platform.
     *
     * @returns True if the compatibility data exists, false otherwise.
     */
    exists(name: string, platform: SpecificPlatform | GenericPlatform): boolean;
    /**
     * Returns a compatibility data by name and specific platform.
     *
     * @param name The name of the compatibility data.
     * @param platform The specific platform.
     *
     * @returns A single compatibility data or `null` if not found.
     */
    getSingle(name: string, platform: SpecificPlatform): T | null;
    /**
     * Returns all compatibility data records for name and specified platform.
     *
     * @param name Compatibility data name.
     * @param platform Specific or generic platform.
     *
     * @returns Multiple records grouped by platforms.
     * Technically, it is an object where keys are platform enums values and values are compatibility data records.
     *
     * @note Platform enum values can be converted to string names using {@link getSpecificPlatformName} on demand.
     */
    getMultiple(name: string, platform: SpecificPlatform | GenericPlatform): SinglePlatformRecords<T> | null;
    /**
     * Returns all compatibility data records for the specified platform.
     *
     * @param platform Specific or generic platform.
     *
     * @returns Array of multiple records grouped by platforms.
     */
    getAllMultiple(platform: SpecificPlatform | GenericPlatform): SinglePlatformRecords<T>[];
    /**
     * Returns the first compatibility data record for name and specified platform.
     *
     * @param name Compatibility data name.
     * @param platform Specific or generic platform.
     *
     * @returns First found compatibility data record or `null` if not found.
     */
    getFirst(name: string, platform: SpecificPlatform | GenericPlatform): T | null;
    /**
     * Returns all compatibility data records for the specified name.
     *
     * @param name Compatibility data name.
     *
     * @returns Array of multiple records grouped by platforms.
     */
    getRow(name: string): T[];
    /**
     * Returns all compatibility data grouped by products.
     *
     * @returns Array of multiple records grouped by products.
     */
    getRowsByProduct(): RowsByProduct<T>;
}

/**
 * @file Compatibility tables for modifiers.
 */

/**
 * Compatibility table for modifiers.
 */
declare class ModifiersCompatibilityTable extends CompatibilityTableBase<ModifierDataSchema> {
    /**
     * Creates a new instance of the compatibility table for modifiers.
     *
     * @param data Compatibility table data.
     */
    constructor(data: CompatibilityTable<ModifierDataSchema>);
}
/**
 * Compatibility table instance for modifiers.
 */
declare const modifiersCompatibilityTable: ModifiersCompatibilityTable;

/**
 * @file Compatibility tables for redirects.
 */

/**
 * Compatibility table for redirects.
 */
declare class RedirectsCompatibilityTable extends CompatibilityTableBase<RedirectDataSchema> {
    /**
     * Creates a new instance of the compatibility table for redirects.
     *
     * @param data Compatibility table data.
     */
    constructor(data: CompatibilityTable<RedirectDataSchema>);
    /**
     * Gets the resource type adblock modifiers for the redirect for the given platform
     * based on the `resourceTypes` field.
     *
     * @param redirect Redirect name or redirect data.
     * @param platform Platform to get the modifiers for.
     *
     * @returns Set of resource type modifiers or an empty set if the redirect is not found or has no resource types.
     */
    getResourceTypeModifiers(redirect: string | RedirectDataSchema, platform: SpecificPlatform | GenericPlatform): Set<string>;
}
/**
 * Compatibility table instance for redirects.
 */
declare const redirectsCompatibilityTable: RedirectsCompatibilityTable;

/**
 * @file Compatibility tables for scriptlets.
 */

/**
 * Compatibility table for scriptlets.
 */
declare class ScriptletsCompatibilityTable extends CompatibilityTableBase<ScriptletDataSchema> {
}
/**
 * Compatibility table instance for scriptlets.
 */
declare const scriptletsCompatibilityTable: ScriptletsCompatibilityTable;

/**
 * @file Provides platform mapping and helper functions.
 */

/**
 * Check if the platform is a generic platform.
 *
 * @param platform Platform to check.
 *
 * @returns True if the platform is a generic platform, false otherwise.
 */
declare const isGenericPlatform: (platform: number) => boolean;
/**
 * Returns the platform enum value for the given platform string name.
 *
 * @param platform Platform string name, e.g., 'adg_os_windows'.
 *
 * @returns Specific or generic platform enum value.
 * @throws Error if the platform is unknown.
 */
declare const getPlatformId: (platform: string) => SpecificPlatform | GenericPlatform;
/**
 * Returns the specific platform string name for the given platform enum value.
 *
 * @param platform Specific platform enum value.
 *
 * @returns Specific platform string name, e.g., 'adg_os_windows'.
 * @throws Error if the platform is unknown.
 */
declare const getSpecificPlatformName: (platform: SpecificPlatform) => string;

/**
 * Gets the adblock modifier name for the given resource type.
 *
 * @param resourceType Resource type to get the modifier name for.
 * @param platform Platform to get the modifier for.
 *
 * @returns A string containing the adblock modifier name for the given resource type
 * or `null` if the modifier could not be found.
 */
declare const getResourceTypeModifier: (resourceType: ResourceType, platform: SpecificPlatform | GenericPlatform) => string | null;
/**
 * Checks if the given resource type is valid.
 *
 * @param resourceType Resource type to check.
 *
 * @returns `true` if the resource type is valid, `false` otherwise.
 */
declare const isValidResourceType: (resourceType: string) => boolean;

/**
 * @file AGTree version
 */
declare const AGTREE_VERSION: string;

export { ADBLOCK_URL_SEPARATOR, ADBLOCK_URL_SEPARATOR_REGEX, ADBLOCK_URL_START, ADBLOCK_URL_START_REGEX, ADBLOCK_WILDCARD, ADBLOCK_WILDCARD_REGEX, ADG_SCRIPTLET_MASK, AGLINT_COMMAND_PREFIX, AGTREE_VERSION, AdblockSyntax, AdblockSyntaxError, Agent, AgentCommentRule, AgentCommentRuleParser, AgentParser, AnyCommentRule, AnyCosmeticRule, AnyExpressionNode, AnyNetworkRule, AnyRule, AppListParser, BINARY_SCHEMA_VERSION, BinarySchemaMismatchError, ByteBuffer, COMMA_DOMAIN_LIST_SEPARATOR, CommentBase, CommentMarker, CommentRule, CommentRuleParser, CommentRuleType, CompatibilityTable, CompatibilityTableRow, ConfigCommentRule, ConfigCommentRuleParser, CosmeticRule, CosmeticRuleParser, CosmeticRuleSeparator, CosmeticRuleSeparatorFinderResult, CosmeticRuleSeparatorUtils, CosmeticRuleType, CssInjectionRule, CssInjectionRuleBody, Domain, DomainList, DomainListParser, DomainListSeparator, DomainUtils, EXT_CSS_LEGACY_ATTRIBUTES, EXT_CSS_PSEUDO_CLASSES, ElementHidingRule, ElementHidingRuleBody, EmptyRule, ExpressionOperatorNode, ExpressionParenthesisNode, ExpressionVariableNode, FORBIDDEN_CSS_FUNCTIONS, FilterList, FilterListConverter, FilterListParser, GenericPlatform, HINT_MARKER, Hint, HintCommentRule, HintCommentRuleParser, HintParser, HostRule, HostRuleParser, HostnameList, HtmlFilteringRule, HtmlFilteringRuleBody, IF, INCLUDE, InputByteBuffer, JsInjectionRule, KNOWN_METADATA_HEADERS, Location, LocationRange, LogicalExpressionParser, LogicalExpressionUtils, MODIFIERS_SEPARATOR, MODIFIER_ASSIGN_OPERATOR, MetadataCommentRule, MetadataCommentRuleParser, MethodListParser, Modifier, ModifierList, ModifierListParser, ModifierParser, NEGATION_MARKER, NETWORK_RULE_EXCEPTION_MARKER, NETWORK_RULE_SEPARATOR, NetworkRule, NetworkRuleParser, NetworkRuleType, Node, NotImplementedError, OutputByteBuffer, PIPE_MODIFIER_SEPARATOR, PREPROCESSOR_MARKER, ParameterList, ParameterListParser, ParserOptions, Position, PositionProvider, PreProcessorCommentRule, PreProcessorCommentRuleParser, ProductRecords, QuoteType, QuoteUtils, RawFilterListConverter, RawRuleConverter, RegExpUtils, ResourceType, RowByProduct, RowsByProduct, RuleBase, RuleCategorizer, RuleCategory, RuleConversionError, RuleConverter, RuleParser, SAFARI_CB_AFFINITY, SPECIAL_REGEX_SYMBOLS, ScriptletInjectionRule, ScriptletInjectionRuleBody, SpecificPlatform, StealthOptionListParser, TextEncoderPolyfillResult, UBO_SCRIPTLET_MASK, Value, VariableTable, decodeTextPolyfill, defaultParserOptions, encodeIntoPolyfill, getPlatformId, getResourceTypeModifier, getSpecificPlatformName, isGenericPlatform, isValidResourceType, modifierValidator, modifiersCompatibilityTable, parseRawPlatforms, redirectsCompatibilityTable, scriptletsCompatibilityTable };
