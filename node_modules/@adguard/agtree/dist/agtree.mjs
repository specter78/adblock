/*
 * AGTree v2.1.2 (build date: Thu, 19 Sep 2024 15:44:40 GMT)
 * (c) 2024 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
import valid from 'semver/functions/valid.js';
import coerce from 'semver/functions/coerce.js';
import JSON5 from 'json5';
import { sprintf } from 'sprintf-js';
import { TokenType as TokenType$1, tokenizeExtended, getFormattedTokenName } from '@adguard/css-tokenizer';
import * as tldts from 'tldts';
import { parse } from 'tldts';
import isIp from 'is-ip';
import XRegExp from 'xregexp';
import cloneDeep from 'clone-deep';
import { modifiersCompatibilityTableData, redirectsCompatibilityTableData, scriptletsCompatibilityTableData } from './compatibility-table-data.js';
import zod from 'zod';

/**
 * @file Possible adblock syntaxes are listed here.
 */
/**
 * Possible adblock syntaxes (supported by this library)
 */
var AdblockSyntax;
(function (AdblockSyntax) {
    /**
     * Common syntax, which is supported by more than one adblocker (or by all adblockers).
     *
     * We typically use this syntax when we cannot determine the concrete syntax of the rule,
     * because the syntax is used by more than one adblocker natively.
     *
     * @example
     * - `||example.org^$important` is a common syntax, since it is used by all adblockers natively, and
     * we cannot determine at parsing level whether `important` is a valid option or not, and if it is valid,
     * then which adblocker supports it.
     */
    AdblockSyntax["Common"] = "Common";
    /**
     * Adblock Plus syntax.
     *
     * @example
     * - `example.org#$#abort-on-property-read alert` is an Adblock Plus syntax, since it is not used by any other
     * adblockers directly (probably supported by some on-the-fly conversion, but this is not the native syntax).
     * @see {@link https://adblockplus.org/}
     */
    AdblockSyntax["Abp"] = "AdblockPlus";
    /**
     * uBlock Origin syntax.
     *
     * @example
     * - `example.com##+js(set, atob, noopFunc)` is an uBlock Origin syntax, since it is not used by any other
     * adblockers directly (probably supported by some on-the-fly conversion, but this is not the native syntax).
     * @see {@link https://github.com/gorhill/uBlock}
     */
    AdblockSyntax["Ubo"] = "UblockOrigin";
    /**
     * AdGuard syntax.
     *
     * @example
     * - `example.org#%#//scriptlet("abort-on-property-read", "alert")` is an AdGuard syntax, since it is not used
     * by any other adblockers directly (probably supported by some on-the-fly conversion, but this is not the native
     * syntax).
     * @see {@link https://adguard.com/}
     */
    AdblockSyntax["Adg"] = "AdGuard";
})(AdblockSyntax || (AdblockSyntax = {}));

/**
 * @file Constant values used by all parts of the library
 */
// TODO: remove unused constants
// General
/**
 * Empty string.
 */
const EMPTY = '';
const SPACE = ' ';
const TAB = '\t';
const COLON = ':';
const COMMA = ',';
const DOT = '.';
const SEMICOLON = ';';
const AMPERSAND = '&';
const ASTERISK = '*';
const AT_SIGN = '@';
const CARET = '^';
const DOLLAR_SIGN = '$';
const EQUALS = '=';
const EXCLAMATION_MARK = '!';
const HASHMARK = '#';
const PIPE = '|';
const PLUS = '+';
const QUESTION_MARK = '?';
const SLASH = '/';
const UNDERSCORE = '_';
// Escape characters
const BACKSLASH = '\\';
const ESCAPE_CHARACTER = BACKSLASH;
// Newlines
const CR = '\r';
const FF = '\f';
const LF = '\n';
const CRLF = CR + LF;
const NEWLINE = LF;
// Quotes
const BACKTICK_QUOTE = '`';
const DOUBLE_QUOTE = '"';
const SINGLE_QUOTE = '\'';
// Brackets
const OPEN_PARENTHESIS = '(';
const CLOSE_PARENTHESIS = ')';
const OPEN_SQUARE_BRACKET = '[';
const CLOSE_SQUARE_BRACKET = ']';
const OPEN_CURLY_BRACKET = '{';
const CLOSE_CURLY_BRACKET = '}';
// Letters
const SMALL_LETTER_A = 'a';
const SMALL_LETTER_B = 'b';
const SMALL_LETTER_C = 'c';
const SMALL_LETTER_D = 'd';
const SMALL_LETTER_E = 'e';
const SMALL_LETTER_F = 'f';
const SMALL_LETTER_G = 'g';
const SMALL_LETTER_H = 'h';
const SMALL_LETTER_I = 'i';
const SMALL_LETTER_J = 'j';
const SMALL_LETTER_K = 'k';
const SMALL_LETTER_L = 'l';
const SMALL_LETTER_M = 'm';
const SMALL_LETTER_N = 'n';
const SMALL_LETTER_O = 'o';
const SMALL_LETTER_P = 'p';
const SMALL_LETTER_Q = 'q';
const SMALL_LETTER_R = 'r';
const SMALL_LETTER_S = 's';
const SMALL_LETTER_T = 't';
const SMALL_LETTER_U = 'u';
const SMALL_LETTER_V = 'v';
const SMALL_LETTER_W = 'w';
const SMALL_LETTER_X = 'x';
const SMALL_LETTER_Y = 'y';
const SMALL_LETTER_Z = 'z';
/**
 * Set of all small letters.
 */
const SMALL_LETTERS = new Set([
    SMALL_LETTER_A,
    SMALL_LETTER_B,
    SMALL_LETTER_C,
    SMALL_LETTER_D,
    SMALL_LETTER_E,
    SMALL_LETTER_F,
    SMALL_LETTER_G,
    SMALL_LETTER_H,
    SMALL_LETTER_I,
    SMALL_LETTER_J,
    SMALL_LETTER_K,
    SMALL_LETTER_L,
    SMALL_LETTER_M,
    SMALL_LETTER_N,
    SMALL_LETTER_O,
    SMALL_LETTER_P,
    SMALL_LETTER_Q,
    SMALL_LETTER_R,
    SMALL_LETTER_S,
    SMALL_LETTER_T,
    SMALL_LETTER_U,
    SMALL_LETTER_V,
    SMALL_LETTER_W,
    SMALL_LETTER_X,
    SMALL_LETTER_Y,
    SMALL_LETTER_Z,
]);
// Capital letters
const CAPITAL_LETTER_A = 'A';
const CAPITAL_LETTER_B = 'B';
const CAPITAL_LETTER_C = 'C';
const CAPITAL_LETTER_D = 'D';
const CAPITAL_LETTER_E = 'E';
const CAPITAL_LETTER_F = 'F';
const CAPITAL_LETTER_G = 'G';
const CAPITAL_LETTER_H = 'H';
const CAPITAL_LETTER_I = 'I';
const CAPITAL_LETTER_J = 'J';
const CAPITAL_LETTER_K = 'K';
const CAPITAL_LETTER_L = 'L';
const CAPITAL_LETTER_M = 'M';
const CAPITAL_LETTER_N = 'N';
const CAPITAL_LETTER_O = 'O';
const CAPITAL_LETTER_P = 'P';
const CAPITAL_LETTER_Q = 'Q';
const CAPITAL_LETTER_R = 'R';
const CAPITAL_LETTER_S = 'S';
const CAPITAL_LETTER_T = 'T';
const CAPITAL_LETTER_U = 'U';
const CAPITAL_LETTER_V = 'V';
const CAPITAL_LETTER_W = 'W';
const CAPITAL_LETTER_X = 'X';
const CAPITAL_LETTER_Y = 'Y';
const CAPITAL_LETTER_Z = 'Z';
/**
 * Set of all capital letters.
 */
const CAPITAL_LETTERS = new Set([
    CAPITAL_LETTER_A,
    CAPITAL_LETTER_B,
    CAPITAL_LETTER_C,
    CAPITAL_LETTER_D,
    CAPITAL_LETTER_E,
    CAPITAL_LETTER_F,
    CAPITAL_LETTER_G,
    CAPITAL_LETTER_H,
    CAPITAL_LETTER_I,
    CAPITAL_LETTER_J,
    CAPITAL_LETTER_K,
    CAPITAL_LETTER_L,
    CAPITAL_LETTER_M,
    CAPITAL_LETTER_N,
    CAPITAL_LETTER_O,
    CAPITAL_LETTER_P,
    CAPITAL_LETTER_Q,
    CAPITAL_LETTER_R,
    CAPITAL_LETTER_S,
    CAPITAL_LETTER_T,
    CAPITAL_LETTER_U,
    CAPITAL_LETTER_V,
    CAPITAL_LETTER_W,
    CAPITAL_LETTER_X,
    CAPITAL_LETTER_Y,
    CAPITAL_LETTER_Z,
]);
// Numbers as strings
const NUMBER_0 = '0';
const NUMBER_1 = '1';
const NUMBER_2 = '2';
const NUMBER_3 = '3';
const NUMBER_4 = '4';
const NUMBER_5 = '5';
const NUMBER_6 = '6';
const NUMBER_7 = '7';
const NUMBER_8 = '8';
const NUMBER_9 = '9';
/**
 * Set of all numbers as strings.
 */
const NUMBERS = new Set([
    NUMBER_0,
    NUMBER_1,
    NUMBER_2,
    NUMBER_3,
    NUMBER_4,
    NUMBER_5,
    NUMBER_6,
    NUMBER_7,
    NUMBER_8,
    NUMBER_9,
]);
const REGEX_MARKER = '/';
const ADG_SCRIPTLET_MASK = '//scriptlet';
const UBO_SCRIPTLET_MASK = '+js';
const UBO_SCRIPTLET_MASK_LEGACY = 'script:inject';
const UBO_HTML_MASK = '^';
// Modifiers are separated by ",". For example: "script,domain=example.com"
const MODIFIERS_SEPARATOR = ',';
const MODIFIER_ASSIGN_OPERATOR = '=';
const NEGATION_MARKER = '~';
/**
 * The wildcard symbol â€” `*`.
 */
const WILDCARD = ASTERISK;
/**
 * Classic domain separator.
 *
 * @example
 * ```adblock
 * ! Domains are separated by ",":
 * example.com,~example.org##.ads
 * ```
 */
const COMMA_DOMAIN_LIST_SEPARATOR = ',';
/**
 * Modifier separator for $app, $denyallow, $domain, $method.
 *
 * @example
 * ```adblock
 * ! Domains are separated by "|":
 * ads.js^$script,domains=example.com|~example.org
 * ```
 */
const PIPE_MODIFIER_SEPARATOR = '|';
const CSS_MEDIA_MARKER = '@media';
const CSS_NOT_PSEUDO = 'not';
const HINT_MARKER = '!+';
const HINT_MARKER_LEN = HINT_MARKER.length;
const NETWORK_RULE_EXCEPTION_MARKER = '@@';
const NETWORK_RULE_EXCEPTION_MARKER_LEN = NETWORK_RULE_EXCEPTION_MARKER.length;
const NETWORK_RULE_SEPARATOR = '$';
const AGLINT_COMMAND_PREFIX = 'aglint';
const AGLINT_CONFIG_COMMENT_MARKER = '--';
const PREPROCESSOR_MARKER = '!#';
const PREPROCESSOR_MARKER_LEN = PREPROCESSOR_MARKER.length;
const PREPROCESSOR_SEPARATOR = ' ';
const SAFARI_CB_AFFINITY = 'safari_cb_affinity';
const IF = 'if';
const INCLUDE = 'include';
const NULL = 0;
const UINT8_MAX = 255;
const UINT16_MAX = 65535;

/**
 * @file Utility functions for string manipulation.
 */
const SINGLE_QUOTE_MARKER = "'";
const DOUBLE_QUOTE_MARKER = '"';
class StringUtils {
    /**
     * Finds the first occurrence of a character that:
     * - isn't preceded by an escape character
     *
     * @param pattern - Source pattern
     * @param searchedCharacter - Searched character
     * @param start - Start index
     * @param escapeCharacter - Escape character, \ by default
     * @returns Index or -1 if the character not found
     */
    static findNextUnescapedCharacter(pattern, searchedCharacter, start = 0, escapeCharacter = ESCAPE_CHARACTER) {
        for (let i = start; i < pattern.length; i += 1) {
            // The searched character cannot be preceded by an escape
            if (pattern[i] === searchedCharacter && pattern[i - 1] !== escapeCharacter) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Finds the first occurrence in backward direction of a character that isn't preceded by an escape character.
     *
     * @param pattern - Source pattern
     * @param searchedCharacter - Searched character
     * @param start - Start index
     * @param escapeCharacter - Escape character, \ by default
     * @returns Index or -1 if the character not found
     */
    static findNextUnescapedCharacterBackwards(pattern, searchedCharacter, start = pattern.length - 1, escapeCharacter = ESCAPE_CHARACTER) {
        for (let i = start; i >= 0; i -= 1) {
            // The searched character cannot be preceded by an escape
            if (pattern[i] === searchedCharacter && pattern[i - 1] !== escapeCharacter) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Finds the last occurrence of a character that:
     * - isn't preceded by an escape character
     *
     * @param pattern - Source pattern
     * @param searchedCharacter - Searched character
     * @param escapeCharacter - Escape character, \ by default
     * @returns Index or -1 if the character not found
     */
    static findLastUnescapedCharacter(pattern, searchedCharacter, escapeCharacter = ESCAPE_CHARACTER) {
        for (let i = pattern.length - 1; i >= 0; i -= 1) {
            // The searched character cannot be preceded by an escape
            if (pattern[i] === searchedCharacter && pattern[i - 1] !== escapeCharacter) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Finds the next occurrence of a character that:
     * - isn't preceded by an escape character
     * - isn't followed by the specified character
     *
     * @param pattern - Source pattern
     * @param start - Start index
     * @param searchedCharacter - Searched character
     * @param notFollowedBy - Searched character not followed by this character
     * @param escapeCharacter - Escape character, \ by default
     * @returns Index or -1 if the character not found
     */
    static findNextUnescapedCharacterThatNotFollowedBy(pattern, start, searchedCharacter, notFollowedBy, escapeCharacter = ESCAPE_CHARACTER) {
        for (let i = start; i < pattern.length; i += 1) {
            // The searched character cannot be preceded by an escape
            if (pattern[i] === searchedCharacter
                && pattern[i + 1] !== notFollowedBy
                && pattern[i - 1] !== escapeCharacter) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Finds the last occurrence of a character that:
     * - isn't preceded by an escape character
     * - isn't followed by the specified character
     *
     * @param pattern - Source pattern
     * @param searchedCharacter - Searched character
     * @param notFollowedBy - Searched character not followed by this character
     * @param escapeCharacter - Escape character, \ by default
     * @returns Index or -1 if the character not found
     */
    static findLastUnescapedCharacterThatNotFollowedBy(pattern, searchedCharacter, notFollowedBy, escapeCharacter = ESCAPE_CHARACTER) {
        for (let i = pattern.length - 1; i >= 0; i -= 1) {
            // The searched character cannot be preceded by an escape
            if (pattern[i] === searchedCharacter
                && pattern[i + 1] !== notFollowedBy
                && pattern[i - 1] !== escapeCharacter) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Finds the next occurrence of a character that:
     * - isn't part of any string literal ('literal' or "literal")
     * - isn't part of any RegExp expression (/regexp/)
     *
     * @param pattern - Source pattern
     * @param searchedCharacter - Searched character
     * @param start - Start index
     * @returns Index or -1 if the character not found
     */
    static findUnescapedNonStringNonRegexChar(pattern, searchedCharacter, start = 0) {
        let open = null;
        for (let i = start; i < pattern.length; i += 1) {
            if ((pattern[i] === SINGLE_QUOTE_MARKER
                || pattern[i] === DOUBLE_QUOTE_MARKER
                || pattern[i] === REGEX_MARKER)
                && pattern[i - 1] !== ESCAPE_CHARACTER) {
                if (open === pattern[i]) {
                    open = null;
                }
                else if (open === null) {
                    open = pattern[i];
                }
            }
            else if (open === null && pattern[i] === searchedCharacter && pattern[i - 1] !== ESCAPE_CHARACTER) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Finds the next occurrence of a character that:
     * - isn't part of any string literal ('literal' or "literal")
     * - isn't preceded by an escape character
     *
     * @param pattern - Source pattern
     * @param searchedCharacter - Searched character
     * @param start - Start index
     * @param escapeCharacter - Escape character, \ by default
     * @returns Index or -1 if the character not found
     */
    static findNextUnquotedUnescapedCharacter(pattern, searchedCharacter, start = 0, escapeCharacter = ESCAPE_CHARACTER) {
        let openQuote = null;
        for (let i = start; i < pattern.length; i += 1) {
            // Unescaped ' or "
            if ((pattern[i] === SINGLE_QUOTE_MARKER || pattern[i] === DOUBLE_QUOTE_MARKER)
                && pattern[i - 1] !== escapeCharacter) {
                if (!openQuote)
                    openQuote = pattern[i];
                else if (openQuote === pattern[i])
                    openQuote = null;
            }
            else if (pattern[i] === searchedCharacter && pattern[i - 1] !== escapeCharacter) {
                // Unescaped character
                if (!openQuote) {
                    return i;
                }
            }
        }
        return -1;
    }
    /**
     * Finds the next occurrence of a character that:
     * - isn't "bracketed"
     * - isn't preceded by an escape character
     *
     * @param pattern - Source pattern
     * @param searchedCharacter - Searched character
     * @param start - Start index
     * @param escapeCharacter - Escape character, \ by default
     * @param openBracket - Open bracket, ( by default
     * @param closeBracket - Close bracket, ( by default
     * @throws If the opening and closing brackets are the same
     * @returns Index or -1 if the character not found
     */
    static findNextNotBracketedUnescapedCharacter(pattern, searchedCharacter, start = 0, escapeCharacter = ESCAPE_CHARACTER, openBracket = '(', closeBracket = ')') {
        if (openBracket === closeBracket) {
            throw new Error('Open and close bracket cannot be the same');
        }
        let depth = 0;
        for (let i = start; i < pattern.length; i += 1) {
            if (pattern[i] === openBracket) {
                depth += 1;
            }
            else if (pattern[i] === closeBracket) {
                depth -= 1;
            }
            else if (depth < 1 && pattern[i] === searchedCharacter && pattern[i - 1] !== escapeCharacter) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Splits the source pattern along characters that:
     * - isn't part of any string literal ('literal' or "literal")
     * - isn't preceded by an escape character
     *
     * @param pattern - Source pattern
     * @param delimeterCharacter - Delimeter character
     * @returns Splitted string
     */
    static splitStringByUnquotedUnescapedCharacter(pattern, delimeterCharacter) {
        const parts = [];
        let delimeterIndex = -1;
        do {
            const prevDelimeterIndex = delimeterIndex;
            delimeterIndex = StringUtils.findNextUnquotedUnescapedCharacter(pattern, delimeterCharacter, delimeterIndex + 1);
            if (delimeterIndex !== -1) {
                parts.push(pattern.substring(prevDelimeterIndex + 1, delimeterIndex));
            }
            else {
                parts.push(pattern.substring(prevDelimeterIndex + 1, pattern.length));
            }
        } while (delimeterIndex !== -1);
        return parts;
    }
    /**
     * Splits the source pattern along characters that:
     * - isn't part of any string literal ('literal' or "literal")
     * - isn't part of any RegExp expression (/regexp/)
     * - isn't preceded by an escape character
     *
     * @param pattern - Source pattern
     * @param delimeterCharacter - Delimeter character
     * @returns Splitted string
     */
    static splitStringByUnescapedNonStringNonRegexChar(pattern, delimeterCharacter) {
        const parts = [];
        let delimeterIndex = -1;
        do {
            const prevDelimeterIndex = delimeterIndex;
            delimeterIndex = StringUtils.findUnescapedNonStringNonRegexChar(pattern, delimeterCharacter, delimeterIndex + 1);
            if (delimeterIndex !== -1) {
                parts.push(pattern.substring(prevDelimeterIndex + 1, delimeterIndex));
            }
            else {
                parts.push(pattern.substring(prevDelimeterIndex + 1, pattern.length));
            }
        } while (delimeterIndex !== -1);
        return parts;
    }
    /**
     * Splits the source pattern along characters that:
     * - isn't preceded by an escape character
     *
     * @param pattern - Source pattern
     * @param delimeterCharacter - Delimeter character
     * @returns Splitted string
     */
    static splitStringByUnescapedCharacter(pattern, delimeterCharacter) {
        const parts = [];
        let delimeterIndex = -1;
        do {
            const prevDelimeterIndex = delimeterIndex;
            delimeterIndex = StringUtils.findNextUnescapedCharacter(pattern, delimeterCharacter, delimeterIndex + 1);
            if (delimeterIndex !== -1) {
                parts.push(pattern.substring(prevDelimeterIndex + 1, delimeterIndex));
            }
            else {
                parts.push(pattern.substring(prevDelimeterIndex + 1, pattern.length));
            }
        } while (delimeterIndex !== -1);
        return parts;
    }
    /**
     * Determines whether the given character is a space or tab character.
     *
     * @param char - The character to check.
     * @returns true if the given character is a space or tab character, false otherwise.
     */
    static isWhitespace(char) {
        return char === SPACE || char === TAB;
    }
    /**
     * Checks if the given character is a digit.
     *
     * @param char The character to check.
     * @returns `true` if the given character is a digit, `false` otherwise.
     */
    static isDigit(char) {
        return char >= NUMBER_0 && char <= NUMBER_9;
    }
    /**
     * Checks if the given character is a small letter.
     *
     * @param char The character to check.
     * @returns `true` if the given character is a small letter, `false` otherwise.
     */
    static isSmallLetter(char) {
        return char >= SMALL_LETTER_A && char <= SMALL_LETTER_Z;
    }
    /**
     * Checks if the given character is a capital letter.
     *
     * @param char The character to check.
     * @returns `true` if the given character is a capital letter, `false` otherwise.
     */
    static isCapitalLetter(char) {
        return char >= CAPITAL_LETTER_A && char <= CAPITAL_LETTER_Z;
    }
    /**
     * Checks if the given character is a letter (small or capital).
     *
     * @param char The character to check.
     * @returns `true` if the given character is a letter, `false` otherwise.
     */
    static isLetter(char) {
        return StringUtils.isSmallLetter(char) || StringUtils.isCapitalLetter(char);
    }
    /**
     * Checks if the given character is a letter or a digit.
     *
     * @param char Character to check
     * @returns `true` if the given character is a letter or a digit, `false` otherwise.
     */
    static isAlphaNumeric(char) {
        return StringUtils.isLetter(char) || StringUtils.isDigit(char);
    }
    /**
     * Searches for the first non-whitespace character in the source pattern.
     *
     * @param pattern - Source pattern
     * @param start - Start index
     * @returns Index or -1 if the character not found
     */
    static findFirstNonWhitespaceCharacter(pattern, start = 0) {
        for (let i = start; i < pattern.length; i += 1) {
            if (!StringUtils.isWhitespace(pattern[i])) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Searches for the last non-whitespace character in the source pattern.
     *
     * @param pattern - Source pattern
     * @returns Index or -1 if the character not found
     */
    static findLastNonWhitespaceCharacter(pattern) {
        for (let i = pattern.length - 1; i >= 0; i -= 1) {
            if (!StringUtils.isWhitespace(pattern[i])) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Finds the next whitespace character in the pattern.
     *
     * @param pattern Pattern to search in
     * @param start Start index
     * @returns Index of the next whitespace character or the length of the pattern if not found
     */
    static findNextWhitespaceCharacter(pattern, start = 0) {
        for (let i = start; i < pattern.length; i += 1) {
            if (StringUtils.isWhitespace(pattern[i])) {
                return i;
            }
        }
        return pattern.length;
    }
    /**
     * Escapes a specified character in the string.
     *
     * @param pattern - Input string
     * @param character - Character to escape
     * @param escapeCharacter - Escape character (optional)
     * @returns Escaped string
     */
    static escapeCharacter(pattern, character, escapeCharacter = ESCAPE_CHARACTER) {
        let result = EMPTY;
        for (let i = 0; i < pattern.length; i += 1) {
            if (pattern[i] === character && pattern[i - 1] !== escapeCharacter) {
                result += escapeCharacter;
            }
            result += pattern[i];
        }
        return result;
    }
    /**
     * Searches for the next non-whitespace character in the source pattern.
     *
     * @param pattern Pattern to search
     * @param start Start index
     * @returns Index of the next non-whitespace character or the length of the pattern
     */
    static skipWS(pattern, start = 0) {
        let i = start;
        while (i < pattern.length && StringUtils.isWhitespace(pattern[i])) {
            i += 1;
        }
        return Math.min(i, pattern.length);
    }
    /**
     * Searches for the previous non-whitespace character in the source pattern.
     *
     * @param pattern Pattern to search
     * @param start Start index
     * @returns Index of the previous non-whitespace character or -1
     */
    static skipWSBack(pattern, start = pattern.length - 1) {
        let i = start;
        while (i >= 0 && StringUtils.isWhitespace(pattern[i])) {
            i -= 1;
        }
        return Math.max(i, -1);
    }
    /**
     * Checks if the given character is a new line character.
     *
     * @param char Character to check
     * @returns `true` if the given character is a new line character, `false` otherwise.
     */
    static isEOL(char) {
        return char === CR || char === LF || char === FF;
    }
    /**
     * Splits a string along newline characters.
     *
     * @param input - Input string
     * @returns Splitted string
     */
    static splitStringByNewLines(input) {
        return input.split(/\r?\n/);
    }
    /**
     * Splits a string by new lines and stores the new line type for each line
     *
     * @param input The input string to be split
     * @returns An array of tuples, where each tuple contains a line of the input string and its
     * corresponding new line type ("lf", "crlf", or "cr")
     */
    static splitStringByNewLinesEx(input) {
        // Array to store the tuples of line and new line type
        const result = [];
        let currentLine = EMPTY;
        let newLineType = null;
        // Iterate over each character in the input string
        for (let i = 0; i < input.length; i += 1) {
            const char = input[i];
            if (char === CR) {
                if (input[i + 1] === LF) {
                    newLineType = 'crlf';
                    i += 1;
                }
                else {
                    newLineType = 'cr';
                }
                result.push([currentLine, newLineType]);
                currentLine = EMPTY;
                newLineType = null;
            }
            else if (char === LF) {
                newLineType = 'lf';
                result.push([currentLine, newLineType]);
                currentLine = EMPTY;
                newLineType = null;
            }
            else {
                currentLine += char;
            }
        }
        if (result.length === 0 || currentLine !== EMPTY) {
            result.push([currentLine, newLineType]);
        }
        return result;
    }
    /**
     * Merges an array of tuples (line, newLineType) into a single string
     *
     * @param input The array of tuples to be merged
     * @returns A single string containing the lines and new line characters from the input array
     */
    static mergeStringByNewLines(input) {
        let result = EMPTY;
        // Iterate over each tuple in the input array
        for (let i = 0; i < input.length; i += 1) {
            const [line, newLineType] = input[i];
            // Add the line to the result string
            result += line;
            // Add the appropriate new line character based on the newLineType
            if (newLineType !== null) {
                if (newLineType === 'crlf') {
                    result += CRLF;
                }
                else if (newLineType === 'cr') {
                    result += CR;
                }
                else {
                    result += LF;
                }
            }
        }
        return result;
    }
    /**
     * Helper method to parse a raw string as a number
     *
     * @param raw Raw string to parse
     * @returns Parsed number
     * @throws If the raw string can't be parsed as a number
     */
    static parseNumber(raw) {
        const result = parseInt(raw, 10);
        if (Number.isNaN(result)) {
            throw new Error('Expected a number');
        }
        return result;
    }
    /**
     * Checks if the given value is a string.
     *
     * @param value Value to check
     * @returns `true` if the value is a string, `false` otherwise
     */
    static isString(value) {
        return typeof value === 'string';
    }
    /**
     * Escapes the given characters in the input string.
     *
     * @param input Input string
     * @param characters Characters to escape (by default, no characters are escaped)
     * @returns Escaped string
     */
    static escapeCharacters(input, characters = new Set()) {
        let result = EMPTY;
        for (let i = 0; i < input.length; i += 1) {
            if (characters.has(input[i])) {
                result += ESCAPE_CHARACTER;
            }
            result += input[i];
        }
        return result;
    }
}

/**
 * Possible operators in the logical expression.
 */
var OperatorValue;
(function (OperatorValue) {
    OperatorValue["Not"] = "!";
    OperatorValue["And"] = "&&";
    OperatorValue["Or"] = "||";
})(OperatorValue || (OperatorValue = {}));
/**
 * Represents the different comment markers that can be used in an adblock rule.
 *
 * @example
 * - If the rule is `! This is just a comment`, then the marker will be `!`.
 * - If the rule is `# This is just a comment`, then the marker will be `#`.
 */
var CommentMarker;
(function (CommentMarker) {
    /**
     * Regular comment marker. It is supported by all ad blockers.
     */
    CommentMarker["Regular"] = "!";
    /**
     * Hashmark comment marker. It is supported by uBlock Origin and AdGuard,
     * and also used in hosts files.
     */
    CommentMarker["Hashmark"] = "#";
})(CommentMarker || (CommentMarker = {}));
/**
 * Represents the main categories that an adblock rule can belong to.
 * Of course, these include additional subcategories.
 */
var RuleCategory;
(function (RuleCategory) {
    /**
     * Empty "rules" that are only containing whitespaces. These rules are handled just for convenience.
     */
    RuleCategory["Empty"] = "Empty";
    /**
     * Syntactically invalid rules (tolerant mode only).
     */
    RuleCategory["Invalid"] = "Invalid";
    /**
     * Comment rules, such as comment rules, metadata rules, preprocessor rules, etc.
     */
    RuleCategory["Comment"] = "Comment";
    /**
     * Cosmetic rules, such as element hiding rules, CSS rules, scriptlet rules, HTML rules, and JS rules.
     */
    RuleCategory["Cosmetic"] = "Cosmetic";
    /**
     * Network rules, such as basic network rules, header remover network rules, redirect network rules,
     * response header filtering rules, etc.
     */
    RuleCategory["Network"] = "Network";
})(RuleCategory || (RuleCategory = {}));
/**
 * Represents similar types of modifiers values
 * which may be separated by a comma `,` (only for DomainList) or a pipe `|`.
 */
var ListNodeType;
(function (ListNodeType) {
    ListNodeType["Unknown"] = "Unknown";
    ListNodeType["AppList"] = "AppList";
    ListNodeType["DomainList"] = "DomainList";
    ListNodeType["MethodList"] = "MethodList";
    ListNodeType["StealthOptionList"] = "StealthOptionList";
})(ListNodeType || (ListNodeType = {}));
/**
 * Represents child items for {@link ListNodeType}.
 */
var ListItemNodeType;
(function (ListItemNodeType) {
    ListItemNodeType["Unknown"] = "Unknown";
    ListItemNodeType["App"] = "App";
    ListItemNodeType["Domain"] = "Domain";
    ListItemNodeType["Method"] = "Method";
    ListItemNodeType["StealthOption"] = "StealthOption";
})(ListItemNodeType || (ListItemNodeType = {}));
/**
 * Represents possible comment types.
 */
var CommentRuleType;
(function (CommentRuleType) {
    CommentRuleType["AgentCommentRule"] = "AgentCommentRule";
    CommentRuleType["CommentRule"] = "CommentRule";
    CommentRuleType["ConfigCommentRule"] = "ConfigCommentRule";
    CommentRuleType["HintCommentRule"] = "HintCommentRule";
    CommentRuleType["MetadataCommentRule"] = "MetadataCommentRule";
    CommentRuleType["PreProcessorCommentRule"] = "PreProcessorCommentRule";
})(CommentRuleType || (CommentRuleType = {}));
/**
 * Represents possible cosmetic rule types.
 */
var CosmeticRuleType;
(function (CosmeticRuleType) {
    CosmeticRuleType["ElementHidingRule"] = "ElementHidingRule";
    CosmeticRuleType["CssInjectionRule"] = "CssInjectionRule";
    CosmeticRuleType["ScriptletInjectionRule"] = "ScriptletInjectionRule";
    CosmeticRuleType["HtmlFilteringRule"] = "HtmlFilteringRule";
    CosmeticRuleType["JsInjectionRule"] = "JsInjectionRule";
})(CosmeticRuleType || (CosmeticRuleType = {}));
/**
 * Represents possible cosmetic rule separators.
 */
var CosmeticRuleSeparator;
(function (CosmeticRuleSeparator) {
    /**
     * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#elemhide_basic}
     */
    CosmeticRuleSeparator["ElementHiding"] = "##";
    /**
     * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#elemhide_basic}
     */
    CosmeticRuleSeparator["ElementHidingException"] = "#@#";
    /**
     * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#elemhide_basic}
     */
    CosmeticRuleSeparator["ExtendedElementHiding"] = "#?#";
    /**
     * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#elemhide_basic}
     */
    CosmeticRuleSeparator["ExtendedElementHidingException"] = "#@?#";
    /**
     * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#elemhide_basic}
     */
    CosmeticRuleSeparator["AbpSnippet"] = "#$#";
    /**
     * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#elemhide_basic}
     */
    CosmeticRuleSeparator["AbpSnippetException"] = "#@$#";
    /**
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-css-rules}
     */
    CosmeticRuleSeparator["AdgCssInjection"] = "#$#";
    /**
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-css-rules}
     */
    CosmeticRuleSeparator["AdgCssInjectionException"] = "#@$#";
    /**
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-css-rules}
     */
    CosmeticRuleSeparator["AdgExtendedCssInjection"] = "#$?#";
    /**
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-css-rules}
     */
    CosmeticRuleSeparator["AdgExtendedCssInjectionException"] = "#@$?#";
    /**
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#scriptlets}
     */
    CosmeticRuleSeparator["AdgJsInjection"] = "#%#";
    /**
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#scriptlets}
     */
    CosmeticRuleSeparator["AdgJsInjectionException"] = "#@%#";
    /**
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#html-filtering-rules}
     */
    CosmeticRuleSeparator["AdgHtmlFiltering"] = "$$";
    /**
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#html-filtering-rules}
     */
    CosmeticRuleSeparator["AdgHtmlFilteringException"] = "$@$";
})(CosmeticRuleSeparator || (CosmeticRuleSeparator = {}));
/**
 * Type map for binary serialization.
 *
 * @note Values should be fit into 8 bits.
 */
var BinaryTypeMap;
(function (BinaryTypeMap) {
    // Basic types
    BinaryTypeMap[BinaryTypeMap["Null"] = 1] = "Null";
    BinaryTypeMap[BinaryTypeMap["Undefined"] = 2] = "Undefined";
    BinaryTypeMap[BinaryTypeMap["Boolean"] = 3] = "Boolean";
    BinaryTypeMap[BinaryTypeMap["Int"] = 4] = "Int";
    BinaryTypeMap[BinaryTypeMap["Float"] = 5] = "Float";
    BinaryTypeMap[BinaryTypeMap["NotANumber"] = 6] = "NotANumber";
    BinaryTypeMap[BinaryTypeMap["String"] = 7] = "String";
    // AGTree nodes
    BinaryTypeMap[BinaryTypeMap["FilterListNode"] = 8] = "FilterListNode";
    BinaryTypeMap[BinaryTypeMap["EmptyRule"] = 9] = "EmptyRule";
    BinaryTypeMap[BinaryTypeMap["InvalidRule"] = 10] = "InvalidRule";
    BinaryTypeMap[BinaryTypeMap["CommentRuleNode"] = 11] = "CommentRuleNode";
    BinaryTypeMap[BinaryTypeMap["AgentNode"] = 12] = "AgentNode";
    BinaryTypeMap[BinaryTypeMap["AgentRuleNode"] = 13] = "AgentRuleNode";
    BinaryTypeMap[BinaryTypeMap["HintNode"] = 14] = "HintNode";
    BinaryTypeMap[BinaryTypeMap["HintRuleNode"] = 15] = "HintRuleNode";
    BinaryTypeMap[BinaryTypeMap["MetadataCommentRuleNode"] = 16] = "MetadataCommentRuleNode";
    BinaryTypeMap[BinaryTypeMap["ConfigCommentRuleNode"] = 17] = "ConfigCommentRuleNode";
    BinaryTypeMap[BinaryTypeMap["PreProcessorCommentRuleNode"] = 18] = "PreProcessorCommentRuleNode";
    BinaryTypeMap[BinaryTypeMap["ConfigNode"] = 19] = "ConfigNode";
    BinaryTypeMap[BinaryTypeMap["NetworkRuleNode"] = 20] = "NetworkRuleNode";
    BinaryTypeMap[BinaryTypeMap["HostRuleNode"] = 21] = "HostRuleNode";
    BinaryTypeMap[BinaryTypeMap["ElementHidingRule"] = 22] = "ElementHidingRule";
    BinaryTypeMap[BinaryTypeMap["CssInjectionRule"] = 23] = "CssInjectionRule";
    BinaryTypeMap[BinaryTypeMap["ScriptletInjectionRule"] = 24] = "ScriptletInjectionRule";
    BinaryTypeMap[BinaryTypeMap["JsInjectionRule"] = 25] = "JsInjectionRule";
    BinaryTypeMap[BinaryTypeMap["HtmlFilteringRule"] = 26] = "HtmlFilteringRule";
    BinaryTypeMap[BinaryTypeMap["ScriptletInjectionRuleBodyNode"] = 27] = "ScriptletInjectionRuleBodyNode";
    BinaryTypeMap[BinaryTypeMap["ElementHidingRuleBody"] = 28] = "ElementHidingRuleBody";
    BinaryTypeMap[BinaryTypeMap["CssInjectionRuleBody"] = 29] = "CssInjectionRuleBody";
    BinaryTypeMap[BinaryTypeMap["HtmlFilteringRuleBody"] = 30] = "HtmlFilteringRuleBody";
    BinaryTypeMap[BinaryTypeMap["JsInjectionRuleBody"] = 31] = "JsInjectionRuleBody";
    BinaryTypeMap[BinaryTypeMap["ValueNode"] = 32] = "ValueNode";
    BinaryTypeMap[BinaryTypeMap["RawNode"] = 33] = "RawNode";
    BinaryTypeMap[BinaryTypeMap["ModifierNode"] = 34] = "ModifierNode";
    BinaryTypeMap[BinaryTypeMap["ModifierListNode"] = 35] = "ModifierListNode";
    BinaryTypeMap[BinaryTypeMap["ParameterListNode"] = 36] = "ParameterListNode";
    BinaryTypeMap[BinaryTypeMap["DomainListNode"] = 37] = "DomainListNode";
    BinaryTypeMap[BinaryTypeMap["DomainNode"] = 38] = "DomainNode";
    BinaryTypeMap[BinaryTypeMap["MethodListNode"] = 39] = "MethodListNode";
    BinaryTypeMap[BinaryTypeMap["MethodNode"] = 40] = "MethodNode";
    BinaryTypeMap[BinaryTypeMap["StealthOptionListNode"] = 41] = "StealthOptionListNode";
    BinaryTypeMap[BinaryTypeMap["StealthOptionNode"] = 42] = "StealthOptionNode";
    BinaryTypeMap[BinaryTypeMap["AppListNode"] = 43] = "AppListNode";
    BinaryTypeMap[BinaryTypeMap["AppNode"] = 44] = "AppNode";
    BinaryTypeMap[BinaryTypeMap["HostnameListNode"] = 45] = "HostnameListNode";
    BinaryTypeMap[BinaryTypeMap["InvalidRuleErrorNode"] = 46] = "InvalidRuleErrorNode";
    BinaryTypeMap[BinaryTypeMap["ExpressionVariableNode"] = 47] = "ExpressionVariableNode";
    BinaryTypeMap[BinaryTypeMap["ExpressionOperatorNode"] = 48] = "ExpressionOperatorNode";
    BinaryTypeMap[BinaryTypeMap["ExpressionParenthesisNode"] = 49] = "ExpressionParenthesisNode";
})(BinaryTypeMap || (BinaryTypeMap = {}));
/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const SYNTAX_SERIALIZATION_MAP = new Map([
    [AdblockSyntax.Common, 0],
    [AdblockSyntax.Abp, 1],
    [AdblockSyntax.Adg, 2],
    [AdblockSyntax.Ubo, 3],
]);
/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
const SYNTAX_DESERIALIZATION_MAP = new Map(Array.from(SYNTAX_SERIALIZATION_MAP, ([key, value]) => [value, key]));
/**
 * Represents the different types of network rules.
 */
var NetworkRuleType;
(function (NetworkRuleType) {
    NetworkRuleType["NetworkRule"] = "NetworkRule";
    NetworkRuleType["HostRule"] = "HostRule";
})(NetworkRuleType || (NetworkRuleType = {}));

/**
 * @file Customized syntax error class for Adblock Filter Parser.
 */
const ERROR_NAME$3 = 'AdblockSyntaxError';
/**
 * Customized syntax error class for Adblock Filter Parser,
 * which contains the location range of the error.
 */
class AdblockSyntaxError extends SyntaxError {
    /**
     * Start offset of the error.
     */
    start;
    /**
     * End offset of the error.
     */
    end;
    /**
     * Constructs a new `AdblockSyntaxError` instance.
     *
     * @param message Error message.
     * @param start Start offset of the error.
     * @param end End offset of the error.
     */
    constructor(message, start, end) {
        super(message);
        this.name = ERROR_NAME$3;
        this.start = start;
        this.end = end;
    }
}

/**
 * @file Customized error class for not implemented features.
 */
const ERROR_NAME$2 = 'NotImplementedError';
const BASE_MESSAGE = 'Not implemented';
/**
 * Customized error class for not implemented features.
 */
class NotImplementedError extends Error {
    /**
     * Constructs a new `NotImplementedError` instance.
     *
     * @param message Additional error message (optional)
     */
    constructor(message = undefined) {
        // Prepare the full error message
        const fullMessage = message
            ? `${BASE_MESSAGE}: ${message}`
            : BASE_MESSAGE;
        super(fullMessage);
        this.name = ERROR_NAME$2;
    }
}

/* eslint-disable @typescript-eslint/no-unused-vars */
/**
 * @file Base parser class.
 */
/**
 * Base class for parsers. Each parser should extend this class.
 */
class ParserBase {
    /**
     * Parses the input string and returns the AST node.
     *
     * @param input Input string to parse.
     * @param options Parser options, see {@link ParserOptions}.
     * @param baseOffset Base offset. Locations in the AST node will be relative to this offset.
     * @param args Additional, parser-specific arguments, if needed.
     */
    static parse(input, options, baseOffset, ...args) {
        throw new NotImplementedError();
    }
    /**
     * Generates a string from the AST node.
     *
     * @param node AST node to generate a string from.
     */
    static generate(node) {
        throw new NotImplementedError();
    }
    /**
     * Serializes the AST node to a byte buffer.
     *
     * @param node AST node to serialize.
     * @param buffer Output byte buffer to write to.
     * @param args Additional, parser-specific arguments, if needed.
     */
    static serialize(node, buffer, ...args) {
        throw new NotImplementedError();
    }
    /**
     * Deserializes the AST node from a byte buffer.
     *
     * @param buffer Input byte buffer to read from.
     * @param node Destination node to write to.
     * @param args Additional, parser-specific arguments, if needed.
     */
    static deserialize(buffer, node, ...args) {
        throw new NotImplementedError();
    }
}

/**
 * @file Common options for all parsers.
 */
/**
 * Default parser options.
 */
const defaultParserOptions = Object.freeze({
    tolerant: false,
    isLocIncluded: true,
    parseAbpSpecificRules: true,
    parseUboSpecificRules: true,
    includeRaws: true,
    ignoreComments: false,
    parseHostRules: false,
});

/**
 * Checks whether the given value is undefined.
 *
 * @param value Value to check.
 *
 * @returns `true` if the value is 'undefined', `false` otherwise.
 */
const isUndefined = (value) => {
    return typeof value === 'undefined';
};
/**
 * Checks whether the given value is null.
 *
 * @param value Value to check.
 *
 * @returns `true` if the value is 'null', `false` otherwise.
 */
const isNull = (value) => {
    return value === null;
};
/**
 * Checks whether the given value is a string.
 *
 * @param value Value to check.
 * @returns `true` if the value is a string, `false` otherwise.
 */
const isString = (value) => {
    return typeof value === 'string';
};
/**
 * Checks whether the given value is an array of Uint8Arrays.
 *
 * @param value Value to check.
 *
 * @returns True if the value type is an array of Uint8Arrays.
 */
const isArrayOfUint8Arrays = (value) => {
    return Array.isArray(value) && value.every((chunk) => chunk instanceof Uint8Array);
};

/* eslint-disable no-param-reassign */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
var ValueNodeSerializationMap;
(function (ValueNodeSerializationMap) {
    ValueNodeSerializationMap[ValueNodeSerializationMap["Value"] = 1] = "Value";
    ValueNodeSerializationMap[ValueNodeSerializationMap["FrequentValue"] = 2] = "FrequentValue";
    ValueNodeSerializationMap[ValueNodeSerializationMap["Start"] = 3] = "Start";
    ValueNodeSerializationMap[ValueNodeSerializationMap["End"] = 4] = "End";
})(ValueNodeSerializationMap || (ValueNodeSerializationMap = {}));
/**
 * Value parser.
 * This parser is very simple, it just exists to provide a consistent interface for parsing and generating values.
 */
class ValueParser extends ParserBase {
    /**
     * Parses a value.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     *
     * @returns Value node.
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0) {
        const result = {
            type: 'Value',
            value: raw,
        };
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        return result;
    }
    /**
     * Converts a value node to a string.
     *
     * @param node Value node.
     * @returns Raw string.
     */
    static generate(node) {
        return node.value;
    }
    /**
     * Serializes a value node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     * @param frequentValuesMap Optional map of frequent values.
     * @param toLower Whether to lowercase the value before the frequent value match (defaults to `false`).
     */
    static serialize(node, buffer, frequentValuesMap, toLower = false) {
        buffer.writeUint8(BinaryTypeMap.ValueNode);
        const frequentValue = frequentValuesMap?.get(toLower ? node.value.toLowerCase() : node.value);
        // note: do not use just `if (frequentValue)` because it can be 0
        if (!isUndefined(frequentValue)) {
            buffer.writeUint8(ValueNodeSerializationMap.FrequentValue);
            buffer.writeUint8(frequentValue);
        }
        else {
            buffer.writeUint8(ValueNodeSerializationMap.Value);
            buffer.writeString(node.value);
        }
        // note: do not use just `if (node.start)` because it can be 0
        if (!isUndefined(node.start)) {
            buffer.writeUint8(ValueNodeSerializationMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(ValueNodeSerializationMap.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Deserializes a value node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @param frequentValuesMap Optional map of frequent values.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node, frequentValuesMap) {
        buffer.assertUint8(BinaryTypeMap.ValueNode);
        node.type = 'Value';
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case ValueNodeSerializationMap.Value:
                    node.value = buffer.readString();
                    break;
                case ValueNodeSerializationMap.FrequentValue:
                    node.value = frequentValuesMap?.get(buffer.readUint8()) ?? EMPTY;
                    break;
                case ValueNodeSerializationMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case ValueNodeSerializationMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
}

/* eslint-disable no-param-reassign */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
var AgentNodeSerializationMap;
(function (AgentNodeSerializationMap) {
    AgentNodeSerializationMap[AgentNodeSerializationMap["Adblock"] = 1] = "Adblock";
    AgentNodeSerializationMap[AgentNodeSerializationMap["Version"] = 2] = "Version";
    AgentNodeSerializationMap[AgentNodeSerializationMap["Start"] = 3] = "Start";
    AgentNodeSerializationMap[AgentNodeSerializationMap["End"] = 4] = "End";
})(AgentNodeSerializationMap || (AgentNodeSerializationMap = {}));
/**
 * Possible AdGuard agent markers.
 */
const ADG_NAME_MARKERS = new Set([
    'adguard',
    'adg',
]);
/**
 * Possible uBlock Origin agent markers.
 */
const UBO_NAME_MARKERS = new Set([
    'ublock',
    'ublock origin',
    'ubo',
]);
/**
 * Possible Adblock Plus agent markers.
 */
const ABP_NAME_MARKERS = new Set([
    'adblock',
    'adblock plus',
    'adblockplus',
    'abp',
]);
/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
const FREQUENT_AGENTS_DESERIALIZATION_MAP = new Map([
    // AdGuard
    [0, 'AdGuard'],
    [1, 'ADG'],
    // uBlock Origin
    [2, 'uBlock Origin'],
    [3, 'uBlock'],
    [4, 'uBO'],
    // Adblock Plus
    [5, 'Adblock Plus'],
    [6, 'AdblockPlus'],
    [7, 'ABP'],
    [8, 'AdBlock'],
]);
/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const FREQUENT_AGENTS_SERIALIZATION_MAP = new Map(Array.from(FREQUENT_AGENTS_DESERIALIZATION_MAP).map(([key, value]) => [value.toLowerCase(), key]));
/**
 * Returns the adblock syntax based on the adblock name parsed from the agent type comment.
 * Needed for modifiers validation of network rules by AGLint.
 *
 * @param name Adblock name.
 *
 * @returns Adblock syntax.
 */
const getAdblockSyntax = (name) => {
    let syntax = AdblockSyntax.Common;
    const lowerCaseName = name.toLowerCase();
    if (ADG_NAME_MARKERS.has(lowerCaseName)) {
        syntax = AdblockSyntax.Adg;
    }
    else if (UBO_NAME_MARKERS.has(lowerCaseName)) {
        syntax = AdblockSyntax.Ubo;
    }
    else if (ABP_NAME_MARKERS.has(lowerCaseName)) {
        syntax = AdblockSyntax.Abp;
    }
    return syntax;
};
/**
 * `AgentParser` is responsible for parsing single adblock agent elements.
 *
 * @example
 * If the adblock agent rule is
 * ```adblock
 * [Adblock Plus 2.0; AdGuard]
 * ```
 * then the adblock agents are `Adblock Plus 2.0` and `AdGuard`, and this
 * class is responsible for parsing them. The rule itself is parsed by
 * `AgentCommentRuleParser`, which uses this class to parse single agents.
 */
class AgentParser extends ParserBase {
    /**
     * Checks if the string is a valid version.
     *
     * @param str String to check
     * @returns `true` if the string is a valid version, `false` otherwise
     */
    static isValidVersion(str) {
        return valid(coerce(str)) !== null;
    }
    /**
     * Parses a raw rule as an adblock agent comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Agent rule AST
     * @throws {AdblockSyntaxError} If the raw rule cannot be parsed as an adblock agent
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0) {
        let offset = 0;
        // Save name start position
        const nameStartIndex = offset;
        let nameEndIndex = offset;
        // Prepare variables for name and version
        let name;
        let version;
        // default value for the syntax
        let syntax = AdblockSyntax.Common;
        // Get agent parts by splitting it by spaces. The last part may be a version.
        // Example: "Adblock Plus 2.0"
        while (offset < raw.length) {
            // Skip whitespace before the part
            offset = StringUtils.skipWS(raw, offset);
            const partEnd = StringUtils.findNextWhitespaceCharacter(raw, offset);
            const part = raw.slice(offset, partEnd);
            if (AgentParser.isValidVersion(part)) {
                if (!isUndefined(version)) {
                    throw new AdblockSyntaxError('Duplicated versions are not allowed', baseOffset + offset, baseOffset + partEnd);
                }
                const parsedNamePart = raw.slice(nameStartIndex, nameEndIndex);
                name = ValueParser.parse(parsedNamePart, options, baseOffset + nameStartIndex);
                version = ValueParser.parse(part, options, baseOffset + offset);
                syntax = getAdblockSyntax(parsedNamePart);
            }
            else {
                nameEndIndex = partEnd;
            }
            // Skip whitespace after the part
            offset = StringUtils.skipWS(raw, partEnd);
        }
        // If we didn't find a version, the whole string is the name
        if (isUndefined(name)) {
            const parsedNamePart = raw.slice(nameStartIndex, nameEndIndex);
            name = ValueParser.parse(parsedNamePart, options, baseOffset + nameStartIndex);
            syntax = getAdblockSyntax(parsedNamePart);
        }
        // Agent name cannot be empty
        if (name.value.length === 0) {
            throw new AdblockSyntaxError('Agent name cannot be empty', baseOffset, baseOffset + raw.length);
        }
        const result = {
            type: 'Agent',
            adblock: name,
            syntax,
        };
        // only add version if it's present
        if (version) {
            result.version = version;
        }
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        return result;
    }
    /**
     * Converts an adblock agent node to a string.
     *
     * @param value Agent node
     * @returns Raw string
     */
    static generate(value) {
        let result = EMPTY;
        // Agent adblock name
        result += value.adblock.value;
        // Agent adblock version (if present)
        if (!isUndefined(value.version)) {
            // Add a space between the name and the version
            result += SPACE;
            result += value.version.value;
        }
        return result;
    }
    /**
     * Serializes an agent node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node, buffer) {
        buffer.writeUint8(BinaryTypeMap.AgentNode);
        buffer.writeUint8(AgentNodeSerializationMap.Adblock);
        ValueParser.serialize(node.adblock, buffer, FREQUENT_AGENTS_SERIALIZATION_MAP, true);
        if (!isUndefined(node.version)) {
            buffer.writeUint8(AgentNodeSerializationMap.Version);
            ValueParser.serialize(node.version, buffer);
        }
        if (!isUndefined(node.start)) {
            buffer.writeUint8(AgentNodeSerializationMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(AgentNodeSerializationMap.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Deserializes an agent node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(BinaryTypeMap.AgentNode);
        node.type = 'Agent';
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case AgentNodeSerializationMap.Adblock:
                    ValueParser.deserialize(buffer, node.adblock = {}, FREQUENT_AGENTS_DESERIALIZATION_MAP);
                    if (node.adblock) {
                        node.syntax = getAdblockSyntax(node.adblock.value);
                    }
                    break;
                case AgentNodeSerializationMap.Version:
                    ValueParser.deserialize(buffer, node.version = {});
                    break;
                case AgentNodeSerializationMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case AgentNodeSerializationMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
}

/**
 * @file Cosmetic rule separator finder and categorizer
 */
/**
 * Utility class for cosmetic rule separators.
 */
class CosmeticRuleSeparatorUtils {
    /**
     * Checks whether the specified separator is an exception.
     *
     * @param separator Separator to check
     * @returns `true` if the separator is an exception, `false` otherwise
     */
    static isException(separator) {
        // Simply check the second character
        return separator[1] === AT_SIGN;
    }
    /**
     * Checks whether the specified separator is marks an Extended CSS cosmetic rule.
     *
     * @param separator Separator to check
     * @returns `true` if the separator is marks an Extended CSS cosmetic rule, `false` otherwise
     */
    static isExtendedCssMarker(separator) {
        return (separator === CosmeticRuleSeparator.ExtendedElementHiding
            || separator === CosmeticRuleSeparator.ExtendedElementHidingException
            || separator === CosmeticRuleSeparator.AdgExtendedCssInjection
            || separator === CosmeticRuleSeparator.AdgExtendedCssInjectionException);
    }
    /**
     * Looks for the cosmetic rule separator in the rule. This is a simplified version that
     * masks the recursive function.
     *
     * @param rule Raw rule
     * @returns Separator result or null if no separator was found
     */
    static find(rule) {
        /**
         * Helper function to create results of the `find` method.
         *
         * @param start Start position
         * @param separator Separator type
         * @returns Cosmetic rule separator node
         */
        // eslint-disable-next-line max-len
        function createResult(start, separator) {
            return {
                separator,
                start,
                end: start + separator.length,
            };
        }
        for (let i = 0; i < rule.length; i += 1) {
            if (rule[i] === '#') {
                if (rule[i + 1] === '#' && rule[i - 1] !== SPACE) {
                    // ##
                    return createResult(i, CosmeticRuleSeparator.ElementHiding);
                }
                if (rule[i + 1] === '?' && rule[i + 2] === '#') {
                    // #?#
                    return createResult(i, CosmeticRuleSeparator.ExtendedElementHiding);
                }
                if (rule[i + 1] === '%' && rule[i + 2] === '#') {
                    // #%#
                    return createResult(i, CosmeticRuleSeparator.AdgJsInjection);
                }
                if (rule[i + 1] === '$') {
                    if (rule[i + 2] === '#') {
                        // #$#
                        return createResult(i, CosmeticRuleSeparator.AdgCssInjection);
                    }
                    if (rule[i + 2] === '?' && rule[i + 3] === '#') {
                        // #$?#
                        return createResult(i, CosmeticRuleSeparator.AdgExtendedCssInjection);
                    }
                }
                // Exceptions
                if (rule[i + 1] === '@') {
                    if (rule[i + 2] === '#' && rule[i - 1] !== SPACE) {
                        // #@#
                        return createResult(i, CosmeticRuleSeparator.ElementHidingException);
                    }
                    if (rule[i + 2] === '?' && rule[i + 3] === '#') {
                        // #@?#
                        return createResult(i, CosmeticRuleSeparator.ExtendedElementHidingException);
                    }
                    if (rule[i + 2] === '%' && rule[i + 3] === '#') {
                        // #@%#
                        return createResult(i, CosmeticRuleSeparator.AdgJsInjectionException);
                    }
                    if (rule[i + 2] === '$') {
                        if (rule[i + 3] === '#') {
                            // #@$#
                            return createResult(i, CosmeticRuleSeparator.AdgCssInjectionException);
                        }
                        if (rule[i + 3] === '?' && rule[i + 4] === '#') {
                            // #@$?#
                            return createResult(i, CosmeticRuleSeparator.AdgExtendedCssInjectionException);
                        }
                    }
                }
            }
            if (rule[i] === '$') {
                if (rule[i + 1] === '$') {
                    // $$
                    return createResult(i, CosmeticRuleSeparator.AdgHtmlFiltering);
                }
                if (rule[i + 1] === '@' && rule[i + 2] === '$') {
                    // $@$
                    return createResult(i, CosmeticRuleSeparator.AdgHtmlFilteringException);
                }
            }
        }
        return null;
    }
}

/* eslint-disable no-param-reassign */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
var AgentRuleSerializationMap;
(function (AgentRuleSerializationMap) {
    AgentRuleSerializationMap[AgentRuleSerializationMap["Children"] = 1] = "Children";
    AgentRuleSerializationMap[AgentRuleSerializationMap["Start"] = 2] = "Start";
    AgentRuleSerializationMap[AgentRuleSerializationMap["End"] = 3] = "End";
})(AgentRuleSerializationMap || (AgentRuleSerializationMap = {}));
/**
 * `AgentParser` is responsible for parsing an Adblock agent rules.
 * Adblock agent comment marks that the filter list is supposed to
 * be used by the specified ad blockers.
 *
 * @example
 *  - ```adblock
 *    [AdGuard]
 *    ```
 *  - ```adblock
 *    [Adblock Plus 2.0]
 *    ```
 *  - ```adblock
 *    [uBlock Origin]
 *    ```
 *  - ```adblock
 *    [uBlock Origin 1.45.3]
 *    ```
 *  - ```adblock
 *    [Adblock Plus 2.0; AdGuard]
 *    ```
 */
class AgentCommentRuleParser extends ParserBase {
    /**
     * Checks if the raw rule is an adblock agent comment.
     *
     * @param raw Raw rule
     * @returns `true` if the rule is an adblock agent, `false` otherwise
     */
    static isAgentRule(raw) {
        const rawTrimmed = raw.trim();
        if (rawTrimmed.startsWith(OPEN_SQUARE_BRACKET) && rawTrimmed.endsWith(CLOSE_SQUARE_BRACKET)) {
            // Avoid this case: [$adg-modifier]##[class^="adg-"]
            return isNull(CosmeticRuleSeparatorUtils.find(rawTrimmed));
        }
        return false;
    }
    /**
     * Parses a raw rule as an adblock agent comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Agent rule AST or null (if the raw rule cannot be parsed as an adblock agent comment)
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0) {
        // Ignore non-agent rules
        if (!AgentCommentRuleParser.isAgentRule(raw)) {
            return null;
        }
        let offset = 0;
        // Skip whitespace characters before the rule
        offset = StringUtils.skipWS(raw, offset);
        // Skip opening bracket
        offset += 1;
        // last character should be a closing bracket
        const closingBracketIndex = StringUtils.skipWSBack(raw, raw.length - 1);
        if (closingBracketIndex === -1 || raw[closingBracketIndex] !== CLOSE_SQUARE_BRACKET) {
            throw new AdblockSyntaxError('Missing closing bracket', offset, offset + raw.length);
        }
        // Initialize the agent list
        const result = {
            type: CommentRuleType.AgentCommentRule,
            syntax: AdblockSyntax.Common,
            category: RuleCategory.Comment,
            children: [],
        };
        if (options.includeRaws) {
            result.raws = {
                text: raw,
            };
        }
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        while (offset < closingBracketIndex) {
            // Skip whitespace characters before the agent
            offset = StringUtils.skipWS(raw, offset);
            // Find the separator or the closing bracket
            let separatorIndex = raw.indexOf(SEMICOLON, offset);
            if (separatorIndex === -1) {
                separatorIndex = closingBracketIndex;
            }
            // Find the last non-whitespace character of the agent
            // [AdGuard  ; Adblock Plus 2.0]
            //        ^
            // (if we have spaces between the agent name and the separator)
            const agentEndIndex = StringUtils.findLastNonWhitespaceCharacter(raw.slice(offset, separatorIndex)) + offset + 1;
            // Collect the agent
            result.children.push(AgentParser.parse(raw.slice(offset, agentEndIndex), options, baseOffset + offset));
            // Set the offset to the next agent or the end of the rule
            offset = separatorIndex + 1;
        }
        if (result.children.length === 0) {
            throw new AdblockSyntaxError('Empty agent list', baseOffset, baseOffset + raw.length);
        }
        return result;
    }
    /**
     * Converts an adblock agent AST to a string.
     *
     * @param ast Agent rule AST
     * @returns Raw string
     */
    static generate(ast) {
        let result = OPEN_SQUARE_BRACKET;
        result += ast.children
            .map(AgentParser.generate)
            .join(SEMICOLON + SPACE);
        result += CLOSE_SQUARE_BRACKET;
        return result;
    }
    /**
     * Serializes an adblock agent list node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    // TODO: add support for raws, if ever needed
    static serialize(node, buffer) {
        buffer.writeUint8(BinaryTypeMap.AgentRuleNode);
        const count = node.children.length;
        if (count) {
            buffer.writeUint8(AgentRuleSerializationMap.Children);
            // note: we store the count, because re-construction of the array is faster if we know the length
            // 8 bits is more than enough here
            if (count > UINT8_MAX) {
                throw new Error(`Too many children: ${count}, the limit is ${UINT8_MAX}`);
            }
            buffer.writeUint8(count);
            for (let i = 0; i < count; i += 1) {
                AgentParser.serialize(node.children[i], buffer);
            }
        }
        if (!isUndefined(node.start)) {
            buffer.writeUint8(AgentRuleSerializationMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(AgentRuleSerializationMap.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Deserializes an agent list node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(BinaryTypeMap.AgentRuleNode);
        node.type = CommentRuleType.AgentCommentRule;
        node.syntax = AdblockSyntax.Common;
        node.category = RuleCategory.Comment;
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case AgentRuleSerializationMap.Children:
                    node.children = new Array(buffer.readUint8());
                    // read children
                    for (let i = 0; i < node.children.length; i += 1) {
                        AgentParser.deserialize(buffer, node.children[i] = {});
                    }
                    break;
                case AgentRuleSerializationMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case AgentRuleSerializationMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
}

/* eslint-disable no-param-reassign */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
var ParameterListNodeSerializationMap;
(function (ParameterListNodeSerializationMap) {
    ParameterListNodeSerializationMap[ParameterListNodeSerializationMap["Children"] = 1] = "Children";
    ParameterListNodeSerializationMap[ParameterListNodeSerializationMap["Start"] = 2] = "Start";
    ParameterListNodeSerializationMap[ParameterListNodeSerializationMap["End"] = 3] = "End";
})(ParameterListNodeSerializationMap || (ParameterListNodeSerializationMap = {}));
class ParameterListParser extends ParserBase {
    /**
     * Parses a raw parameter list.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @param separator Separator character (default: comma)
     * @returns Parameter list AST
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0, separator = COMMA) {
        // Prepare the parameter list node
        const params = {
            type: 'ParameterList',
            children: [],
        };
        const { length } = raw;
        if (options.isLocIncluded) {
            params.start = baseOffset;
            params.end = baseOffset + length;
        }
        let offset = 0;
        // Parse parameters: skip whitespace before and after each parameter, and
        // split parameters by the separator character.
        while (offset < length) {
            // Skip whitespace before parameter
            offset = StringUtils.skipWS(raw, offset);
            // Parameter may only contain whitespace
            // In this case, we reached the end of the parameter list
            if (raw[offset] === separator || offset === length) {
                // Add a null for empty parameter
                params.children.push(null);
                // Skip separator
                offset += 1;
            }
            else {
                // Get parameter start position
                const paramStart = offset;
                // Get next unescaped separator position
                const nextSeparator = StringUtils.findUnescapedNonStringNonRegexChar(raw, separator, offset);
                // Get parameter end position
                const paramEnd = nextSeparator !== -1
                    ? StringUtils.skipWSBack(raw, nextSeparator - 1)
                    : StringUtils.skipWSBack(raw);
                // Add parameter to the list
                const param = ValueParser.parse(raw.slice(paramStart, paramEnd + 1), options, baseOffset + paramStart);
                params.children.push(param);
                // Set offset to the next separator position + 1
                offset = nextSeparator !== -1 ? nextSeparator + 1 : length;
            }
        }
        // If the last character was a separator, add an additional null parameter
        if (raw[length - 1] === separator) {
            params.children.push(null);
        }
        return params;
    }
    /**
     * Converts a parameter list AST to a string.
     *
     * @param params Parameter list AST
     * @param separator Separator character (default: comma)
     * @returns String representation of the parameter list
     */
    static generate(params, separator = COMMA) {
        const collection = [];
        // add parameters
        let i = 0;
        for (; i < params.children.length; i += 1) {
            const param = params.children[i];
            if (param === null) {
                collection.push(EMPTY);
            }
            else {
                collection.push(ValueParser.generate(param));
            }
        }
        // join parameters with separator
        // if the separator is a space, join with a single space
        const result = collection.join(separator === SPACE ? separator : `${separator}${SPACE}`);
        return result;
    }
    /**
     * Serializes a parameter list node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     * @param frequentValuesMap Optional map of frequent values.
     * @param toLower Whether to lowercase the value before the frequent value match (defaults to `false`).
     */
    static serialize(node, buffer, frequentValuesMap, toLower = false) {
        buffer.writeUint8(BinaryTypeMap.ParameterListNode);
        const count = node.children.length;
        buffer.writeUint8(ParameterListNodeSerializationMap.Children);
        // note: we store the count, because re-construction of the array is faster if we know the length
        buffer.writeUint32(count);
        for (let i = 0; i < count; i += 1) {
            const child = node.children[i];
            if (isNull(child)) {
                buffer.writeUint8(BinaryTypeMap.Null);
                continue;
            }
            ValueParser.serialize(child, buffer, frequentValuesMap, toLower);
        }
        if (!isUndefined(node.start)) {
            buffer.writeUint8(ParameterListNodeSerializationMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(ParameterListNodeSerializationMap.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Deserializes a parameter list node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @param frequentValuesMap Optional map of frequent values.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node, frequentValuesMap) {
        buffer.assertUint8(BinaryTypeMap.ParameterListNode);
        node.type = 'ParameterList';
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case ParameterListNodeSerializationMap.Children:
                    node.children = new Array(buffer.readUint32());
                    // read children
                    for (let i = 0; i < node.children.length; i += 1) {
                        switch (buffer.peekUint8()) {
                            case BinaryTypeMap.Null:
                                buffer.readUint8();
                                node.children[i] = null;
                                break;
                            case BinaryTypeMap.ValueNode:
                                ValueParser.deserialize(buffer, node.children[i] = {}, frequentValuesMap);
                                break;
                            default:
                                throw new Error(`Invalid child type: ${buffer.peekUint8()}`);
                        }
                    }
                    break;
                case ParameterListNodeSerializationMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case ParameterListNodeSerializationMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
}

/* eslint-disable no-param-reassign */
/**
 * @file AGLint configuration comments. Inspired by ESLint inline configuration comments.
 * @see {@link https://eslint.org/docs/latest/user-guide/configuring/rules#using-configuration-comments}
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
var ConfigCommentRuleSerializationMap;
(function (ConfigCommentRuleSerializationMap) {
    ConfigCommentRuleSerializationMap[ConfigCommentRuleSerializationMap["Marker"] = 1] = "Marker";
    ConfigCommentRuleSerializationMap[ConfigCommentRuleSerializationMap["Command"] = 2] = "Command";
    ConfigCommentRuleSerializationMap[ConfigCommentRuleSerializationMap["Params"] = 3] = "Params";
    ConfigCommentRuleSerializationMap[ConfigCommentRuleSerializationMap["Comment"] = 4] = "Comment";
    ConfigCommentRuleSerializationMap[ConfigCommentRuleSerializationMap["Start"] = 5] = "Start";
    ConfigCommentRuleSerializationMap[ConfigCommentRuleSerializationMap["End"] = 6] = "End";
})(ConfigCommentRuleSerializationMap || (ConfigCommentRuleSerializationMap = {}));
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
var ConfigNodeSerializationMap;
(function (ConfigNodeSerializationMap) {
    ConfigNodeSerializationMap[ConfigNodeSerializationMap["Value"] = 1] = "Value";
    ConfigNodeSerializationMap[ConfigNodeSerializationMap["Start"] = 2] = "Start";
    ConfigNodeSerializationMap[ConfigNodeSerializationMap["End"] = 3] = "End";
})(ConfigNodeSerializationMap || (ConfigNodeSerializationMap = {}));
/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 *
 * @see {@link https://github.com/AdguardTeam/AGLint/blob/master/src/linter/inline-config.ts}
 */
const FREQUENT_COMMANDS_SERIALIZATION_MAP = new Map([
    ['aglint', 0],
    ['aglint-disable', 1],
    ['aglint-enable', 2],
    ['aglint-disable-next-line', 3],
    ['aglint-enable-next-line', 4],
]);
/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
const FREQUENT_COMMANDS_DESERIALIZATION_MAP = new Map(Array.from(FREQUENT_COMMANDS_SERIALIZATION_MAP).map(([key, value]) => [value, key]));
/**
 * `ConfigCommentParser` is responsible for parsing inline AGLint configuration rules.
 * Generally, the idea is inspired by ESLint inline configuration comments.
 *
 * @see {@link https://eslint.org/docs/latest/user-guide/configuring/rules#using-configuration-comments}
 */
class ConfigCommentRuleParser extends ParserBase {
    /**
     * Checks if the raw rule is an inline configuration comment rule.
     *
     * @param raw Raw rule
     * @returns `true` if the rule is an inline configuration comment rule, otherwise `false`.
     */
    static isConfigComment(raw) {
        const trimmed = raw.trim();
        if (trimmed[0] === CommentMarker.Regular || trimmed[0] === CommentMarker.Hashmark) {
            // Skip comment marker and trim comment text (it is necessary because of "!     something")
            const text = raw.slice(1).trim();
            // The code below is "not pretty", but it runs fast, which is necessary, since it will run on EVERY comment
            // The essence of the indicator is that the control comment always starts with the "aglint" prefix
            return ((text[0] === 'a' || text[0] === 'A')
                && (text[1] === 'g' || text[1] === 'G')
                && (text[2] === 'l' || text[2] === 'L')
                && (text[3] === 'i' || text[3] === 'I')
                && (text[4] === 'n' || text[4] === 'N')
                && (text[5] === 't' || text[5] === 'T'));
        }
        return false;
    }
    /**
     * Parses a raw rule as an inline configuration comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns
     * Inline configuration comment AST or null (if the raw rule cannot be parsed as configuration comment)
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0) {
        if (!ConfigCommentRuleParser.isConfigComment(raw)) {
            return null;
        }
        let offset = 0;
        // Skip leading whitespace (if any)
        offset = StringUtils.skipWS(raw, offset);
        // Get comment marker
        const marker = ValueParser.parse(raw[offset], options, baseOffset + offset);
        // Skip marker
        offset += 1;
        // Skip whitespace (if any)
        offset = StringUtils.skipWS(raw, offset);
        // Save the command start position
        const commandStart = offset;
        // Get comment text, for example: "aglint-disable-next-line"
        offset = StringUtils.findNextWhitespaceCharacter(raw, offset);
        const command = ValueParser.parse(raw.slice(commandStart, offset), options, baseOffset + commandStart);
        // Skip whitespace after command
        offset = StringUtils.skipWS(raw, offset);
        // Get comment (if any)
        const commentStart = raw.indexOf(AGLINT_CONFIG_COMMENT_MARKER, offset);
        const commentEnd = commentStart !== -1 ? StringUtils.skipWSBack(raw) + 1 : -1;
        let comment;
        // Check if there is a comment
        if (commentStart !== -1) {
            comment = ValueParser.parse(raw.slice(commentStart, commentEnd), options, baseOffset + commentStart);
        }
        // Get parameter
        const paramsStart = offset;
        const paramsEnd = commentStart !== -1
            ? StringUtils.skipWSBack(raw, commentStart - 1) + 1
            : StringUtils.skipWSBack(raw) + 1;
        let params;
        // `! aglint ...` config comment
        if (command.value === AGLINT_COMMAND_PREFIX) {
            params = {
                type: 'ConfigNode',
                // It is necessary to use JSON5.parse instead of JSON.parse because JSON5 allows unquoted keys.
                // But don't forget to add { } to the beginning and end of the string,
                // otherwise JSON5 will not be able to parse it.
                // TODO: Better solution? ESLint uses "levn" package for parsing these comments.
                value: JSON5.parse(`{${raw.slice(paramsStart, paramsEnd)}}`),
            };
            if (options.isLocIncluded) {
                params.start = paramsStart;
                params.end = paramsEnd;
            }
            // Throw error for empty config
            if (Object.keys(params.value).length === 0) {
                throw new Error('Empty AGLint config');
            }
        }
        else if (paramsStart < paramsEnd) {
            params = ParameterListParser.parse(raw.slice(paramsStart, paramsEnd), options, baseOffset + paramsStart, COMMA);
        }
        const result = {
            type: CommentRuleType.ConfigCommentRule,
            category: RuleCategory.Comment,
            syntax: AdblockSyntax.Common,
            marker,
            command,
            params,
            comment,
        };
        if (options.includeRaws) {
            result.raws = {
                text: raw,
            };
        }
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        return result;
    }
    /**
     * Converts an inline configuration comment node to a string.
     *
     * @param node Inline configuration comment node
     * @returns Raw string
     */
    static generate(node) {
        let result = EMPTY;
        result += node.marker.value;
        result += SPACE;
        result += node.command.value;
        if (node.params) {
            result += SPACE;
            if (node.params.type === 'ParameterList') {
                result += ParameterListParser.generate(node.params, COMMA);
            }
            else {
                // Trim JSON boundaries
                result += JSON.stringify(node.params.value).slice(1, -1).trim();
            }
        }
        // Add comment within the config comment
        if (node.comment) {
            result += SPACE;
            result += node.comment.value;
        }
        return result;
    }
    /**
     * Serializes a config node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serializeConfigNode(node, buffer) {
        buffer.writeUint8(BinaryTypeMap.ConfigNode);
        buffer.writeUint8(ConfigNodeSerializationMap.Value);
        // note: we don't support serializing generic objects, only AGTree nodes
        // this is a very special case, so we just stringify the configuration object
        buffer.writeString(JSON.stringify(node.value));
        if (!isUndefined(node.start)) {
            buffer.writeUint8(ConfigNodeSerializationMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(ConfigNodeSerializationMap.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Deserializes a metadata comment node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserializeConfigNode(buffer, node) {
        buffer.assertUint8(BinaryTypeMap.ConfigNode);
        node.type = 'ConfigNode';
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case ConfigNodeSerializationMap.Value:
                    // note: it is safe to use JSON.parse here, because we serialized it with JSON.stringify
                    node.value = JSON.parse(buffer.readString());
                    break;
                case ConfigNodeSerializationMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case ConfigNodeSerializationMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}.`);
            }
            prop = buffer.readUint8();
        }
    }
    /**
     * Serializes a metadata comment node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    // TODO: add support for raws, if ever needed
    static serialize(node, buffer) {
        buffer.writeUint8(BinaryTypeMap.ConfigCommentRuleNode);
        buffer.writeUint8(ConfigCommentRuleSerializationMap.Marker);
        ValueParser.serialize(node.marker, buffer);
        buffer.writeUint8(ConfigCommentRuleSerializationMap.Command);
        ValueParser.serialize(node.command, buffer, FREQUENT_COMMANDS_SERIALIZATION_MAP, true);
        if (!isUndefined(node.params)) {
            buffer.writeUint8(ConfigCommentRuleSerializationMap.Params);
            if (node.params.type === 'ParameterList') {
                ParameterListParser.serialize(node.params, buffer);
            }
            else {
                ConfigCommentRuleParser.serializeConfigNode(node.params, buffer);
            }
        }
        if (!isUndefined(node.comment)) {
            buffer.writeUint8(ConfigCommentRuleSerializationMap.Comment);
            ValueParser.serialize(node.comment, buffer);
        }
        if (!isUndefined(node.start)) {
            buffer.writeUint8(ConfigCommentRuleSerializationMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(ConfigCommentRuleSerializationMap.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Deserializes a metadata comment node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(BinaryTypeMap.ConfigCommentRuleNode);
        node.type = CommentRuleType.ConfigCommentRule;
        node.category = RuleCategory.Comment;
        node.syntax = AdblockSyntax.Common;
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case ConfigCommentRuleSerializationMap.Marker:
                    ValueParser.deserialize(buffer, node.marker = {});
                    break;
                case ConfigCommentRuleSerializationMap.Command:
                    ValueParser.deserialize(buffer, node.command = {}, FREQUENT_COMMANDS_DESERIALIZATION_MAP);
                    break;
                case ConfigCommentRuleSerializationMap.Params:
                    if (buffer.peekUint8() === BinaryTypeMap.ConfigNode) {
                        ConfigCommentRuleParser.deserializeConfigNode(buffer, node.params = {});
                    }
                    else {
                        ParameterListParser.deserialize(buffer, node.params = {});
                    }
                    break;
                case ConfigCommentRuleSerializationMap.Comment:
                    ValueParser.deserialize(buffer, node.comment = {});
                    break;
                case ConfigCommentRuleSerializationMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case ConfigCommentRuleSerializationMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
}

/* eslint-disable no-param-reassign */
/**
 * @file AdGuard Hints
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#hints}
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
var HintNodeSerializationMap;
(function (HintNodeSerializationMap) {
    HintNodeSerializationMap[HintNodeSerializationMap["Name"] = 1] = "Name";
    HintNodeSerializationMap[HintNodeSerializationMap["Params"] = 2] = "Params";
    HintNodeSerializationMap[HintNodeSerializationMap["Start"] = 3] = "Start";
    HintNodeSerializationMap[HintNodeSerializationMap["End"] = 4] = "End";
})(HintNodeSerializationMap || (HintNodeSerializationMap = {}));
/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const FREQUENT_HINTS_SERIALIZATION_MAP = new Map([
    ['NOT_OPTIMIZED', 0],
    ['PLATFORM', 1],
    ['NOT_PLATFORM', 2],
]);
/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
const FREQUENT_HINTS_DESERIALIZATION_MAP = new Map(Array.from(FREQUENT_HINTS_SERIALIZATION_MAP).map(([key, value]) => [value, key]));
/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const FREQUENT_PLATFORMS_SERIALIZATION_MAP = new Map([
    ['windows', 0],
    ['mac', 1],
    ['android', 2],
    ['ios', 3],
    ['ext_chromium', 4],
    ['ext_ff', 5],
    ['ext_edge', 6],
    ['ext_opera', 7],
    ['ext_safari', 8],
    ['ext_android_cb', 9],
    ['ext_ublock', 10],
]);
/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
const FREQUENT_PLATFORMS_DESERIALIZATION_MAP = new Map(Array.from(FREQUENT_PLATFORMS_SERIALIZATION_MAP).map(([key, value]) => [value, key]));
/**
 * `HintParser` is responsible for parsing AdGuard hints.
 *
 * @example
 * If the hint rule is
 * ```adblock
 * !+ NOT_OPTIMIZED PLATFORM(windows)
 * ```
 * then the hints are `NOT_OPTIMIZED` and `PLATFORM(windows)`, and this
 * class is responsible for parsing them. The rule itself is parsed by
 * the `HintRuleParser`, which uses this class to parse single hints.
 */
class HintParser extends ParserBase {
    /**
     * Parses a raw rule as a hint.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Hint rule AST or null
     * @throws If the syntax is invalid
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0) {
        let offset = 0;
        // Skip whitespace characters before the hint
        offset = StringUtils.skipWS(raw);
        // Hint should start with the hint name in every case
        // Save the start offset of the hint name
        const nameStartIndex = offset;
        // Parse the hint name
        for (; offset < raw.length; offset += 1) {
            const char = raw[offset];
            // Abort consuming the hint name if we encounter a whitespace character
            // or an opening parenthesis, which means 'HIT_NAME(' case
            if (char === OPEN_PARENTHESIS || char === SPACE) {
                break;
            }
            // Hint name should only contain letters, digits, and underscores
            if (!StringUtils.isAlphaNumeric(char) && char !== UNDERSCORE) {
                throw new AdblockSyntaxError(`Invalid character "${char}" in hint name: "${char}"`, baseOffset + nameStartIndex, baseOffset + offset);
            }
        }
        // Save the end offset of the hint name
        const nameEndIndex = offset;
        // Save the hint name token
        const name = raw.slice(nameStartIndex, nameEndIndex);
        // Hint name cannot be empty
        if (name === EMPTY) {
            throw new AdblockSyntaxError('Empty hint name', baseOffset, baseOffset + nameEndIndex);
        }
        // Now we have two case:
        //  1. We have HINT_NAME and should return it
        //  2. We have HINT_NAME(PARAMS) and should continue parsing
        // Skip whitespace characters after the hint name
        offset = StringUtils.skipWS(raw, offset);
        // Throw error for 'HINT_NAME (' case
        if (offset > nameEndIndex && raw[offset] === OPEN_PARENTHESIS) {
            throw new AdblockSyntaxError('Unexpected whitespace(s) between hint name and opening parenthesis', baseOffset + nameEndIndex, baseOffset + offset);
        }
        // Create the hint name node (we can reuse it in the 'HINT_NAME' case, if needed)
        const nameNode = ValueParser.parse(name, options, baseOffset + nameStartIndex);
        // Just return the hint name if we have 'HINT_NAME' case (no params)
        if (raw[offset] !== OPEN_PARENTHESIS) {
            const result = {
                type: 'Hint',
                name: nameNode,
            };
            if (options.isLocIncluded) {
                result.start = baseOffset;
                result.end = baseOffset + offset;
            }
            return result;
        }
        // Skip the opening parenthesis
        offset += 1;
        // Find closing parenthesis
        const closeParenthesisIndex = raw.lastIndexOf(CLOSE_PARENTHESIS);
        // Throw error if we don't have closing parenthesis
        if (closeParenthesisIndex === -1) {
            throw new AdblockSyntaxError(`Missing closing parenthesis for hint "${name}"`, baseOffset + nameStartIndex, baseOffset + raw.length);
        }
        // Save the start and end index of the params
        const paramsStartIndex = offset;
        const paramsEndIndex = closeParenthesisIndex;
        // Parse the params
        const params = ParameterListParser.parse(raw.slice(paramsStartIndex, paramsEndIndex), options, baseOffset + paramsStartIndex, COMMA);
        offset = closeParenthesisIndex + 1;
        // Skip whitespace characters after the closing parenthesis
        offset = StringUtils.skipWS(raw, offset);
        // Throw error if we don't reach the end of the input
        if (offset !== raw.length) {
            throw new AdblockSyntaxError(
            // eslint-disable-next-line max-len
            `Unexpected input after closing parenthesis for hint "${name}": "${raw.slice(closeParenthesisIndex + 1, offset + 1)}"`, baseOffset + closeParenthesisIndex + 1, baseOffset + offset + 1);
        }
        // Return the HINT_NAME(PARAMS) case AST
        const result = {
            type: 'Hint',
            name: nameNode,
            params,
        };
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + offset;
        }
        return result;
    }
    /**
     * Converts a single hint AST to a string.
     *
     * @param hint Hint AST
     * @returns Hint string
     */
    static generate(hint) {
        let result = EMPTY;
        result += hint.name.value;
        if (hint.params && hint.params.children.length > 0) {
            result += OPEN_PARENTHESIS;
            result += ParameterListParser.generate(hint.params, COMMA);
            result += CLOSE_PARENTHESIS;
        }
        return result;
    }
    /**
     * Serializes a hint node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node, buffer) {
        buffer.writeUint8(BinaryTypeMap.HintNode);
        buffer.writeUint8(HintNodeSerializationMap.Name);
        ValueParser.serialize(node.name, buffer, FREQUENT_HINTS_SERIALIZATION_MAP);
        if (!isUndefined(node.params)) {
            buffer.writeUint8(HintNodeSerializationMap.Params);
            ParameterListParser.serialize(node.params, buffer, FREQUENT_PLATFORMS_SERIALIZATION_MAP);
        }
        if (!isUndefined(node.start)) {
            buffer.writeUint8(HintNodeSerializationMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(HintNodeSerializationMap.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Deserializes a hint node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(BinaryTypeMap.HintNode);
        node.type = 'Hint';
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case HintNodeSerializationMap.Name:
                    ValueParser.deserialize(buffer, node.name = {}, FREQUENT_HINTS_DESERIALIZATION_MAP);
                    break;
                case HintNodeSerializationMap.Params:
                    // eslint-disable-next-line max-len
                    ParameterListParser.deserialize(buffer, node.params = {}, FREQUENT_PLATFORMS_DESERIALIZATION_MAP);
                    break;
                case HintNodeSerializationMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case HintNodeSerializationMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
}

/* eslint-disable no-param-reassign */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
var HintRuleSerializationMap;
(function (HintRuleSerializationMap) {
    HintRuleSerializationMap[HintRuleSerializationMap["Syntax"] = 1] = "Syntax";
    HintRuleSerializationMap[HintRuleSerializationMap["Children"] = 2] = "Children";
    HintRuleSerializationMap[HintRuleSerializationMap["Start"] = 3] = "Start";
    HintRuleSerializationMap[HintRuleSerializationMap["End"] = 4] = "End";
})(HintRuleSerializationMap || (HintRuleSerializationMap = {}));
/**
 * `HintRuleParser` is responsible for parsing AdGuard hint rules.
 *
 * @example
 * The following hint rule
 * ```adblock
 * !+ NOT_OPTIMIZED PLATFORM(windows)
 * ```
 * contains two hints: `NOT_OPTIMIZED` and `PLATFORM`.
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#hints}
 */
class HintCommentRuleParser extends ParserBase {
    /**
     * Checks if the raw rule is a hint rule.
     *
     * @param raw Raw rule
     * @returns `true` if the rule is a hint rule, `false` otherwise
     */
    static isHintRule(raw) {
        return raw.trim().startsWith(HINT_MARKER);
    }
    /**
     * Parses a raw rule as a hint comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Hint AST or null (if the raw rule cannot be parsed as a hint comment)
     * @throws If the input matches the HINT pattern but syntactically invalid
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#hints-1}
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0) {
        // Ignore non-hint rules
        if (!HintCommentRuleParser.isHintRule(raw)) {
            return null;
        }
        let offset = 0;
        // Skip whitespace characters before the rule
        offset = StringUtils.skipWS(raw);
        // Skip hint marker
        offset += HINT_MARKER_LEN;
        const hints = [];
        // Collect hints. Each hint is a string, optionally followed by a parameter list,
        // enclosed in parentheses. One rule can contain multiple hints.
        while (offset < raw.length) {
            // Split rule into raw hints (e.g. 'HINT_NAME' or 'HINT_NAME(PARAMS)')
            // Hints are separated by whitespace characters, but we should ignore
            // whitespace characters inside the parameter list
            // Ignore whitespace characters before the hint
            offset = StringUtils.skipWS(raw, offset);
            // Save the start index of the hint
            const hintStartIndex = offset;
            // Find the end of the hint
            let hintEndIndex = offset;
            let balance = 0;
            while (hintEndIndex < raw.length) {
                if (raw[hintEndIndex] === OPEN_PARENTHESIS && raw[hintEndIndex - 1] !== BACKSLASH) {
                    balance += 1;
                    // Throw error for nesting
                    if (balance > 1) {
                        throw new AdblockSyntaxError('Invalid hint: nested parentheses are not allowed', baseOffset + hintStartIndex, baseOffset + hintEndIndex);
                    }
                }
                else if (raw[hintEndIndex] === CLOSE_PARENTHESIS && raw[hintEndIndex - 1] !== BACKSLASH) {
                    balance -= 1;
                }
                else if (StringUtils.isWhitespace(raw[hintEndIndex]) && balance === 0) {
                    break;
                }
                hintEndIndex += 1;
            }
            offset = hintEndIndex;
            // Skip whitespace characters after the hint
            offset = StringUtils.skipWS(raw, offset);
            // Parse the hint
            const hint = HintParser.parse(raw.slice(hintStartIndex, hintEndIndex), options, baseOffset + hintStartIndex);
            hints.push(hint);
        }
        // Throw error if no hints were found
        if (hints.length === 0) {
            throw new AdblockSyntaxError('Empty hint rule', baseOffset, baseOffset + offset);
        }
        const result = {
            type: CommentRuleType.HintCommentRule,
            category: RuleCategory.Comment,
            syntax: AdblockSyntax.Adg,
            children: hints,
        };
        if (options.includeRaws) {
            result.raws = {
                text: raw,
            };
        }
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + offset;
        }
        return result;
    }
    /**
     * Converts a hint rule node to a raw string.
     *
     * @param node Hint rule node
     * @returns Raw string
     */
    static generate(node) {
        let result = HINT_MARKER + SPACE;
        result += node.children.map(HintParser.generate).join(SPACE);
        return result;
    }
    /**
     * Serializes a hint rule node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    // TODO: add support for raws, if ever needed
    static serialize(node, buffer) {
        buffer.writeUint8(BinaryTypeMap.HintRuleNode);
        if (node.syntax === AdblockSyntax.Adg) {
            buffer.writeUint8(HintRuleSerializationMap.Syntax);
            buffer.writeUint8(SYNTAX_SERIALIZATION_MAP.get(AdblockSyntax.Adg) ?? 0);
        }
        const count = node.children.length;
        if (count) {
            buffer.writeUint8(HintRuleSerializationMap.Children);
            // note: we store the count, because re-construction of the array is faster if we know the length
            buffer.writeUint8(count);
            for (let i = 0; i < count; i += 1) {
                HintParser.serialize(node.children[i], buffer);
            }
        }
        if (!isUndefined(node.start)) {
            buffer.writeUint8(HintRuleSerializationMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(HintRuleSerializationMap.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Deserializes a hint rule node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(BinaryTypeMap.HintRuleNode);
        node.category = RuleCategory.Comment;
        node.type = CommentRuleType.HintCommentRule;
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case HintRuleSerializationMap.Syntax:
                    node.syntax = SYNTAX_DESERIALIZATION_MAP.get(buffer.readUint8()) ?? AdblockSyntax.Common;
                    break;
                case HintRuleSerializationMap.Children:
                    node.children = new Array(buffer.readUint8());
                    // read children
                    for (let i = 0; i < node.children.length; i += 1) {
                        HintParser.deserialize(buffer, node.children[i] = {});
                    }
                    break;
                case HintRuleSerializationMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case HintRuleSerializationMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
}

/* eslint-disable no-param-reassign */
/**
 * @file Metadata comments
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
var MetadataCommentRuleSerializationMap;
(function (MetadataCommentRuleSerializationMap) {
    MetadataCommentRuleSerializationMap[MetadataCommentRuleSerializationMap["Marker"] = 1] = "Marker";
    MetadataCommentRuleSerializationMap[MetadataCommentRuleSerializationMap["Header"] = 2] = "Header";
    MetadataCommentRuleSerializationMap[MetadataCommentRuleSerializationMap["Value"] = 3] = "Value";
    MetadataCommentRuleSerializationMap[MetadataCommentRuleSerializationMap["Start"] = 4] = "Start";
    MetadataCommentRuleSerializationMap[MetadataCommentRuleSerializationMap["End"] = 5] = "End";
})(MetadataCommentRuleSerializationMap || (MetadataCommentRuleSerializationMap = {}));
/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
const FREQUENT_HEADERS_DESERIALIZATION_MAP = new Map([
    [1, 'Checksum'],
    [2, 'Description'],
    [3, 'Expires'],
    [4, 'Homepage'],
    [5, 'Last Modified'],
    [6, 'LastModified'],
    [7, 'Licence'],
    [8, 'License'],
    [9, 'Time Updated'],
    [10, 'TimeUpdated'],
    [11, 'Version'],
    [12, 'Title'],
]);
/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 * @note This map is generated from `FREQUENT_HEADERS_DESERIALIZATION_MAP` to keep uppercase characters
 * while deserializing.
 */
const FREQUENT_HEADERS_SERIALIZATION_MAP = new Map(Array.from(FREQUENT_HEADERS_DESERIALIZATION_MAP.entries()).map(([key, value]) => [value.toLowerCase(), key]));
/**
 * Known metadata headers.
 */
const KNOWN_METADATA_HEADERS = Array.from(FREQUENT_HEADERS_SERIALIZATION_MAP.keys());
/**
 * `MetadataParser` is responsible for parsing metadata comments.
 * Metadata comments are special comments that specify some properties of the list.
 *
 * @example
 * For example, in the case of
 * ```adblock
 * ! Title: My List
 * ```
 * the name of the header is `Title`, and the value is `My List`, which means that
 * the list title is `My List`, and it can be used in the adblocker UI.
 * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#special-comments}
 */
class MetadataCommentRuleParser extends ParserBase {
    /**
     * Parses a raw rule as a metadata comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Metadata comment AST or null (if the raw rule cannot be parsed as a metadata comment)
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0) {
        // Fast check to avoid unnecessary work
        if (raw.indexOf(COLON) === -1) {
            return null;
        }
        let offset = 0;
        // Skip leading spaces before the comment marker
        offset = StringUtils.skipWS(raw, offset);
        // Check if the rule starts with a comment marker (first non-space sequence)
        if (raw[offset] !== CommentMarker.Regular && raw[offset] !== CommentMarker.Hashmark) {
            return null;
        }
        // Consume the comment marker
        const marker = ValueParser.parse(raw[offset], options, baseOffset + offset);
        offset += 1;
        // Skip spaces
        offset = StringUtils.skipWS(raw, offset);
        // Save header start position
        const headerStart = offset;
        // Check if the comment text starts with a known header
        const text = raw.slice(offset);
        for (let i = 0; i < KNOWN_METADATA_HEADERS.length; i += 1) {
            // Check if the comment text starts with the header (case-insensitive)
            if (text.toLocaleLowerCase().startsWith(KNOWN_METADATA_HEADERS[i].toLocaleLowerCase())) {
                // Skip the header
                offset += KNOWN_METADATA_HEADERS[i].length;
                // Save header
                const header = ValueParser.parse(raw.slice(headerStart, offset), options, baseOffset + headerStart);
                // Skip spaces after the header
                offset = StringUtils.skipWS(raw, offset);
                // Check if the rule contains a separator after the header
                if (raw[offset] !== COLON) {
                    return null;
                }
                // Skip the separator
                offset += 1;
                // Skip spaces after the separator
                offset = StringUtils.skipWS(raw, offset);
                // Save the value start position
                const valueStart = offset;
                // Check if the rule contains a value
                if (offset >= raw.length) {
                    return null;
                }
                const valueEnd = StringUtils.skipWSBack(raw, raw.length - 1) + 1;
                // Save the value
                const value = ValueParser.parse(raw.slice(valueStart, valueEnd), options, baseOffset + valueStart);
                const result = {
                    type: CommentRuleType.MetadataCommentRule,
                    category: RuleCategory.Comment,
                    syntax: AdblockSyntax.Common,
                    marker,
                    header,
                    value,
                };
                if (options.includeRaws) {
                    result.raws = {
                        text: raw,
                    };
                }
                if (options.isLocIncluded) {
                    result.start = baseOffset;
                    result.end = baseOffset + raw.length;
                }
                return result;
            }
        }
        return null;
    }
    /**
     * Converts a metadata comment rule node to a string.
     *
     * @param node Metadata comment rule node.
     * @returns Raw string.
     */
    static generate(node) {
        let result = EMPTY;
        result += ValueParser.generate(node.marker);
        result += SPACE;
        result += ValueParser.generate(node.header);
        result += COLON;
        result += SPACE;
        result += ValueParser.generate(node.value);
        return result;
    }
    /**
     * Serializes a metadata comment node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    // TODO: add support for raws, if ever needed
    static serialize(node, buffer) {
        buffer.writeUint8(BinaryTypeMap.MetadataCommentRuleNode);
        buffer.writeUint8(MetadataCommentRuleSerializationMap.Marker);
        ValueParser.serialize(node.marker, buffer);
        buffer.writeUint8(MetadataCommentRuleSerializationMap.Header);
        ValueParser.serialize(node.header, buffer, FREQUENT_HEADERS_SERIALIZATION_MAP, true);
        buffer.writeUint8(MetadataCommentRuleSerializationMap.Value);
        ValueParser.serialize(node.value, buffer);
        if (!isUndefined(node.start)) {
            buffer.writeUint8(MetadataCommentRuleSerializationMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(MetadataCommentRuleSerializationMap.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Deserializes a metadata comment node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(BinaryTypeMap.MetadataCommentRuleNode);
        node.type = CommentRuleType.MetadataCommentRule;
        node.category = RuleCategory.Comment;
        node.syntax = AdblockSyntax.Common;
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case MetadataCommentRuleSerializationMap.Marker:
                    ValueParser.deserialize(buffer, node.marker = {});
                    break;
                case MetadataCommentRuleSerializationMap.Header:
                    ValueParser.deserialize(buffer, node.header = {}, FREQUENT_HEADERS_DESERIALIZATION_MAP);
                    break;
                case MetadataCommentRuleSerializationMap.Value:
                    ValueParser.deserialize(buffer, node.value = {});
                    break;
                case MetadataCommentRuleSerializationMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case MetadataCommentRuleSerializationMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
}

/* eslint-disable no-param-reassign */
/* eslint-disable max-classes-per-file */
/**
 * Property map for binary serialization.
 */
var VariableNodeBinaryPropMap;
(function (VariableNodeBinaryPropMap) {
    VariableNodeBinaryPropMap[VariableNodeBinaryPropMap["Name"] = 1] = "Name";
    VariableNodeBinaryPropMap[VariableNodeBinaryPropMap["FrequentName"] = 2] = "FrequentName";
    VariableNodeBinaryPropMap[VariableNodeBinaryPropMap["Start"] = 3] = "Start";
    VariableNodeBinaryPropMap[VariableNodeBinaryPropMap["End"] = 4] = "End";
})(VariableNodeBinaryPropMap || (VariableNodeBinaryPropMap = {}));
/**
 * Property map for binary serialization.
 */
var OperatorNodeBinaryPropMap;
(function (OperatorNodeBinaryPropMap) {
    OperatorNodeBinaryPropMap[OperatorNodeBinaryPropMap["Operator"] = 1] = "Operator";
    OperatorNodeBinaryPropMap[OperatorNodeBinaryPropMap["Left"] = 2] = "Left";
    OperatorNodeBinaryPropMap[OperatorNodeBinaryPropMap["Right"] = 3] = "Right";
    OperatorNodeBinaryPropMap[OperatorNodeBinaryPropMap["Start"] = 4] = "Start";
    OperatorNodeBinaryPropMap[OperatorNodeBinaryPropMap["End"] = 5] = "End";
})(OperatorNodeBinaryPropMap || (OperatorNodeBinaryPropMap = {}));
/**
 * Property map for binary serialization.
 */
var ParenthesisNodeBinaryPropMap;
(function (ParenthesisNodeBinaryPropMap) {
    ParenthesisNodeBinaryPropMap[ParenthesisNodeBinaryPropMap["Expression"] = 1] = "Expression";
    ParenthesisNodeBinaryPropMap[ParenthesisNodeBinaryPropMap["Start"] = 2] = "Start";
    ParenthesisNodeBinaryPropMap[ParenthesisNodeBinaryPropMap["End"] = 3] = "End";
})(ParenthesisNodeBinaryPropMap || (ParenthesisNodeBinaryPropMap = {}));
/**
 * Possible token types in the logical expression.
 */
var TokenType;
(function (TokenType) {
    TokenType[TokenType["Variable"] = 0] = "Variable";
    TokenType[TokenType["Operator"] = 1] = "Operator";
    TokenType[TokenType["Parenthesis"] = 2] = "Parenthesis";
})(TokenType || (TokenType = {}));
/**
 * Possible node types in the logical expression.
 */
var NodeType;
(function (NodeType) {
    NodeType["Variable"] = "Variable";
    NodeType["Operator"] = "Operator";
    NodeType["Parenthesis"] = "Parenthesis";
})(NodeType || (NodeType = {}));
/**
 * Precedence of the operators, larger number means higher precedence.
 */
const OPERATOR_PRECEDENCE = {
    [OperatorValue.Not]: 3,
    [OperatorValue.And]: 2,
    [OperatorValue.Or]: 1,
};
const OPERATOR_BINARY_MAP = new Map([
    [OperatorValue.Not, 0],
    [OperatorValue.And, 1],
    [OperatorValue.Or, 2],
]);
const OPERATOR_BINARY_MAP_REVERSE = new Map(Array.from(OPERATOR_BINARY_MAP).map(([key, value]) => [value, key]));
/**
 * Gets the string representation of the operator from the binary representation.
 *
 * @param binary Binary representation of the operator
 * @returns String representation of the operator
 * @throws If the operator is unknown
 */
const getOperatorOrFail = (binary) => {
    const operator = OPERATOR_BINARY_MAP_REVERSE.get(binary);
    if (isUndefined(operator)) {
        throw new Error(`Unknown operator: ${binary}`);
    }
    return operator;
};
/**
 * Serialization map for known variables.
 */
const KNOWN_VARIABLES_MAP = new Map([
    ['ext_abp', 0],
    ['ext_ublock', 1],
    ['ext_ubol', 2],
    ['ext_devbuild', 3],
    ['env_chromium', 4],
    ['env_edge', 5],
    ['env_firefox', 6],
    ['env_mobile', 7],
    ['env_safari', 8],
    ['env_mv3', 9],
    ['false', 10],
    ['cap_html_filtering', 11],
    ['cap_user_stylesheet', 12],
    ['adguard', 13],
    ['adguard_app_windows', 14],
    ['adguard_app_mac', 15],
    ['adguard_app_android', 16],
    ['adguard_app_ios', 17],
    ['adguard_ext_safari', 18],
    ['adguard_ext_chromium', 19],
    ['adguard_ext_firefox', 20],
    ['adguard_ext_edge', 21],
    ['adguard_ext_opera', 22],
    ['adguard_ext_android_cb', 23],
    // TODO: Add 'adguard_ext_chromium_mv3' to the list
]);
/**
 * Deserialization map for known variables.
 */
const KNOWN_VARIABLES_MAP_REVERSE = new Map(Array.from(KNOWN_VARIABLES_MAP).map(([key, value]) => [value, key]));
/**
 * Gets the frequent name of the variable from the binary representation.
 *
 * @param binary Binary representation of the variable
 * @returns Frequent name of the variable
 * @throws If the variable is unknown
 */
const getFrequentNameOrFail = (binary) => {
    const name = KNOWN_VARIABLES_MAP_REVERSE.get(binary);
    if (isUndefined(name)) {
        throw new Error(`Unknown frequent name: ${binary}`);
    }
    return name;
};
/**
 * `LogicalExpressionParser` is responsible for parsing logical expressions.
 *
 * @example
 * From the following rule:
 * ```adblock
 * !#if (adguard_ext_android_cb || adguard_ext_safari)
 * ```
 * this parser will parse the expression `(adguard_ext_android_cb || adguard_ext_safari)`.
 */
// TODO: Refactor this class
class LogicalExpressionParser extends ParserBase {
    /**
     * Split the expression into tokens.
     *
     * @param raw Source code of the expression
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Token list
     * @throws {AdblockSyntaxError} If the expression is invalid
     */
    static tokenize(raw, baseOffset = 0) {
        const tokens = [];
        let offset = 0;
        while (offset < raw.length) {
            const char = raw[offset];
            if (StringUtils.isWhitespace(char)) {
                // Ignore whitespace
                offset += 1;
            }
            else if (StringUtils.isLetter(char)) {
                // Save the start offset of the variable name
                const nameStart = offset;
                // Variable name shouldn't start with a number or underscore,
                // but can contain them
                while (offset + 1 < raw.length
                    && (StringUtils.isAlphaNumeric(raw[offset + 1]) || raw[offset + 1] === UNDERSCORE)) {
                    offset += 1;
                }
                tokens.push({
                    type: TokenType.Variable,
                    start: nameStart,
                    end: offset + 1,
                });
                offset += 1;
            }
            else if (char === OPEN_PARENTHESIS || char === CLOSE_PARENTHESIS) {
                // Parenthesis
                tokens.push({
                    type: TokenType.Parenthesis,
                    start: offset,
                    end: offset + 1,
                });
                offset += 1;
            }
            else if (char === AMPERSAND || char === PIPE) {
                // Parse operator
                if (offset + 1 < raw.length && raw[offset + 1] === char) {
                    tokens.push({
                        type: TokenType.Operator,
                        start: offset,
                        end: offset + 2,
                    });
                    offset += 2;
                }
                else {
                    throw new AdblockSyntaxError(`Unexpected character "${char}"`, baseOffset + offset, baseOffset + offset + 1);
                }
            }
            else if (char === EXCLAMATION_MARK) {
                tokens.push({
                    type: TokenType.Operator,
                    start: offset,
                    end: offset + 1,
                });
                offset += 1;
            }
            else {
                throw new AdblockSyntaxError(`Unexpected character "${char}"`, baseOffset + offset, baseOffset + offset + 1);
            }
        }
        return tokens;
    }
    /**
     * Parses a logical expression.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Parsed expression
     * @throws {AdblockSyntaxError} If the expression is invalid
     */
    // TODO: Create a separate TokenStream class
    static parse(raw, options = defaultParserOptions, baseOffset = 0) {
        // Tokenize the source (produces an array of tokens)
        const tokens = LogicalExpressionParser.tokenize(raw, baseOffset);
        // Current token index
        let tokenIndex = 0;
        /**
         * Consumes a token of the expected type.
         *
         * @param type Expected token type
         * @returns The consumed token
         */
        function consume(type) {
            const token = tokens[tokenIndex];
            if (!token) {
                throw new AdblockSyntaxError(`Expected token of type "${type}", but reached end of input`, baseOffset, baseOffset + raw.length);
            }
            // We only use this function internally, so we can safely ignore this
            // from the coverage report
            // istanbul ignore next
            if (token.type !== type) {
                throw new AdblockSyntaxError(`Expected token of type "${type}", but got "${token.type}"`, baseOffset + token.start, baseOffset + token.end);
            }
            tokenIndex += 1;
            return token;
        }
        /**
         * Parses a variable.
         *
         * @returns Variable node
         */
        function parseVariable() {
            const token = consume(TokenType.Variable);
            const result = {
                type: NodeType.Variable,
                name: raw.slice(token.start, token.end),
            };
            if (options.isLocIncluded) {
                result.start = baseOffset + token.start;
                result.end = baseOffset + token.end;
            }
            return result;
        }
        /**
         * Parses a binary expression.
         *
         * @param left Left-hand side of the expression
         * @param minPrecedence Minimum precedence of the operator
         * @returns Binary expression node
         */
        function parseBinaryExpression(left, minPrecedence = 0) {
            let node = left;
            let operatorToken;
            while (tokens[tokenIndex]) {
                operatorToken = tokens[tokenIndex];
                if (!operatorToken || operatorToken.type !== TokenType.Operator) {
                    break;
                }
                // It is safe to cast here, because we already checked the type
                const operator = raw.slice(operatorToken.start, operatorToken.end);
                const precedence = OPERATOR_PRECEDENCE[operator];
                if (precedence < minPrecedence) {
                    break;
                }
                tokenIndex += 1;
                // eslint-disable-next-line @typescript-eslint/no-use-before-define
                const right = parseExpression(precedence + 1);
                const newNode = {
                    type: NodeType.Operator,
                    operator,
                    left: node,
                    right,
                };
                if (options.isLocIncluded) {
                    newNode.start = node.start ?? baseOffset + operatorToken.start;
                    newNode.end = right.end ?? baseOffset + operatorToken.end;
                }
                node = newNode;
            }
            return node;
        }
        /**
         * Parses a parenthesized expression.
         *
         * @returns Parenthesized expression node
         */
        function parseParenthesizedExpression() {
            consume(TokenType.Parenthesis);
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            const expression = parseExpression();
            consume(TokenType.Parenthesis);
            const result = {
                type: NodeType.Parenthesis,
                expression,
            };
            if (options.isLocIncluded) {
                result.start = expression.start;
                result.end = expression.end;
            }
            return result;
        }
        /**
         * Parses an expression.
         *
         * @param minPrecedence Minimum precedence of the operator
         * @returns Expression node
         */
        function parseExpression(minPrecedence = 0) {
            let node;
            const token = tokens[tokenIndex];
            const value = raw.slice(token.start, token.end);
            if (token.type === TokenType.Variable) {
                node = parseVariable();
            }
            else if (token.type === TokenType.Operator && value === OperatorValue.Not) {
                tokenIndex += 1;
                const expression = parseExpression(OPERATOR_PRECEDENCE[OperatorValue.Not]);
                node = {
                    type: NodeType.Operator,
                    operator: OperatorValue.Not,
                    left: expression,
                };
                if (options.isLocIncluded) {
                    if (expression.end) {
                        node.start = baseOffset + token.start;
                        // no need to shift the node location, because it's already shifted
                        node.end = expression.end;
                    }
                    else {
                        node.start = baseOffset + token.start;
                        node.end = baseOffset + token.end;
                    }
                }
            }
            else if (token.type === TokenType.Parenthesis && value === OPEN_PARENTHESIS) {
                node = parseParenthesizedExpression();
            }
            else {
                throw new AdblockSyntaxError(`Unexpected token "${value}"`, baseOffset + token.start, baseOffset + token.end);
            }
            return parseBinaryExpression(node, minPrecedence);
        }
        const expression = parseExpression();
        if (tokenIndex !== tokens.length) {
            throw new AdblockSyntaxError(`Unexpected token "${tokens[tokenIndex].type}"`, baseOffset + tokens[tokenIndex].start, baseOffset + tokens[tokenIndex].end);
        }
        return expression;
    }
    /**
     * Generates a string representation of the logical expression (serialization).
     *
     * @param node Expression node
     * @returns String representation of the logical expression
     */
    static generate(node) {
        if (node.type === NodeType.Variable) {
            return node.name;
        }
        if (node.type === NodeType.Operator) {
            const left = LogicalExpressionParser.generate(node.left);
            const right = node.right ? LogicalExpressionParser.generate(node.right) : undefined;
            const { operator } = node;
            // Special case for NOT operator
            if (operator === OperatorValue.Not) {
                return `${operator}${left}`;
            }
            // Right operand is required for AND and OR operators
            if (!right) {
                throw new Error('Expected right operand');
            }
            return `${left} ${operator} ${right}`;
        }
        if (node.type === NodeType.Parenthesis) {
            const expressionString = LogicalExpressionParser.generate(node.expression);
            return `(${expressionString})`;
        }
        // Theoretically, this shouldn't happen if the library is used correctly
        throw new Error('Unexpected node type');
    }
    /**
     * Serializes a variable node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    // TODO: create a common serialize / deserialize interface for such nodes (Variable, Value, Parameter, etc.)
    static serializeVariableNode(node, buffer) {
        buffer.writeUint8(BinaryTypeMap.ExpressionVariableNode);
        const frequentName = KNOWN_VARIABLES_MAP.get(node.name);
        if (!isUndefined(frequentName)) {
            buffer.writeUint8(VariableNodeBinaryPropMap.FrequentName);
            buffer.writeUint8(frequentName);
        }
        else {
            buffer.writeUint8(VariableNodeBinaryPropMap.Name);
            buffer.writeString(node.name);
        }
        if (!isUndefined(node.start)) {
            buffer.writeUint8(VariableNodeBinaryPropMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(VariableNodeBinaryPropMap.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Serializes a parenthesis node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serializeParenthesisNode(node, buffer) {
        buffer.writeUint8(BinaryTypeMap.ExpressionParenthesisNode);
        buffer.writeUint8(ParenthesisNodeBinaryPropMap.Expression);
        LogicalExpressionParser.serialize(node.expression, buffer);
        if (!isUndefined(node.start)) {
            buffer.writeUint8(ParenthesisNodeBinaryPropMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(ParenthesisNodeBinaryPropMap.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Serializes an operator node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serializeOperatorNode(node, buffer) {
        buffer.writeUint8(BinaryTypeMap.ExpressionOperatorNode);
        buffer.writeUint8(OperatorNodeBinaryPropMap.Operator);
        const operatorBinary = OPERATOR_BINARY_MAP.get(node.operator);
        if (isUndefined(operatorBinary)) {
            throw new Error(`Unknown operator: ${node.operator}`);
        }
        buffer.writeUint8(operatorBinary);
        buffer.writeUint8(OperatorNodeBinaryPropMap.Left);
        LogicalExpressionParser.serialize(node.left, buffer);
        if (node.right) {
            buffer.writeUint8(OperatorNodeBinaryPropMap.Right);
            LogicalExpressionParser.serialize(node.right, buffer);
        }
        if (!isUndefined(node.start)) {
            buffer.writeUint8(OperatorNodeBinaryPropMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(OperatorNodeBinaryPropMap.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Serializes a logical expression node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node, buffer) {
        switch (node.type) {
            case NodeType.Variable:
                LogicalExpressionParser.serializeVariableNode(node, buffer);
                break;
            case NodeType.Operator:
                LogicalExpressionParser.serializeOperatorNode(node, buffer);
                break;
            case NodeType.Parenthesis:
                LogicalExpressionParser.serializeParenthesisNode(node, buffer);
                break;
            default:
                throw new Error(`Unexpected node type: ${node.type}`);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Deserializes a variable node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserializeVariableNode(buffer, node) {
        buffer.assertUint8(BinaryTypeMap.ExpressionVariableNode);
        node.type = NodeType.Variable;
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case VariableNodeBinaryPropMap.Name:
                    node.name = buffer.readString();
                    break;
                case VariableNodeBinaryPropMap.FrequentName:
                    node.name = getFrequentNameOrFail(buffer.readUint8());
                    break;
                case VariableNodeBinaryPropMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case VariableNodeBinaryPropMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
    /**
     * Deserializes a parenthesis node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserializeParenthesisNode(buffer, node) {
        buffer.assertUint8(BinaryTypeMap.ExpressionParenthesisNode);
        node.type = NodeType.Parenthesis;
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case ParenthesisNodeBinaryPropMap.Expression:
                    LogicalExpressionParser.deserialize(buffer, node.expression = {});
                    break;
                case ParenthesisNodeBinaryPropMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case ParenthesisNodeBinaryPropMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
    /**
     * Deserializes an operator node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserializeOperatorNode(buffer, node) {
        buffer.assertUint8(BinaryTypeMap.ExpressionOperatorNode);
        node.type = NodeType.Operator;
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case OperatorNodeBinaryPropMap.Operator:
                    node.operator = getOperatorOrFail(buffer.readUint8());
                    break;
                case OperatorNodeBinaryPropMap.Left:
                    LogicalExpressionParser.deserialize(buffer, node.left = {});
                    break;
                case OperatorNodeBinaryPropMap.Right:
                    LogicalExpressionParser.deserialize(buffer, node.right = {});
                    break;
                case OperatorNodeBinaryPropMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case OperatorNodeBinaryPropMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
    /**
     * Deserializes a logical expression node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node) {
        // note: we just do a simple lookahead here, because advancing the buffer is done in the
        // 'sub-deserialize' methods
        let type = buffer.peekUint8();
        while (type !== NULL) {
            switch (type) {
                case BinaryTypeMap.ExpressionVariableNode:
                    LogicalExpressionParser.deserializeVariableNode(buffer, node);
                    break;
                case BinaryTypeMap.ExpressionOperatorNode:
                    LogicalExpressionParser.deserializeOperatorNode(buffer, node);
                    break;
                case BinaryTypeMap.ExpressionParenthesisNode:
                    // eslint-disable-next-line max-len
                    LogicalExpressionParser.deserializeParenthesisNode(buffer, node);
                    break;
                default:
                    throw new Error(`Unexpected node type: ${type}`);
            }
            type = buffer.peekUint8();
        }
        // consume NULL
        buffer.readUint8();
    }
}

/* eslint-disable no-param-reassign */
/**
 * Pre-processor directives
 *
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#pre-processor-directives}
 * @see {@link https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#pre-parsing-directives}
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
var PreProcessorRuleSerializationMap;
(function (PreProcessorRuleSerializationMap) {
    PreProcessorRuleSerializationMap[PreProcessorRuleSerializationMap["Name"] = 1] = "Name";
    PreProcessorRuleSerializationMap[PreProcessorRuleSerializationMap["Params"] = 2] = "Params";
    PreProcessorRuleSerializationMap[PreProcessorRuleSerializationMap["Syntax"] = 3] = "Syntax";
    PreProcessorRuleSerializationMap[PreProcessorRuleSerializationMap["Start"] = 4] = "Start";
    PreProcessorRuleSerializationMap[PreProcessorRuleSerializationMap["End"] = 5] = "End";
})(PreProcessorRuleSerializationMap || (PreProcessorRuleSerializationMap = {}));
/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 *
 * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#preprocessor-directives}
 * @see {@link https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#pre-parsing-directives}
 */
const FREQUENT_DIRECTIVES_SERIALIZATION_MAP = new Map([
    ['if', 0],
    ['else', 1],
    ['endif', 2],
    ['include', 3],
    ['safari_cb_affinity', 4],
]);
/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
const FREQUENT_DIRECTIVES_DESERIALIZATION_MAP = new Map(Array.from(FREQUENT_DIRECTIVES_SERIALIZATION_MAP).map(([key, value]) => [value, key]));
/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const FREQUENT_PARAMS_SERIALIZATION_MAP = new Map([
    // safari_cb_affinity parameters
    ['general', 0],
    ['privacy', 1],
    ['social', 2],
    ['security', 3],
    ['other', 4],
    ['custom', 5],
    ['all', 6],
]);
/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
const FREQUENT_PARAMS_DESERIALIZATION_MAP = new Map(Array.from(FREQUENT_PARAMS_SERIALIZATION_MAP).map(([key, value]) => [value, key]));
/**
 * `PreProcessorParser` is responsible for parsing preprocessor rules.
 * Pre-processor comments are special comments that are used to control the behavior of the filter list processor.
 * Please note that this parser only handles general syntax for now, and does not validate the parameters at
 * the parsing stage.
 *
 * @example
 * If your rule is
 * ```adblock
 * !#if (adguard)
 * ```
 * then the directive's name is `if` and its value is `(adguard)`, but the parameter list
 * is not parsed / validated further.
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#pre-processor-directives}
 * @see {@link https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#pre-parsing-directives}
 */
class PreProcessorCommentRuleParser extends ParserBase {
    /**
     * Determines whether the rule is a pre-processor rule.
     *
     * @param raw Raw rule
     * @returns `true` if the rule is a pre-processor rule, `false` otherwise
     */
    static isPreProcessorRule(raw) {
        const trimmed = raw.trim();
        // Avoid this case: !##... (commonly used in AdGuard filters)
        return trimmed.startsWith(PREPROCESSOR_MARKER) && trimmed[PREPROCESSOR_MARKER_LEN] !== HASHMARK;
    }
    /**
     * Parses a raw rule as a pre-processor comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns
     * Pre-processor comment AST or null (if the raw rule cannot be parsed as a pre-processor comment)
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0) {
        // Ignore non-pre-processor rules
        if (!PreProcessorCommentRuleParser.isPreProcessorRule(raw)) {
            return null;
        }
        let offset = 0;
        // Ignore whitespace characters before the rule (if any)
        offset = StringUtils.skipWS(raw, offset);
        // Ignore the pre-processor marker
        offset += PREPROCESSOR_MARKER_LEN;
        // Ignore whitespace characters after the pre-processor marker (if any)
        // Note: this is incorrect according to the spec, but we do it for tolerance
        offset = StringUtils.skipWS(raw, offset);
        // Directive name should start at this offset, so we save this offset now
        const nameStart = offset;
        // Consume directive name, so parse the sequence until the first
        // whitespace / opening parenthesis / end of string
        while (offset < raw.length) {
            const ch = raw[offset];
            if (ch === PREPROCESSOR_SEPARATOR || ch === OPEN_PARENTHESIS) {
                break;
            }
            offset += 1;
        }
        // Save name end offset
        const nameEnd = offset;
        // Create name node
        const name = ValueParser.parse(raw.slice(nameStart, nameEnd), options, baseOffset + nameStart);
        // Ignore whitespace characters after the directive name (if any)
        // Note: this may incorrect according to the spec, but we do it for tolerance
        offset = StringUtils.skipWS(raw, offset);
        // If the directive name is "safari_cb_affinity", then we have a special case
        if (name.value === SAFARI_CB_AFFINITY) {
            // Throw error if there are spaces after the directive name
            if (offset > nameEnd) {
                throw new AdblockSyntaxError(`Unexpected whitespace after "${SAFARI_CB_AFFINITY}" directive name`, baseOffset + nameEnd, baseOffset + offset);
            }
            // safari_cb_affinity directive optionally accepts a parameter list
            // So at this point we should check if there are parameters or not
            // (cb_affinity directive followed by an opening parenthesis or if we
            // skip the whitespace we reach the end of the string)
            if (StringUtils.skipWS(raw, offset) !== raw.length) {
                if (raw[offset] !== OPEN_PARENTHESIS) {
                    throw new AdblockSyntaxError(`Unexpected character '${raw[offset]}' after '${SAFARI_CB_AFFINITY}' directive name`, baseOffset + offset, baseOffset + offset + 1);
                }
                // If we have parameters, then we should parse them
                // Note: we don't validate the parameters at this stage
                // Ignore opening parenthesis
                offset += 1;
                // Save parameter list start offset
                const parameterListStart = offset;
                // Check for closing parenthesis
                const closingParenthesesIndex = StringUtils.skipWSBack(raw);
                if (closingParenthesesIndex === -1 || raw[closingParenthesesIndex] !== CLOSE_PARENTHESIS) {
                    throw new AdblockSyntaxError(`Missing closing parenthesis for '${SAFARI_CB_AFFINITY}' directive`, baseOffset + offset, baseOffset + raw.length);
                }
                // Save parameter list end offset
                const parameterListEnd = closingParenthesesIndex;
                // Parse parameters between the opening and closing parentheses
                const result = {
                    type: CommentRuleType.PreProcessorCommentRule,
                    category: RuleCategory.Comment,
                    syntax: AdblockSyntax.Adg,
                    name,
                    // comma separated list of parameters
                    params: ParameterListParser.parse(raw.slice(parameterListStart, parameterListEnd), options, baseOffset + parameterListStart, COMMA),
                };
                if (options.includeRaws) {
                    result.raws = {
                        text: raw,
                    };
                }
                if (options.isLocIncluded) {
                    result.start = baseOffset;
                    result.end = baseOffset + raw.length;
                }
                return result;
            }
        }
        // If we reached the end of the string, then we have a directive without parameters
        // (e.g. "!#safari_cb_affinity" or "!#endif")
        // No need to continue parsing in this case.
        if (offset === raw.length) {
            // Throw error if the directive name is "if" or "include", because these directives
            // should have parameters
            if (name.value === IF || name.value === INCLUDE) {
                throw new AdblockSyntaxError(`Directive "${name.value}" requires parameters`, baseOffset, baseOffset + raw.length);
            }
            const result = {
                type: CommentRuleType.PreProcessorCommentRule,
                category: RuleCategory.Comment,
                syntax: AdblockSyntax.Common,
                name,
            };
            if (options.includeRaws) {
                result.raws = {
                    text: raw,
                };
            }
            if (options.isLocIncluded) {
                result.start = baseOffset;
                result.end = baseOffset + raw.length;
            }
            return result;
        }
        // Get start and end offsets of the directive parameters
        const paramsStart = offset;
        const paramsEnd = StringUtils.skipWSBack(raw) + 1;
        // Prepare parameters node
        let params;
        // Parse parameters. Handle "if" and "safari_cb_affinity" directives
        // separately.
        if (name.value === IF) {
            params = LogicalExpressionParser.parse(raw.slice(paramsStart, paramsEnd), options, baseOffset + paramsStart);
        }
        else {
            params = ValueParser.parse(raw.slice(paramsStart, paramsEnd), options, baseOffset + paramsStart);
        }
        const result = {
            type: CommentRuleType.PreProcessorCommentRule,
            category: RuleCategory.Comment,
            syntax: AdblockSyntax.Common,
            name,
            params,
        };
        if (options.includeRaws) {
            result.raws = {
                text: raw,
            };
        }
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        return result;
    }
    /**
     * Converts a pre-processor comment node to a string.
     *
     * @param node Pre-processor comment node
     * @returns Raw string
     */
    static generate(node) {
        let result = EMPTY;
        result += PREPROCESSOR_MARKER;
        result += node.name.value;
        if (node.params) {
            // Space is not allowed after "safari_cb_affinity" directive, so we need to handle it separately.
            if (node.name.value !== SAFARI_CB_AFFINITY) {
                result += SPACE;
            }
            if (node.params.type === 'Value') {
                result += ValueParser.generate(node.params);
            }
            else if (node.params.type === 'ParameterList') {
                result += OPEN_PARENTHESIS;
                result += ParameterListParser.generate(node.params);
                result += CLOSE_PARENTHESIS;
            }
            else {
                result += LogicalExpressionParser.generate(node.params);
            }
        }
        return result;
    }
    /**
     * Serializes a pre-processor comment node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    // TODO: add support for raws, if ever needed
    static serialize(node, buffer) {
        buffer.writeUint8(BinaryTypeMap.PreProcessorCommentRuleNode);
        buffer.writeUint8(PreProcessorRuleSerializationMap.Name);
        ValueParser.serialize(node.name, buffer, FREQUENT_DIRECTIVES_SERIALIZATION_MAP);
        buffer.writeUint8(PreProcessorRuleSerializationMap.Syntax);
        buffer.writeUint8(SYNTAX_SERIALIZATION_MAP.get(node.syntax) ?? 0);
        if (!isUndefined(node.params)) {
            buffer.writeUint8(PreProcessorRuleSerializationMap.Params);
            if (node.params.type === 'Value') {
                ValueParser.serialize(node.params, buffer);
            }
            else if (node.params.type === 'ParameterList') {
                ParameterListParser.serialize(node.params, buffer, FREQUENT_PARAMS_SERIALIZATION_MAP, true);
            }
            else {
                LogicalExpressionParser.serialize(node.params, buffer);
            }
        }
        if (!isUndefined(node.start)) {
            buffer.writeUint8(PreProcessorRuleSerializationMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(PreProcessorRuleSerializationMap.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Deserializes a pre-processor comment node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(BinaryTypeMap.PreProcessorCommentRuleNode);
        node.type = CommentRuleType.PreProcessorCommentRule;
        node.category = RuleCategory.Comment;
        node.syntax = AdblockSyntax.Common;
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case PreProcessorRuleSerializationMap.Name:
                    ValueParser.deserialize(buffer, node.name = {}, FREQUENT_DIRECTIVES_DESERIALIZATION_MAP);
                    break;
                case PreProcessorRuleSerializationMap.Syntax:
                    node.syntax = SYNTAX_DESERIALIZATION_MAP.get(buffer.readUint8()) ?? AdblockSyntax.Common;
                    break;
                case PreProcessorRuleSerializationMap.Params:
                    switch (buffer.peekUint8()) {
                        case BinaryTypeMap.ValueNode:
                            ValueParser.deserialize(buffer, node.params = {});
                            break;
                        case BinaryTypeMap.ParameterListNode:
                            // eslint-disable-next-line max-len
                            ParameterListParser.deserialize(buffer, node.params = {}, FREQUENT_PARAMS_DESERIALIZATION_MAP);
                            break;
                        case BinaryTypeMap.ExpressionOperatorNode:
                        case BinaryTypeMap.ExpressionParenthesisNode:
                        case BinaryTypeMap.ExpressionVariableNode:
                            LogicalExpressionParser.deserialize(buffer, node.params = {});
                            break;
                        default:
                            throw new Error(`Invalid binary type: ${prop}`);
                    }
                    break;
                case PreProcessorRuleSerializationMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case PreProcessorRuleSerializationMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
}

/* eslint-disable no-param-reassign */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
var SimpleCommentRuleSerializationMap;
(function (SimpleCommentRuleSerializationMap) {
    SimpleCommentRuleSerializationMap[SimpleCommentRuleSerializationMap["Marker"] = 1] = "Marker";
    SimpleCommentRuleSerializationMap[SimpleCommentRuleSerializationMap["Text"] = 2] = "Text";
    SimpleCommentRuleSerializationMap[SimpleCommentRuleSerializationMap["Start"] = 3] = "Start";
    SimpleCommentRuleSerializationMap[SimpleCommentRuleSerializationMap["End"] = 4] = "End";
})(SimpleCommentRuleSerializationMap || (SimpleCommentRuleSerializationMap = {}));
/**
 * `SimpleCommentParser` is responsible for parsing simple comments.
 * Some comments have a special meaning in adblock syntax, like agent comments or hints,
 * but this parser is only responsible for parsing regular comments,
 * whose only purpose is to provide some human-readable information.
 *
 * @example
 * ```adblock
 * ! This is a simple comment
 * # This is a simple comment, but in host-like syntax
 * ```
 */
class SimpleCommentParser extends ParserBase {
    /**
     * Checks if the raw rule is a simple comment.
     *
     * @param raw Raw input to check.
     * @returns `true` if the input is a simple comment, `false` otherwise.
     * @note This method does not check for adblock agent comments.
     */
    static isSimpleComment(raw) {
        const trimmed = raw.trim();
        // Exclamation mark based comments
        if (trimmed.startsWith(CommentMarker.Regular)) {
            return true;
        }
        // Hashmark based comments
        // Note: in this case, we must be sure that we do not mistakenly parse a cosmetic rule as a #-like comment,
        // since most cosmetic rule separators also start with #
        if (trimmed.startsWith(CommentMarker.Hashmark)) {
            const result = CosmeticRuleSeparatorUtils.find(trimmed);
            // If we cannot find a separator, it means that the rule is definitely a comment
            if (result === null) {
                return true;
            }
            // Otherwise, we must check if the separator is followed by a valid selector
            const { end } = result;
            // No valid selector
            if (!trimmed[end + 1]
                || StringUtils.isWhitespace(trimmed[end + 1])
                || (trimmed[end + 1] === CommentMarker.Hashmark && trimmed[end + 2] === CommentMarker.Hashmark)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Parses a raw rule as a simple comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Comment rule node or null (if the raw rule cannot be parsed as a simple comment).
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0) {
        // Ignore non-comment rules
        if (!this.isSimpleComment(raw)) {
            return null;
        }
        // If we are here, it means that the rule is a regular comment
        let offset = 0;
        // Skip leading whitespace (if any)
        offset = StringUtils.skipWS(raw, offset);
        // Get comment marker
        const marker = ValueParser.parse(raw[offset], options, baseOffset + offset);
        // Skip marker
        offset += 1;
        // Get comment text
        const text = ValueParser.parse(raw.slice(offset), options, baseOffset + offset);
        // Regular comment rule
        const result = {
            category: RuleCategory.Comment,
            type: CommentRuleType.CommentRule,
            // TODO: Change syntax when hashmark is used
            syntax: AdblockSyntax.Common,
            marker,
            text,
        };
        if (options.includeRaws) {
            result.raws = {
                text: raw,
            };
        }
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        return result;
    }
    /**
     * Converts a comment rule node to a string.
     *
     * @param node Comment rule node.
     * @returns Raw string.
     */
    static generate(node) {
        let result = EMPTY;
        result += ValueParser.generate(node.marker);
        result += ValueParser.generate(node.text);
        return result;
    }
    /**
     * Serializes a simple comment rule node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    // TODO: add support for raws, if ever needed
    static serialize(node, buffer) {
        buffer.writeUint8(BinaryTypeMap.CommentRuleNode);
        buffer.writeUint8(SimpleCommentRuleSerializationMap.Marker);
        ValueParser.serialize(node.marker, buffer);
        buffer.writeUint8(SimpleCommentRuleSerializationMap.Text);
        ValueParser.serialize(node.text, buffer);
        if (!isUndefined(node.start)) {
            buffer.writeUint8(SimpleCommentRuleSerializationMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(SimpleCommentRuleSerializationMap.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Deserializes a simple comment node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(BinaryTypeMap.CommentRuleNode);
        node.type = CommentRuleType.CommentRule;
        node.category = RuleCategory.Comment;
        node.syntax = AdblockSyntax.Common;
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case SimpleCommentRuleSerializationMap.Marker:
                    ValueParser.deserialize(buffer, node.marker = {});
                    break;
                case SimpleCommentRuleSerializationMap.Text:
                    ValueParser.deserialize(buffer, node.text = {});
                    break;
                case SimpleCommentRuleSerializationMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case SimpleCommentRuleSerializationMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
}

/* eslint-disable no-param-reassign */
/**
 * `CommentParser` is responsible for parsing any comment-like adblock rules.
 *
 * @example
 * Example rules:
 *  - Adblock agent rules:
 *      - ```adblock
 *        [AdGuard]
 *        ```
 *      - ```adblock
 *        [Adblock Plus 2.0]
 *        ```
 *      - etc.
 *  - AdGuard hint rules:
 *      - ```adblock
 *        !+ NOT_OPTIMIZED
 *        ```
 *      - ```adblock
 *        !+ NOT_OPTIMIZED PLATFORM(windows)
 *        ```
 *      - etc.
 *  - Pre-processor rules:
 *      - ```adblock
 *        !#if (adguard)
 *        ```
 *      - ```adblock
 *        !#endif
 *        ```
 *      - etc.
 *  - Metadata rules:
 *      - ```adblock
 *        ! Title: My List
 *        ```
 *      - ```adblock
 *        ! Version: 2.0.150
 *        ```
 *      - etc.
 *  - AGLint inline config rules:
 *      - ```adblock
 *        ! aglint-enable some-rule
 *        ```
 *      - ```adblock
 *        ! aglint-disable some-rule
 *        ```
 *      - etc.
 *  - Simple comments:
 *      - Regular version:
 *        ```adblock
 *        ! This is just a comment
 *        ```
 *      - uBlock Origin / "hostlist" version:
 *        ```adblock
 *        # This is just a comment
 *        ```
 *      - etc.
 */
class CommentRuleParser extends ParserBase {
    /**
     * Checks whether a rule is a comment.
     *
     * @param raw Raw rule
     * @returns `true` if the rule is a comment, `false` otherwise
     */
    static isCommentRule(raw) {
        const trimmed = raw.trim();
        return SimpleCommentParser.isSimpleComment(trimmed) || AgentCommentRuleParser.isAgentRule(trimmed);
    }
    /**
     * Parses a raw rule as comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Comment AST or null (if the raw rule cannot be parsed as comment)
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0) {
        // Ignore non-comment rules
        if (!CommentRuleParser.isCommentRule(raw)) {
            return null;
        }
        // Note: we parse non-functional comments at the end,
        // if the input does not match any of the previous, more specific comment patterns
        return AgentCommentRuleParser.parse(raw, options, baseOffset)
            || HintCommentRuleParser.parse(raw, options, baseOffset)
            || PreProcessorCommentRuleParser.parse(raw, options, baseOffset)
            || MetadataCommentRuleParser.parse(raw, options, baseOffset)
            || ConfigCommentRuleParser.parse(raw, options, baseOffset)
            || SimpleCommentParser.parse(raw, options, baseOffset);
    }
    /**
     * Converts a comment rule node to a string.
     *
     * @param node Comment rule node
     * @returns Raw string
     */
    static generate(node) {
        switch (node.type) {
            case CommentRuleType.AgentCommentRule:
                return AgentCommentRuleParser.generate(node);
            case CommentRuleType.HintCommentRule:
                return HintCommentRuleParser.generate(node);
            case CommentRuleType.PreProcessorCommentRule:
                return PreProcessorCommentRuleParser.generate(node);
            case CommentRuleType.MetadataCommentRule:
                return MetadataCommentRuleParser.generate(node);
            case CommentRuleType.ConfigCommentRule:
                return ConfigCommentRuleParser.generate(node);
            case CommentRuleType.CommentRule:
                return SimpleCommentParser.generate(node);
            default:
                throw new Error('Unknown comment rule type');
        }
    }
    /**
     * Serializes a comment rule node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node, buffer) {
        switch (node.type) {
            case CommentRuleType.AgentCommentRule:
                AgentCommentRuleParser.serialize(node, buffer);
                return;
            case CommentRuleType.HintCommentRule:
                HintCommentRuleParser.serialize(node, buffer);
                return;
            case CommentRuleType.PreProcessorCommentRule:
                PreProcessorCommentRuleParser.serialize(node, buffer);
                return;
            case CommentRuleType.MetadataCommentRule:
                MetadataCommentRuleParser.serialize(node, buffer);
                return;
            case CommentRuleType.ConfigCommentRule:
                ConfigCommentRuleParser.serialize(node, buffer);
                return;
            case CommentRuleType.CommentRule:
                SimpleCommentParser.serialize(node, buffer);
                break;
            default:
                throw new Error('Unknown comment rule type');
        }
    }
    /**
     * Deserializes a comment rule node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node) {
        const type = buffer.peekUint8();
        switch (type) {
            case BinaryTypeMap.AgentRuleNode:
                AgentCommentRuleParser.deserialize(buffer, node);
                return;
            case BinaryTypeMap.HintRuleNode:
                HintCommentRuleParser.deserialize(buffer, node);
                return;
            case BinaryTypeMap.PreProcessorCommentRuleNode:
                PreProcessorCommentRuleParser.deserialize(buffer, node);
                return;
            case BinaryTypeMap.MetadataCommentRuleNode:
                MetadataCommentRuleParser.deserialize(buffer, node);
                return;
            case BinaryTypeMap.ConfigCommentRuleNode:
                ConfigCommentRuleParser.deserialize(buffer, node);
                return;
            case BinaryTypeMap.CommentRuleNode:
                SimpleCommentParser.deserialize(buffer, node);
                return;
            default:
                throw new Error(`Unknown comment rule type: ${type}`);
        }
    }
}

/* eslint-disable no-param-reassign */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the binary schema version
 *
 * @note Only 256 values can be represented this way.
 */
var ListItemSerializationMap;
(function (ListItemSerializationMap) {
    ListItemSerializationMap[ListItemSerializationMap["Exception"] = 1] = "Exception";
    ListItemSerializationMap[ListItemSerializationMap["Value"] = 2] = "Value";
    ListItemSerializationMap[ListItemSerializationMap["Start"] = 3] = "Start";
    ListItemSerializationMap[ListItemSerializationMap["End"] = 4] = "End";
})(ListItemSerializationMap || (ListItemSerializationMap = {}));
/**
 * Prefixes for error messages which are used for parsing of value lists.
 */
const LIST_PARSE_ERROR_PREFIX = {
    EMPTY_ITEM: 'Empty value specified in the list',
    NO_MULTIPLE_NEGATION: 'Exception marker cannot be followed by another exception marker',
    NO_SEPARATOR_AFTER_NEGATION: 'Exception marker cannot be followed by a separator',
    NO_SEPARATOR_AT_THE_BEGINNING: 'Value list cannot start with a separator',
    NO_SEPARATOR_AT_THE_END: 'Value list cannot end with a separator',
    NO_WHITESPACE_AFTER_NEGATION: 'Exception marker cannot be followed by whitespace',
};
/**
 * Parses a `raw` modifier value which may be represented as a list of items separated by `separator`.
 * Needed for $app, $denyallow, $domain, $method.
 *
 * @param raw Raw input to parse.
 * @param options Global parser options.
 * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
 * @param separator Separator character (default: comma)
 * @param type Type of the list items (default: {@link ListItemNodeType.Domain}).
 * @template T Type of the list items.
 *
 * @returns List of parsed items.
 * @throws An {@link AdblockSyntaxError} if the list is syntactically invalid
 *
 * @example
 * - parses an app list â€” `com.example.app|Example.exe`
 * - parses a domain list â€” `example.com,example.org,~example.org` or `example.com|~example.org`
 * - parses a method list â€” `~post|~put`
 */
const parseListItems = (raw, options = defaultParserOptions, baseOffset = 0, separator = COMMA, type = ListItemNodeType.Unknown) => {
    // Function body here
    const rawListItems = [];
    let offset = 0;
    // Skip whitespace before the list
    offset = StringUtils.skipWS(raw, offset);
    // If the first character is a separator, then the list is invalid
    // and no need to continue parsing
    if (raw[offset] === separator) {
        throw new AdblockSyntaxError(LIST_PARSE_ERROR_PREFIX.NO_SEPARATOR_AT_THE_BEGINNING, baseOffset + offset, baseOffset + raw.length);
    }
    // If the last character is a separator, then the list item is invalid
    // and no need to continue parsing
    const realEndIndex = StringUtils.skipWSBack(raw);
    if (raw[realEndIndex] === separator) {
        throw new AdblockSyntaxError(LIST_PARSE_ERROR_PREFIX.NO_SEPARATOR_AT_THE_END, baseOffset + realEndIndex, baseOffset + realEndIndex + 1);
    }
    // Split list items by unescaped separators
    while (offset < raw.length) {
        // Skip whitespace before the list item
        offset = StringUtils.skipWS(raw, offset);
        let itemStart = offset;
        // Find the index of the first unescaped separator character
        const separatorStartIndex = StringUtils.findNextUnescapedCharacter(raw, separator, offset);
        const itemEnd = separatorStartIndex === -1
            ? StringUtils.skipWSBack(raw) + 1
            : StringUtils.skipWSBack(raw, separatorStartIndex - 1) + 1;
        const exception = raw[itemStart] === NEGATION_MARKER;
        // Skip the exception marker
        if (exception) {
            itemStart += 1;
            const item = raw[itemStart];
            // Exception marker cannot be followed by another exception marker
            if (item === NEGATION_MARKER) {
                throw new AdblockSyntaxError(LIST_PARSE_ERROR_PREFIX.NO_MULTIPLE_NEGATION, baseOffset + itemStart, baseOffset + itemStart + 1);
            }
            // Exception marker cannot be followed by a separator
            if (item === separator) {
                throw new AdblockSyntaxError(LIST_PARSE_ERROR_PREFIX.NO_SEPARATOR_AFTER_NEGATION, baseOffset + itemStart, baseOffset + itemStart + 1);
            }
            // Exception marker cannot be followed by whitespace
            if (StringUtils.isWhitespace(item)) {
                throw new AdblockSyntaxError(LIST_PARSE_ERROR_PREFIX.NO_WHITESPACE_AFTER_NEGATION, baseOffset + itemStart, baseOffset + itemStart + 1);
            }
        }
        // List item can't be empty
        // Note we use '<=' instead of '===' because we have bidirectional trim
        // This is needed to handle cases like 'example.com, ,example.org'
        if (itemEnd <= itemStart) {
            throw new AdblockSyntaxError(LIST_PARSE_ERROR_PREFIX.EMPTY_ITEM, baseOffset + itemStart, baseOffset + raw.length);
        }
        const listItem = {
            type,
            value: raw.slice(itemStart, itemEnd),
            exception,
        };
        if (options.isLocIncluded) {
            listItem.start = baseOffset + itemStart;
            listItem.end = baseOffset + itemEnd;
        }
        // Collect list item
        rawListItems.push(listItem);
        // Increment the offset to the next list item (or the end of the string)
        offset = separatorStartIndex === -1 ? raw.length : separatorStartIndex + 1;
    }
    return rawListItems;
};
/**
 * Generates a string representation of a list item.
 *
 * @param item List item to generate.
 * @template T Type of the list item.
 *
 * @returns String representation of the list item.
 */
const generateListItem = (item) => {
    return `${item.exception ? NEGATION_MARKER : EMPTY}${item.value}`;
};
/**
 * Generates a string representation of a list of items.
 *
 * @param items List of items to generate.
 * @param separator Separator character.
 * @template T Type of the list items.
 *
 * @returns String representation of the list of items.
 */
const generateListItems = (items, separator) => {
    return items.map(generateListItem).join(separator);
};
/**
 * Serializes a list item to binary format.
 *
 * @param item List item to serialize.
 * @param buffer Output byte buffer.
 * @template T Type of the list item.
 */
const serializeListItem = (item, buffer) => {
    switch (item.type) {
        case ListItemNodeType.App:
            buffer.writeUint8(BinaryTypeMap.AppNode);
            break;
        case ListItemNodeType.Domain:
            buffer.writeUint8(BinaryTypeMap.DomainNode);
            break;
        case ListItemNodeType.Method:
            buffer.writeUint8(BinaryTypeMap.MethodNode);
            break;
        case ListItemNodeType.StealthOption:
            buffer.writeUint8(BinaryTypeMap.StealthOptionNode);
            break;
        default:
            throw new Error(`Invalid list item type: ${item.type}`);
    }
    buffer.writeUint8(ListItemSerializationMap.Exception);
    buffer.writeUint8(item.exception ? 1 : 0);
    buffer.writeUint8(ListItemSerializationMap.Value);
    buffer.writeString(item.value);
    if (!isUndefined(item.start)) {
        buffer.writeUint8(ListItemSerializationMap.Start);
        buffer.writeUint32(item.start);
    }
    if (!isUndefined(item.end)) {
        buffer.writeUint8(ListItemSerializationMap.End);
        buffer.writeUint32(item.end);
    }
    buffer.writeUint8(NULL);
};
/**
 * Deserializes a list item from binary format.
 *
 * @param buffer Input byte buffer.
 * @param node Partial list item to deserialize.
 * @template T Type of the list item.
 */
const deserializeListItem = (buffer, node) => {
    const type = buffer.readUint8();
    switch (type) {
        case BinaryTypeMap.AppNode:
            node.type = ListItemNodeType.App;
            break;
        case BinaryTypeMap.DomainNode:
            node.type = ListItemNodeType.Domain;
            break;
        case BinaryTypeMap.MethodNode:
            node.type = ListItemNodeType.Method;
            break;
        case BinaryTypeMap.StealthOptionNode:
            node.type = ListItemNodeType.StealthOption;
            break;
        default:
            throw new Error(`Invalid list item type: ${type}`);
    }
    let prop = buffer.readUint8();
    while (prop !== NULL) {
        switch (prop) {
            case ListItemSerializationMap.Exception:
                node.exception = buffer.readUint8() === 1;
                break;
            case ListItemSerializationMap.Value:
                node.value = buffer.readString();
                break;
            case ListItemSerializationMap.Start:
                node.start = buffer.readUint32();
                break;
            case ListItemSerializationMap.End:
                node.end = buffer.readUint32();
                break;
            default:
                throw new Error(`Invalid property: ${type}`);
        }
        prop = buffer.readUint8();
    }
};
/**
 * Serializes a list of items to binary format.
 *
 * @param items List of items to serialize.
 * @param buffer Output byte buffer.
 * @template T Type of the list items.
 */
const serializeListItems = (items, buffer) => {
    const { length } = items;
    buffer.writeUint16(length);
    for (let i = 0; i < length; i += 1) {
        serializeListItem(items[i], buffer);
    }
};
/**
 * Deserializes a list of items from binary format.
 *
 * @param buffer Input byte buffer.
 * @param items Partial list of items to deserialize.
 * @template T Type of the list items.
 */
const deserializeListItems = (buffer, items) => {
    const length = buffer.readUint16();
    items.length = length;
    for (let i = 0; i < length; i += 1) {
        deserializeListItem(buffer, items[i] = {});
    }
};

/* eslint-disable no-param-reassign */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the binary schema version
 *
 * @note Only 256 values can be represented this way.
 */
var DomainListSerializationMap;
(function (DomainListSerializationMap) {
    DomainListSerializationMap[DomainListSerializationMap["Separator"] = 1] = "Separator";
    DomainListSerializationMap[DomainListSerializationMap["Children"] = 2] = "Children";
    DomainListSerializationMap[DomainListSerializationMap["Start"] = 3] = "Start";
    DomainListSerializationMap[DomainListSerializationMap["End"] = 4] = "End";
})(DomainListSerializationMap || (DomainListSerializationMap = {}));
/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const SEPARATOR_SERIALIZATION_MAP$1 = new Map([
    [COMMA, 0],
    [PIPE, 1],
]);
/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
const SEPARATOR_DESERIALIZATION_MAP$1 = new Map(Array.from(SEPARATOR_SERIALIZATION_MAP$1).map(([key, value]) => [value, key]));
/**
 * `DomainListParser` is responsible for parsing a domain list.
 *
 * @example
 * - If the rule is `example.com,~example.net##.ads`, the domain list is `example.com,~example.net`.
 * - If the rule is `ads.js^$script,domains=example.com|~example.org`, the domain list is `example.com|~example.org`.
 * This parser is responsible for parsing these domain lists.
 * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#elemhide_domains}
 */
class DomainListParser extends ParserBase {
    /**
     * Parses a domain list, eg. `example.com,example.org,~example.org`
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @param separator Separator character (default: comma)
     *
     * @returns Domain list AST.
     * @throws An {@link AdblockSyntaxError} if the domain list is syntactically invalid.
     * @throws An {@link Error} if the options are invalid.
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0, separator = COMMA) {
        if (separator !== COMMA && separator !== PIPE) {
            throw new Error(`Invalid separator: ${separator}`);
        }
        const result = {
            type: ListNodeType.DomainList,
            separator,
            children: parseListItems(raw, options, baseOffset, separator, ListItemNodeType.Domain),
        };
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        return result;
    }
    /**
     * Converts a domain list node to a string.
     *
     * @param node Domain list node.
     *
     * @returns Raw string.
     */
    static generate(node) {
        return generateListItems(node.children, node.separator);
    }
    /**
     * Serializes a domain list node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node, buffer) {
        buffer.writeUint8(BinaryTypeMap.DomainListNode);
        const separator = SEPARATOR_SERIALIZATION_MAP$1.get(node.separator);
        if (isUndefined(separator)) {
            throw new Error(`Invalid separator: ${node.separator}`);
        }
        buffer.writeUint8(DomainListSerializationMap.Separator);
        buffer.writeUint8(separator);
        buffer.writeUint8(DomainListSerializationMap.Children);
        serializeListItems(node.children, buffer);
        if (!isUndefined(node.start)) {
            buffer.writeUint8(DomainListSerializationMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(DomainListSerializationMap.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Deserializes a modifier list node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(BinaryTypeMap.DomainListNode);
        node.type = ListNodeType.DomainList;
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case DomainListSerializationMap.Separator:
                    // eslint-disable-next-line max-len
                    node.separator = (SEPARATOR_DESERIALIZATION_MAP$1.get(buffer.readUint8()) ?? COMMA);
                    break;
                case DomainListSerializationMap.Children:
                    deserializeListItems(buffer, node.children = []);
                    break;
                case DomainListSerializationMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case DomainListSerializationMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}.`);
            }
            prop = buffer.readUint8();
        }
    }
}

/* eslint-disable no-param-reassign */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
var ModifierNodeSerializationMap;
(function (ModifierNodeSerializationMap) {
    ModifierNodeSerializationMap[ModifierNodeSerializationMap["Name"] = 1] = "Name";
    ModifierNodeSerializationMap[ModifierNodeSerializationMap["Value"] = 2] = "Value";
    ModifierNodeSerializationMap[ModifierNodeSerializationMap["Exception"] = 3] = "Exception";
    ModifierNodeSerializationMap[ModifierNodeSerializationMap["Start"] = 4] = "Start";
    ModifierNodeSerializationMap[ModifierNodeSerializationMap["End"] = 5] = "End";
})(ModifierNodeSerializationMap || (ModifierNodeSerializationMap = {}));
/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const FREQUENT_MODIFIERS_SERIALIZATION_MAP = new Map([
    ['_', 0],
    ['all', 1],
    ['app', 2],
    ['badfilter', 3],
    ['cname', 4],
    ['content', 5],
    ['cookie', 6],
    ['csp', 7],
    ['denyallow', 8],
    ['document', 9],
    ['doc', 10],
    ['domain', 11],
    ['from', 12],
    ['elemhide', 13],
    ['ehide', 14],
    ['empty', 15],
    ['first-party', 16],
    ['1p', 17],
    ['extension', 18],
    ['font', 19],
    ['genericblock', 20],
    ['generichide', 21],
    ['ghide', 22],
    ['header', 23],
    ['hls', 24],
    ['image', 25],
    ['important', 26],
    ['inline-font', 27],
    ['inline-script', 28],
    ['jsinject', 29],
    ['jsonprune', 30],
    ['match-case', 31],
    ['media', 32],
    ['method', 33],
    ['mp4', 34],
    ['network', 35],
    ['object-subrequest', 36],
    ['object', 37],
    ['other', 38],
    ['permissions', 39],
    ['ping', 40],
    ['popunder', 41],
    ['popup', 42],
    ['redirect-rule', 43],
    ['redirect', 44],
    ['rewrite', 45],
    ['referrerpolicy', 46],
    ['removeheader', 47],
    ['removeparam', 48],
    ['replace', 49],
    ['script', 50],
    ['specifichide', 51],
    ['shide', 52],
    ['stealth', 53],
    ['strict1p', 54],
    ['strict3p', 55],
    ['stylesheet', 56],
    ['css', 57],
    ['subdocument', 58],
    ['frame', 59],
    ['third-party', 60],
    ['3p', 61],
    ['to', 62],
    ['urlblock', 63],
    ['webrtc', 64],
    ['websocket', 65],
    ['xmlhttprequest', 66],
    ['xhr', 67],
    // TODO: add new modifiers here
]);
/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * @note Only 256 values can be represented this way.
 */
const FREQUENT_MODIFIERS_DESERIALIZATION_MAP = new Map(Array.from(FREQUENT_MODIFIERS_SERIALIZATION_MAP, ([key, value]) => [value, key]));
/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the binary schema version
 *
 * @note Only 256 values can be represented this way.
 */
const FREQUENT_REDIRECT_VALUES_SERIALIZATION_MAP = new Map([
    // AdGuard
    ['1x1-transparent.gif', 0],
    ['2x2-transparent.png', 1],
    ['3x2-transparent.png', 2],
    ['32x32-transparent.png', 3],
    ['amazon-apstag', 4],
    ['ati-smarttag', 5],
    ['didomi-loader', 6],
    ['click2load.html', 7],
    ['fingerprintjs2', 8],
    ['fingerprintjs3', 9],
    ['google-analytics', 10],
    ['google-analytics-ga', 11],
    ['googlesyndication-adsbygoogle', 12],
    ['googlesyndication-adsbygoogle', 13],
    ['googletagmanager-gtm', 14],
    ['googletagmanager-gtm', 15],
    ['googletagservices-gpt', 16],
    ['google-ima3', 17],
    ['gemius', 18],
    ['matomo', 19],
    ['metrika-yandex-watch', 20],
    ['metrika-yandex-tag', 21],
    ['naver-wcslog', 22],
    ['noeval', 23],
    ['noopcss', 24],
    ['noopframe', 25],
    ['noopjs', 26],
    ['noopjson', 27],
    ['nooptext', 28],
    ['noopmp3-0.1s', 29],
    ['noopmp4-1s', 30],
    ['noopvmap-1.0', 31],
    ['noopvast-2.0', 32],
    ['noopvast-3.0', 33],
    ['noopvast-4.0', 34],
    ['prebid', 35],
    ['pardot-1.0', 36],
    ['prevent-bab', 37],
    ['prevent-bab2', 38],
    ['prevent-fab-3.2.0', 39],
    ['prevent-fab-3.2.0', 40],
    ['prevent-popads-net', 41],
    ['scorecardresearch-beacon', 42],
    ['set-popads-dummy', 43],
    ['empty', 44],
    ['prebid-ads', 45],
    // empty slots for future use
    // uBlock Origin
    ['1x1.gif', 60],
    ['2x2.png', 61],
    ['3x2.png', 62],
    ['32x32.png', 63],
    ['amazon_apstag.js', 64],
    ['click2load.html', 65],
    ['fingerprint2.js', 66],
    ['fingerprint3.js', 67],
    ['google-analytics_analytics.js', 68],
    ['google-analytics_ga.js', 69],
    ['googlesyndication_adsbygoogle.js', 70],
    ['googlesyndication.com/adsbygoogle.js', 71],
    ['google-analytics_ga.js', 72],
    ['googletagmanager_gtm.js', 73],
    ['googletagservices_gpt.js', 74],
    ['google-ima.js', 75],
    ['noeval-silent.js', 76],
    ['noop.css', 77],
    ['noop.html', 78],
    ['noop.js', 79],
    ['noop.json', 80],
    ['noop.txt', 81],
    ['noop-0.1s.mp3', 82],
    ['noop-1s.mp4', 83],
    ['noop-vmap1.0.xml', 84],
    ['nobab.js', 85],
    ['nobab2.js', 86],
    ['nofab.js', 87],
    ['fuckadblock.js-3.2.0', 88],
    ['popads.js', 89],
    ['scorecardresearch_beacon.js', 90],
    ['popads-dummy.js', 91],
    ['empty', 92],
    ['prebid-ads.js', 93],
    // empty slots for future use
    // Adblock Plus
    ['1x1-transparent-gif', 105],
    ['2x2-transparent-png', 106],
    ['3x2-transparent-png', 107],
    ['32x32-transparent-png', 108],
    ['blank-css', 109],
    ['blank-html', 110],
    ['blank-js', 111],
    ['blank-text', 112],
    ['blank-mp3', 113],
    ['blank-mp4', 114],
    // empty slots for future use
    ['abp-resource:1x1-transparent-gif', 120],
    ['abp-resource:2x2-transparent-png', 121],
    ['abp-resource:3x2-transparent-png', 122],
    ['abp-resource:32x32-transparent-png', 123],
    ['abp-resource:blank-css', 124],
    ['abp-resource:blank-html', 125],
    ['abp-resource:blank-js', 126],
    ['abp-resource:blank-text', 127],
    ['abp-resource:blank-mp3', 128],
    ['abp-resource:blank-mp4', 129],
    // TODO: add other common values
]);
/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * @note This is a special map which allows us to use different value maps for different modifiers.
 */
const FREQUENT_VALUES_SERIALIZATION_MAPS = new Map([
    ['redirect', FREQUENT_REDIRECT_VALUES_SERIALIZATION_MAP],
    ['redirect-rule', FREQUENT_REDIRECT_VALUES_SERIALIZATION_MAP],
    ['rewrite', FREQUENT_REDIRECT_VALUES_SERIALIZATION_MAP],
    // TODO: Add other modifiers here
]);
/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
const FREQUENT_VALUES_DESERIALIZATION_MAPS = new Map(Array.from(FREQUENT_VALUES_SERIALIZATION_MAPS, ([modifier, valueMap]) => [modifier, new Map(Array.from(valueMap, ([key, value]) => [value, key]))]));
/**
 * `ModifierParser` is responsible for parsing modifiers.
 *
 * @example
 * `match-case`, `~third-party`, `domain=example.com|~example.org`
 */
class ModifierParser extends ParserBase {
    /**
     * Parses a modifier.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     *
     * @returns Parsed modifier
     * @throws An error if modifier name or value is empty.
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0) {
        let offset = 0;
        // Skip leading whitespace
        offset = StringUtils.skipWS(raw, offset);
        // Save the offset of the first character of the modifier (whole modifier)
        const modifierStart = offset;
        // Check if the modifier is an exception
        let exception = false;
        if (raw[offset] === NEGATION_MARKER) {
            offset += NEGATION_MARKER.length;
            exception = true;
        }
        // Skip whitespace after the exception marker (if any)
        offset = StringUtils.skipWS(raw, offset);
        // Save the offset of the first character of the modifier name
        const modifierNameStart = offset;
        // Find assignment operator
        const assignmentIndex = StringUtils.findNextUnescapedCharacter(raw, MODIFIER_ASSIGN_OPERATOR);
        // Find the end of the modifier
        const modifierEnd = Math.max(StringUtils.skipWSBack(raw) + 1, modifierNameStart);
        // Modifier name can't be empty
        if (modifierNameStart === modifierEnd) {
            throw new AdblockSyntaxError('Modifier name cannot be empty', baseOffset, baseOffset + raw.length);
        }
        let modifier;
        let value;
        // If there is no assignment operator, the whole modifier is the name
        // without a value
        if (assignmentIndex === -1) {
            modifier = ValueParser.parse(raw.slice(modifierNameStart, modifierEnd), options, baseOffset + modifierNameStart);
        }
        else {
            // If there is an assignment operator, first we need to find the
            // end of the modifier name, then we can parse the value
            const modifierNameEnd = StringUtils.skipWSBack(raw, assignmentIndex - 1) + 1;
            modifier = ValueParser.parse(raw.slice(modifierNameStart, modifierNameEnd), options, baseOffset + modifierNameStart);
            // Value can't be empty
            if (assignmentIndex + 1 === modifierEnd) {
                throw new AdblockSyntaxError('Modifier value cannot be empty', baseOffset, baseOffset + raw.length);
            }
            // Skip whitespace after the assignment operator
            const valueStart = StringUtils.skipWS(raw, assignmentIndex + MODIFIER_ASSIGN_OPERATOR.length);
            value = ValueParser.parse(raw.slice(valueStart, modifierEnd), options, baseOffset + valueStart);
        }
        const result = {
            type: 'Modifier',
            name: modifier,
            value,
            exception,
        };
        if (options.isLocIncluded) {
            result.start = baseOffset + modifierStart;
            result.end = baseOffset + modifierEnd;
        }
        return result;
    }
    /**
     * Generates a string from a modifier (serializes it).
     *
     * @param modifier Modifier to generate string from
     * @returns String representation of the modifier
     */
    static generate(modifier) {
        let result = EMPTY;
        if (modifier.exception) {
            result += NEGATION_MARKER;
        }
        result += modifier.name.value;
        if (modifier.value !== undefined) {
            result += MODIFIER_ASSIGN_OPERATOR;
            result += modifier.value.value;
        }
        return result;
    }
    /**
     * Serializes a modifier node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node, buffer) {
        buffer.writeUint8(BinaryTypeMap.ModifierNode);
        buffer.writeUint8(ModifierNodeSerializationMap.Name);
        ValueParser.serialize(node.name, buffer, FREQUENT_MODIFIERS_SERIALIZATION_MAP);
        if (!isUndefined(node.value)) {
            buffer.writeUint8(ModifierNodeSerializationMap.Value);
            ValueParser.serialize(node.value, buffer, FREQUENT_VALUES_SERIALIZATION_MAPS.get(node.name.value));
        }
        buffer.writeUint8(ModifierNodeSerializationMap.Exception);
        buffer.writeUint8(node.exception ? 1 : 0);
        if (!isUndefined(node.start)) {
            buffer.writeUint8(ModifierNodeSerializationMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(ModifierNodeSerializationMap.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Deserializes a modifier node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(BinaryTypeMap.ModifierNode);
        node.type = 'Modifier';
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case ModifierNodeSerializationMap.Name:
                    ValueParser.deserialize(buffer, node.name = {}, FREQUENT_MODIFIERS_DESERIALIZATION_MAP);
                    break;
                case ModifierNodeSerializationMap.Value:
                    if (node.name) {
                        // eslint-disable-next-line max-len
                        ValueParser.deserialize(buffer, node.value = {}, FREQUENT_VALUES_DESERIALIZATION_MAPS.get(node.name.value));
                    }
                    else {
                        ValueParser.deserialize(buffer, node.value = {});
                    }
                    break;
                case ModifierNodeSerializationMap.Exception:
                    node.exception = buffer.readUint8() === 1;
                    break;
                case ModifierNodeSerializationMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case ModifierNodeSerializationMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}.`);
            }
            prop = buffer.readUint8();
        }
    }
}

/* eslint-disable no-param-reassign */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
var ModifierListNodeSerializationMap;
(function (ModifierListNodeSerializationMap) {
    ModifierListNodeSerializationMap[ModifierListNodeSerializationMap["Children"] = 1] = "Children";
    ModifierListNodeSerializationMap[ModifierListNodeSerializationMap["Start"] = 2] = "Start";
    ModifierListNodeSerializationMap[ModifierListNodeSerializationMap["End"] = 3] = "End";
})(ModifierListNodeSerializationMap || (ModifierListNodeSerializationMap = {}));
/**
 * `ModifierListParser` is responsible for parsing modifier lists. Please note that the name is not
 * uniform, "modifiers" are also known as "options".
 *
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules-modifiers}
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#non-basic-rules-modifiers}
 * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#options}
 */
class ModifierListParser extends ParserBase {
    /**
     * Parses the cosmetic rule modifiers, eg. `third-party,domain=example.com|~example.org`.
     *
     * _Note:_ you should remove `$` separator before passing the raw modifiers to this function,
     *  or it will be parsed in the first modifier.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Parsed modifiers interface
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0) {
        const result = {
            type: 'ModifierList',
            children: [],
        };
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        let offset = StringUtils.skipWS(raw);
        let separatorIndex = -1;
        // Split modifiers by unescaped commas
        while (offset < raw.length) {
            // Skip whitespace before the modifier
            offset = StringUtils.skipWS(raw, offset);
            const modifierStart = offset;
            // Find the index of the first unescaped comma
            separatorIndex = StringUtils.findNextUnescapedCharacter(raw, MODIFIERS_SEPARATOR, offset);
            const modifierEnd = separatorIndex === -1
                ? raw.length
                : StringUtils.skipWSBack(raw, separatorIndex - 1) + 1;
            // Parse the modifier
            const modifier = ModifierParser.parse(raw.slice(modifierStart, modifierEnd), options, baseOffset + modifierStart);
            result.children.push(modifier);
            // Increment the offset to the next modifier (or the end of the string)
            offset = separatorIndex === -1 ? raw.length : separatorIndex + 1;
        }
        // Check if there are any modifiers after the last separator
        if (separatorIndex !== -1) {
            const modifierStart = StringUtils.skipWS(raw, separatorIndex + 1);
            result.children.push(ModifierParser.parse(raw.slice(modifierStart, raw.length), options, baseOffset + modifierStart));
        }
        return result;
    }
    /**
     * Converts a modifier list AST to a string.
     *
     * @param ast Modifier list AST
     * @returns Raw string
     */
    static generate(ast) {
        const result = ast.children
            .map(ModifierParser.generate)
            .join(MODIFIERS_SEPARATOR);
        return result;
    }
    /**
     * Serializes a modifier list node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node, buffer) {
        buffer.writeUint8(BinaryTypeMap.ModifierListNode);
        const count = node.children.length;
        if (count) {
            buffer.writeUint8(ModifierListNodeSerializationMap.Children);
            // note: we store the count, because re-construction of the array is faster if we know the length
            if (count > UINT16_MAX) {
                throw new Error(`Too many modifiers: ${count}, the limit is ${UINT16_MAX}`);
            }
            buffer.writeUint16(count);
            for (let i = 0; i < count; i += 1) {
                ModifierParser.serialize(node.children[i], buffer);
            }
        }
        if (!isUndefined(node.start)) {
            buffer.writeUint8(ModifierListNodeSerializationMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(ModifierListNodeSerializationMap.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Deserializes a modifier list node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(BinaryTypeMap.ModifierListNode);
        node.type = 'ModifierList';
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case ModifierListNodeSerializationMap.Children:
                    node.children = new Array(buffer.readUint16());
                    // read children
                    for (let i = 0; i < node.children.length; i += 1) {
                        ModifierParser.deserialize(buffer, node.children[i] = {});
                    }
                    break;
                case ModifierListNodeSerializationMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case ModifierListNodeSerializationMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}.`);
            }
            prop = buffer.readUint8();
        }
    }
}

/**
 * @file Error messages for CSS token stream and balancer.
 */
const END_OF_INPUT = 'end of input';
const ERROR_MESSAGES$6 = {
    EXPECTED_ANY_TOKEN_BUT_GOT: "Expected a token, but got '%s'",
    EXPECTED_TOKEN_BUT_GOT: "Expected '%s', but got '%s'",
    EXPECTED_TOKEN_WITH_BALANCE_BUT_GOT: "Expected '%s' with balance '%d', but got '%d'",
    EXPECTED_TOKEN_WITH_VALUE_BUT_GOT: "Expected '%s' with value '%s', but got '%s'",
};

/**
 * @file Tokenizer helpers for balanced pairs.
 */
/**
 * Map of opening tokens to their corresponding closing tokens.
 */
const standardTokenPairs = new Map([
    [TokenType$1.Function, TokenType$1.CloseParenthesis],
    [TokenType$1.OpenParenthesis, TokenType$1.CloseParenthesis],
    [TokenType$1.OpenSquareBracket, TokenType$1.CloseSquareBracket],
    [TokenType$1.OpenCurlyBracket, TokenType$1.CloseCurlyBracket],
]);
/**
 * Map of opening tokens to their corresponding closing tokens just for function calls. This makes possible a more
 * lightweight and tolerant check for balanced pairs in some cases.
 */
const functionTokenPairs = new Map([
    [TokenType$1.Function, TokenType$1.CloseParenthesis],
    [TokenType$1.OpenParenthesis, TokenType$1.CloseParenthesis],
]);
/**
 * Helper function to tokenize and ensure balanced pairs.
 *
 * @param raw Raw CSS string to tokenize
 * @param onToken Callback which will be invoked for each token, extended with a `balance` parameter
 * @param onError Error callback which is called when a parsing error is found (optional)
 * @param functionHandlers Custom function handlers (optional)
 * @param tokenPairs Map of opening tokens to their corresponding closing tokens
 * @throws If the input is not balanced
 * @todo Consider adding a `tolerant` flag if error throwing seems too aggressive in the future
 */
const tokenizeWithBalancedPairs = (raw, onToken, onError = () => { }, functionHandlers, tokenPairs = standardTokenPairs) => {
    const stack = [];
    const values = new Set(tokenPairs.values());
    tokenizeExtended(raw, (type, start, end, props) => {
        if (tokenPairs.has(type)) {
            // If the token is an opening token, push its corresponding closing token to the stack.
            // It is safe to use non-null assertion here, because we have checked that the token exists in the map.
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            stack.push(tokenPairs.get(type));
        }
        else if (values.has(type)) {
            // If the token is a closing token, check if it matches the last opening token, and if so, pop it.
            if (stack[stack.length - 1] === type) {
                stack.pop();
            }
            else {
                throw new AdblockSyntaxError(sprintf(ERROR_MESSAGES$6.EXPECTED_TOKEN_BUT_GOT, getFormattedTokenName(stack[stack.length - 1]), getFormattedTokenName(type)), start, raw.length);
            }
        }
        onToken(type, start, end, props, stack.length);
    }, onError, functionHandlers);
    // If the stack is not empty, then there are some opening tokens that were not closed.
    if (stack.length > 0) {
        throw new AdblockSyntaxError(sprintf(ERROR_MESSAGES$6.EXPECTED_TOKEN_BUT_GOT, getFormattedTokenName(stack[stack.length - 1]), END_OF_INPUT), raw.length - 1, raw.length);
    }
};
/**
 * Tokenize and ensure balanced pairs for standard CSS.
 *
 * @param raw Raw CSS string to tokenize
 * @param onToken Callback which will be invoked for each token, extended with a `balance` parameter
 * @param onError Error callback which is called when a parsing error is found (optional)
 * @param functionHandlers Custom function handlers (optional)
 * @throws If the input is not balanced
 */
const tokenizeBalanced = (raw, onToken, onError = () => { }, functionHandlers) => {
    tokenizeWithBalancedPairs(raw, onToken, onError, functionHandlers);
};
/**
 * Tokenize and ensure balanced pairs for function calls.
 *
 * @param raw Raw CSS string to tokenize
 * @param onToken Callback which will be invoked for each token, extended with a `balance` parameter
 * @param onError Error callback which is called when a parsing error is found (optional)
 * @param functionHandlers Custom function handlers (optional)
 * @throws If the input is not balanced
 */
const tokenizeFnBalanced = (raw, onToken, onError = () => { }, functionHandlers) => {
    tokenizeWithBalancedPairs(raw, onToken, onError, functionHandlers, functionTokenPairs);
};

/**
 * @file Parser for special uBO selectors.
 */
/**
 * Possible error messages for uBO selectors. Formatted with {@link sprintf}.
 */
const ERROR_MESSAGES$5 = {
    DUPLICATED_UBO_MODIFIER: "uBO modifier '%s' cannot be used more than once",
    EXPECTED_BUT_GOT_BEFORE: "Expected '%s' but got '%s' before '%s'",
    // eslint-disable-next-line max-len
    NEGATED_UBO_MODIFIER_CANNOT_BE_FOLLOWED_BY: "Negated uBO modifier '%s' cannot be followed by anything else than a closing parenthesis or a whitespace",
    NEGATED_UBO_MODIFIER_CANNOT_BE_PRECEDED_BY: "Negated uBO modifier '%s' cannot be preceded by '%s'",
    PSEUDO_CANNOT_BE_NESTED: "uBO modifier '%s' cannot be nested inside '%s', only '%s' is allowed as a wrapper",
    UBO_MODIFIER_CANNOT_BE_NESTED: "uBO modifier '%s' cannot be nested",
    UBO_STYLE_CANNOT_BE_FOLLOWED: 'uBO style injection cannot be followed by anything else than a whitespace',
};
/**
 * Dummy parameter for uBO modifiers in error messages.
 */
const DUMMY_PARAM = '...';
/**
 * Known uBO modifiers.
 */
var UboPseudoName;
(function (UboPseudoName) {
    UboPseudoName["MatchesMedia"] = "matches-media";
    UboPseudoName["MatchesPath"] = "matches-path";
    UboPseudoName["Remove"] = "remove";
    UboPseudoName["Style"] = "style";
})(UboPseudoName || (UboPseudoName = {}));
/**
 * Set of known uBO modifiers.
 *
 * @note We use `string` instead of `UboPseudoName` because we use this set for checking if a modifier is a known uBO,
 * and an unknown sequence is just a string.
 */
const KNOWN_UBO_MODIFIERS = new Set([
    UboPseudoName.MatchesMedia,
    UboPseudoName.MatchesPath,
    UboPseudoName.Remove,
    UboPseudoName.Style,
]);
/**
 * Helper function to check if the given selector has any uBO modifier. This function should be fast, because it's used
 * in the hot path of the parser.
 *
 * @param raw Raw selector string.
 * @returns `true` if the selector has any uBO modifier, `false` otherwise.
 */
const hasAnyUboModifier = (raw) => {
    // Find the first colon
    let colonIndex = raw.indexOf(COLON);
    while (colonIndex !== -1) {
        // Find next opening parenthesis
        const openingParenthesisIndex = raw.indexOf(OPEN_PARENTHESIS, colonIndex + 1);
        // If there is no opening parenthesis, then the selector doesn't contain any uBO modifier
        if (openingParenthesisIndex === -1) {
            return false;
        }
        // Check if the modifier is a known uBO modifier
        if (KNOWN_UBO_MODIFIERS.has(raw.slice(colonIndex + 1, openingParenthesisIndex))) {
            return true;
        }
        // Find next colon
        colonIndex = raw.indexOf(COLON, openingParenthesisIndex + 1);
    }
    return false;
};
/**
 * A simple helper function to format a pseudo name for error messages.
 *
 * @param name Pseudo name.
 * @param wrapper Wrapper pseudo name (eg. `not`) (optional, defaults to `undefined`).
 * @returns Formatted pseudo name.
 * @example
 * ```ts
 * formatPseudoName('matches-path', 'not'); // => ':not(:matches-path(...))'
 * formatPseudoName('matches-media'); // => ':matches-media(...)'
 * ```
 */
const formatPseudoName = (name, wrapper) => {
    const result = [];
    if (wrapper) {
        result.push(COLON, wrapper, OPEN_PARENTHESIS);
    }
    result.push(COLON, name, OPEN_PARENTHESIS, DUMMY_PARAM, CLOSE_PARENTHESIS);
    if (wrapper) {
        result.push(CLOSE_PARENTHESIS);
    }
    return result.join(EMPTY);
};
/**
 * Parser for uBO selectors.
 */
class UboSelectorParser extends ParserBase {
    /**
     * Parses a uBO selector list, eg. `div:matches-path(/path)`.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     *
     * @returns Parsed uBO selector {@link UboSelector}.
     * @throws An {@link AdblockSyntaxError} if the selector list is syntactically invalid.
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0) {
        // Prepare helper variables
        const modifiers = {
            type: 'ModifierList',
            children: [],
        };
        if (options.isLocIncluded) {
            modifiers.start = baseOffset;
            modifiers.end = baseOffset + raw.length;
        }
        // Do not perform any parsing if the selector doesn't contain any uBO modifier
        // Parsing is a relatively expensive operation, but this check is cheap, so we can avoid unnecessary work
        // TODO: Move this check to the cosmetic parser (adjustable syntaxes - if uBO syntax is disabled, then we don't
        // need to check for uBO modifiers)
        if (!hasAnyUboModifier(raw)) {
            const selector = {
                type: 'Value',
                value: raw,
            };
            if (options.isLocIncluded) {
                selector.start = baseOffset;
                selector.end = baseOffset + raw.length;
            }
            const result = {
                type: 'UboSelector',
                selector,
                modifiers,
            };
            if (options.isLocIncluded) {
                result.start = baseOffset;
                result.end = baseOffset + raw.length;
            }
            return result;
        }
        // Simple way to check if a modifier is already processed to avoid duplicate modifiers
        const processedModifiers = new Set();
        // We need to keep track of the tokens for handling negations properly
        const tokens = [];
        // This array is used to mark the character slots in the selector string that are occupied by uBO modifiers
        const uboIndexes = new Array(raw.length);
        const uboModifierStack = [];
        let i = 0;
        // Helper function to stack a uBO modifier
        const stackModifier = (modifier) => {
            if (processedModifiers.has(modifier.name)) {
                throw new AdblockSyntaxError(sprintf(ERROR_MESSAGES$5.DUPLICATED_UBO_MODIFIER, formatPseudoName(modifier.name)), baseOffset + modifier.modifierStart, baseOffset + raw.length);
            }
            uboModifierStack.push(modifier);
        };
        // Tokenize the selector, calculate the balance
        tokenizeFnBalanced(raw, (type, start, end, _, balance) => {
            // Special case: style injection (`:style(...)` and `:remove()`) can only be used at the end of the
            // selector, like
            //  - `div:style(...)`,
            //  - `div:matches-media(...):style(...)`,
            //  - `div:remove()`,
            // etc.
            //
            // But not like
            //  - `:style(...) div`,
            //  - `:matches-media(...):style(...) div`,
            //  - `:remove() div`,
            // etc.
            //
            // The one exception is whitespace, which is allowed after style injection, like
            //  - `div:style(...) `,
            //  - `div:matches-media(...):style(...) `,
            //  - `div:remove() `,
            // etc.
            if ((processedModifiers.has(UboPseudoName.Style)
                || processedModifiers.has(UboPseudoName.Remove))
                && type !== TokenType$1.Whitespace) {
                throw new AdblockSyntaxError(ERROR_MESSAGES$5.UBO_STYLE_CANNOT_BE_FOLLOWED, baseOffset + start, baseOffset + raw.length);
            }
            // Check for pseudo classes (colon followed by a function)
            if (tokens[i - 1]?.type === TokenType$1.Colon && type === TokenType$1.Function) {
                // Since closing parenthesis is always included in the function token, but we only need the function
                // name, we need to cut off the last character, this is why we use `end - 1` here
                const fn = raw.slice(start, end - 1);
                // Check if the pseudo class is a known uBO modifier
                if (KNOWN_UBO_MODIFIERS.has(fn)) {
                    // Generally, uBO modifiers cannot be nested, like
                    //  - `:any(:matches-media(...))`,
                    //  - `:matches-media(:matches-media(...))`,
                    //  - `:not(style(...))`,
                    //  etc.
                    if (balance > 1) {
                        // However, we have one exception: `:matches-path()` can be nested inside `:not()`s, like:
                        //  - `:not(:matches-path(...))`,
                        //  - `:not(:not(:matches-path(...)))`,
                        //  etc.
                        //
                        // But it can't be nested inside any other pseudo class, like:
                        //  - `:anything(:matches-path(...))`,
                        //  etc.
                        //
                        // Moreover, :not() can't contain any other data, like
                        //  - `:not(div:matches-path(...))`,
                        //  - `:not(:matches-path(...):matches-path(...))`,
                        //  - `:not(:matches-path(...) div)`,
                        // etc.
                        if (fn === UboPseudoName.MatchesPath) {
                            if (uboModifierStack.length > 0) {
                                throw new AdblockSyntaxError(sprintf(ERROR_MESSAGES$5.PSEUDO_CANNOT_BE_NESTED, formatPseudoName(UboPseudoName.MatchesPath), formatPseudoName(uboModifierStack[uboModifierStack.length - 1].name), formatPseudoName(CSS_NOT_PSEUDO)), baseOffset + start - 1, baseOffset + raw.length);
                            }
                            let isException = false;
                            let modifierBalance = balance;
                            let modifierStart = start;
                            for (let j = i - 1; j >= 0; j -= 1) {
                                // If we have reached the root level, then we should check if the `not` function is
                                // preceded by a colon (which means that it's a pseudo class)
                                if (tokens[j].balance === 0) {
                                    modifierStart = tokens[j].start;
                                    modifierBalance = tokens[j].balance;
                                    break;
                                }
                                else if (tokens[j].type === TokenType$1.Colon
                                    || tokens[j].type === TokenType$1.Whitespace) {
                                    continue;
                                }
                                else if (tokens[j].type === TokenType$1.Function) {
                                    const wrapperFnName = raw.slice(tokens[j].start, tokens[j].end - 1);
                                    if (wrapperFnName !== CSS_NOT_PSEUDO) {
                                        throw new AdblockSyntaxError(sprintf(ERROR_MESSAGES$5.PSEUDO_CANNOT_BE_NESTED, formatPseudoName(UboPseudoName.MatchesPath), formatPseudoName(wrapperFnName), formatPseudoName(CSS_NOT_PSEUDO)), baseOffset + tokens[j].start - 1, baseOffset + raw.length);
                                    }
                                    if (tokens[j - 1]?.type !== TokenType$1.Colon) {
                                        const got = tokens[j - 1]?.type
                                            ? getFormattedTokenName(tokens[j - 1]?.type)
                                            : 'nothing';
                                        throw new AdblockSyntaxError(sprintf(ERROR_MESSAGES$5.EXPECTED_BUT_GOT_BEFORE, getFormattedTokenName(TokenType$1.Colon), got, formatPseudoName(UboPseudoName.MatchesPath, CSS_NOT_PSEUDO)), 
                                        // eslint-disable-next-line no-unsafe-optional-chaining
                                        baseOffset + tokens[j - 1]?.start || 0, baseOffset + raw.length);
                                    }
                                    isException = !isException;
                                    continue;
                                }
                                else {
                                    throw new AdblockSyntaxError(sprintf(ERROR_MESSAGES$5.NEGATED_UBO_MODIFIER_CANNOT_BE_PRECEDED_BY, formatPseudoName(UboPseudoName.MatchesPath), getFormattedTokenName(tokens[j].type)), baseOffset + tokens[j].start, baseOffset + raw.length);
                                }
                            }
                            stackModifier({
                                name: fn,
                                modifierStart,
                                modifierBalance,
                                nameStart: start,
                                nameEnd: end - 1, // ignore opening parenthesis
                                valueStart: end,
                                valueBalance: balance,
                                isException,
                            });
                        }
                        else {
                            throw new AdblockSyntaxError(sprintf(ERROR_MESSAGES$5.UBO_MODIFIER_CANNOT_BE_NESTED, formatPseudoName(fn)), baseOffset + start - 1, baseOffset + raw.length);
                        }
                    }
                    else {
                        stackModifier({
                            name: fn,
                            modifierStart: start - 1, // Include the colon
                            modifierBalance: balance,
                            nameStart: start,
                            nameEnd: end - 1, // ignore opening parenthesis
                            valueStart: end,
                            valueBalance: balance,
                            isException: false,
                        });
                    }
                }
            }
            else {
                // Get the last stacked modifier
                const lastStackedModifier = uboModifierStack[uboModifierStack.length - 1];
                // Do not allow any other token after `:matches-path(...)` inside `:not(...)`
                if (lastStackedModifier?.name === UboPseudoName.MatchesPath && lastStackedModifier?.isException) {
                    if (!(type === TokenType$1.CloseParenthesis || type === TokenType$1.Whitespace)
                        && balance < lastStackedModifier.valueBalance) {
                        throw new AdblockSyntaxError(sprintf(ERROR_MESSAGES$5.NEGATED_UBO_MODIFIER_CANNOT_BE_FOLLOWED_BY, formatPseudoName(UboPseudoName.MatchesPath), getFormattedTokenName(type)), baseOffset + start, baseOffset + raw.length);
                    }
                }
                // If we have reached a closing parenthesis, then we should check if it closes the last stacked modifier
                // and if so, pop it from the stack
                if (type === TokenType$1.CloseParenthesis && lastStackedModifier) {
                    if (balance === Math.max(0, lastStackedModifier.valueBalance - 1)) {
                        lastStackedModifier.valueEnd = start;
                    }
                    if (balance === Math.max(0, lastStackedModifier.modifierBalance - 1)) {
                        const modifierName = {
                            type: 'Value',
                            value: lastStackedModifier.name,
                        };
                        if (options.isLocIncluded) {
                            // TODO: Refactor
                            modifierName.start = baseOffset + lastStackedModifier.nameStart;
                            modifierName.end = baseOffset + lastStackedModifier.nameEnd;
                        }
                        const value = {
                            type: 'Value',
                            value: raw.slice(lastStackedModifier.valueStart, lastStackedModifier.valueEnd),
                        };
                        if (options.isLocIncluded) {
                            value.start = baseOffset + lastStackedModifier.valueStart;
                            // It's safe to use `!` here, because we determined the value end index in the
                            // previous `if` statement
                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                            value.end = baseOffset + lastStackedModifier.valueEnd;
                        }
                        const modifier = {
                            type: 'Modifier',
                            name: modifierName,
                            value,
                            exception: lastStackedModifier.isException,
                        };
                        if (options.isLocIncluded) {
                            modifier.start = baseOffset + lastStackedModifier.modifierStart;
                            modifier.end = baseOffset + end;
                        }
                        modifiers.children.push(modifier);
                        processedModifiers.add(lastStackedModifier.name);
                        uboModifierStack.pop();
                        // Mark the character slots in the selector string that are occupied by uBO modifiers
                        uboIndexes.fill(true, lastStackedModifier.modifierStart, end);
                    }
                }
            }
            // Save the token to the history and increase the index
            tokens.push({
                type,
                start,
                end,
                balance,
            });
            i += 1;
        });
        const selector = {
            type: 'Value',
            value: raw
                .split(EMPTY)
                .map((char, p) => (uboIndexes[p] ? EMPTY : char))
                .join(EMPTY)
                .trim(),
        };
        if (options.isLocIncluded) {
            selector.start = baseOffset;
            selector.end = baseOffset + raw.length;
        }
        const result = {
            type: 'UboSelector',
            selector,
            modifiers,
        };
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        return result;
    }
    /**
     * Serializes a uBO selector node to a string.
     *
     * @param node UBO selector node
     * @returns Raw string
     */
    static generate(node) {
        const prefix = []; // List of leading modifiers
        const suffix = []; // List of trailing modifiers, typically style injection
        if (node.modifiers) {
            for (const modifier of node.modifiers.children) {
                switch (modifier.name.value) {
                    case UboPseudoName.Remove:
                    case UboPseudoName.Style:
                        // eslint-disable-next-line max-len
                        suffix.push(COLON, modifier.name.value, OPEN_PARENTHESIS, modifier.value?.value || EMPTY, CLOSE_PARENTHESIS);
                        break;
                    default:
                        // Wrap exceptions in `:not()`
                        if (modifier.exception) {
                            prefix.push(COLON, CSS_NOT_PSEUDO, OPEN_PARENTHESIS);
                        }
                        // :modifier-name(value)
                        // eslint-disable-next-line max-len
                        prefix.push(COLON, modifier.name.value, OPEN_PARENTHESIS, modifier.value?.value || EMPTY, CLOSE_PARENTHESIS);
                        // Close the `:not()` if we are in an exception
                        if (modifier.exception) {
                            prefix.push(CLOSE_PARENTHESIS);
                        }
                        break;
                }
            }
        }
        // Prepare the result
        let result = EMPTY;
        if (prefix.length > 0) {
            result += prefix.join(EMPTY);
            // Add a space between the selector and the leading modifier(s)
            if (node.selector?.value) {
                result += SPACE;
            }
        }
        result += node.selector?.value || EMPTY;
        result += suffix.join(EMPTY);
        return result;
    }
}

/**
 * @file Known CSS elements and attributes.
 * TODO: Implement a compatibility table for Extended CSS
 */
/**
 * Legacy Extended CSS attribute prefix.
 *
 * @example
 * ```css
 * [-ext-<name>=...]
 * ```
 */
const LEGACY_EXT_CSS_ATTRIBUTE_PREFIX = '-ext-';
/**
 * ABP Extended CSS prefix.
 *
 * @example
 * ```css
 * [-abp-<name>=...]
 * -abp-<name>(...)
 * ```
 */
const ABP_EXT_CSS_PREFIX = '-abp';
/**
 * Known _strict_ Extended CSS pseudo-classes. Please, keep this list sorted.
 * Strict means that these pseudo-classes are not supported by any browser natively,
 * and they always require Extended CSS libraries to work.
 */
const EXT_CSS_PSEUDO_CLASSES_STRICT = new Set([
    // AdGuard
    // https://github.com/AdguardTeam/ExtendedCss
    'contains',
    'if-not',
    'matches-attr',
    'matches-css',
    'matches-property',
    'nth-ancestor',
    'remove',
    'upward',
    'xpath',
    // uBlock Origin
    // https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#procedural-cosmetic-filters
    'has-text',
    'matches-css-after',
    'matches-css-before',
    'matches-path',
    'min-text-length',
    'watch-attr',
    // Adblock Plus
    // https://help.eyeo.com/adblockplus/how-to-write-filters#elemhide-emulation
    '-abp-contains',
    '-abp-has',
    '-abp-properties',
]);
/**
 * _ALL_ known Extended CSS pseudo-classes. Please, keep this list sorted.
 * It includes strict pseudo-classes and additional pseudo-classes that may be
 * supported by some browsers natively.
 */
const EXT_CSS_PSEUDO_CLASSES = new Set([
    ...EXT_CSS_PSEUDO_CLASSES_STRICT,
    /**
     * https://developer.mozilla.org/en-US/docs/Web/CSS/:has
     */
    'has',
    /**
     * https://developer.mozilla.org/en-US/docs/Web/CSS/:is
     */
    'is',
]);
/**
 * Known legacy Extended CSS attributes. These attributes are deprecated and
 * should be replaced with the corresponding pseudo-classes. In a long term,
 * these attributes will be COMPLETELY removed from the Extended CSS syntax.
 *
 * Please, keep this list sorted.
 */
const EXT_CSS_LEGACY_ATTRIBUTES = new Set([
    // AdGuard
    '-ext-contains',
    '-ext-has',
    '-ext-if-not',
    '-ext-is',
    '-ext-matches-attr',
    '-ext-matches-css',
    '-ext-matches-property',
    '-ext-nth-ancestor',
    '-ext-remove',
    '-ext-upward',
    '-ext-xpath',
    // uBlock Origin
    '-ext-has-text',
    '-ext-matches-css-after',
    '-ext-matches-css-before',
    '-ext-matches-path',
    '-ext-min-text-length',
    '-ext-watch-attr',
    // Adblock Plus
    '-ext-abp-contains',
    '-ext-abp-has',
    '-ext-abp-properties',
]);
/**
 * Known CSS functions that aren't allowed in CSS injection rules, because they
 * able to load external resources. Please, keep this list sorted.
 */
const FORBIDDEN_CSS_FUNCTIONS = new Set([
    // https://developer.mozilla.org/en-US/docs/Web/CSS/cross-fade
    '-webkit-cross-fade',
    'cross-fade',
    // https://developer.mozilla.org/en-US/docs/Web/CSS/image
    'image',
    // https://developer.mozilla.org/en-US/docs/Web/CSS/image-set
    '-webkit-image-set',
    'image-set',
    // https://developer.mozilla.org/en-US/docs/Web/CSS/url
    'url',
]);

/**
 * @file CSS token stream.
 */
/**
 * Represents a stream of CSS tokens.
 */
class CssTokenStream {
    /**
     * The tokens in the stream.
     */
    tokens = [];
    /**
     * The source string.
     */
    source = EMPTY;
    /**
     * The current index in the stream.
     */
    index = 0;
    /**
     * The base offset of the source string.
     */
    baseOffset;
    /**
     * Initializes a new instance of the TokenStream class.
     *
     * @param source The source string to tokenize.
     * @param baseOffset The base offset of the source string.
     */
    constructor(source, baseOffset = 0) {
        this.source = source;
        // Tokenize the source string with the CSS tokenizer and add balance level to each token.
        // 'onToken' callback is invoked when a token is found in the source string.
        // Passed parameters:
        // - type: type of the token
        // - start: start index of the token
        // - end: end index of the token
        // - props: additional properties of the token, if any (we don't use it here, this is why we use underscore)
        // - balance: balance level of the token
        tokenizeBalanced(source, (type, start, end, _, balance) => {
            this.tokens.push({
                type,
                start,
                end,
                balance,
            });
        });
        this.index = 0;
        this.baseOffset = baseOffset;
    }
    /**
     * Gets the number of tokens in the stream.
     *
     * @returns The number of tokens in the stream.
     */
    get length() {
        return this.tokens.length;
    }
    /**
     * Checks if the end of the token stream is reached.
     *
     * @returns True if the end of the stream is reached, otherwise false.
     */
    isEof() {
        return this.index >= this.tokens.length;
    }
    /**
     * Gets the token at the specified index.
     *
     * @param index The index of the token to retrieve.
     * @returns The token at the specified index or undefined if the index is out of bounds.
     */
    get(index = this.index) {
        return this.tokens[index];
    }
    /**
     * Gets the token at the specified index or throws if no token is found at the specified index.
     *
     * @param index The index of the token to retrieve.
     * @returns The token at the specified index or undefined if the index is out of bounds.
     * @throws If no token is found at the specified index.
     */
    getOrFail(index = this.index) {
        const token = this.get(index);
        if (!token) {
            throw new AdblockSyntaxError(sprintf(ERROR_MESSAGES$6.EXPECTED_ANY_TOKEN_BUT_GOT, END_OF_INPUT), this.baseOffset + this.source.length - 1, this.baseOffset + this.source.length);
        }
        return token;
    }
    /**
     * Gets the source fragment of the token at the specified index.
     *
     * @param index The index of the token to retrieve the fragment for.
     * @returns The source fragment of the token or an empty string if the index is out of bounds.
     */
    fragment(index = this.index) {
        const token = this.get(index);
        if (token) {
            return this.source.slice(token.start, token.end);
        }
        return EMPTY;
    }
    /**
     * Moves the index to the next token and returns it.
     *
     * @returns The next token or undefined if the end of the stream is reached.
     */
    advance() {
        if (this.isEof()) {
            return undefined;
        }
        this.index += 1;
        return this.tokens[this.index];
    }
    /**
     * Looks ahead in the stream without changing the index.
     *
     * @param index The relative index to look ahead to, starting from the current index.
     * @returns The next token or undefined if the end of the stream is reached.
     */
    lookahead(index = 1) {
        return this.tokens[this.index + Math.max(1, index)];
    }
    /**
     * Looks behind in the stream without changing the index.
     *
     * @param index The relative index to look behind to, starting from the current index.
     * @returns The previous token or undefined if the current token is the first in the stream.
     */
    lookbehind(index = 1) {
        if (this.index === 0) {
            return undefined;
        }
        return this.tokens[this.index - Math.max(1, index)];
    }
    /**
     * Looks behind in the stream for the previous non-whitespace token without changing the index.
     *
     * @returns The previous non-whitespace token or undefined if it could not be found.
     */
    lookbehindForNonWs() {
        for (let i = this.index - 1; i >= 0; i -= 1) {
            if (this.tokens[i].type !== TokenType$1.Whitespace) {
                return this.tokens[i];
            }
        }
        return undefined;
    }
    /**
     * Skips whitespace tokens in the stream.
     */
    skipWhitespace() {
        while (this.get()?.type === TokenType$1.Whitespace) {
            this.index += 1;
        }
    }
    /**
     * Skips tokens until the current balance level is reached.
     *
     * @returns The number of tokens skipped.
     */
    skipUntilBalanced() {
        if (this.isEof()) {
            return 0;
        }
        // It is safe to use ! here, because we check for EOF above
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const currentBalance = this.get().balance;
        // If the current balance is 0, do nothing
        if (currentBalance === 0) {
            return 0;
        }
        // Otherwise, skip tokens until the balance is the current balance - 1
        let skipped = 0;
        while (!this.isEof() && this.get()?.balance !== currentBalance - 1) {
            this.index += 1;
            skipped += 1;
        }
        return skipped;
    }
    /**
     * Skips tokens until a token with the specified type or the end of the stream is reached.
     *
     * @param type The type of token to skip until.
     * @param balance The balance level of the token to skip until.
     * @returns The number of tokens skipped.
     */
    skipUntil(type, balance) {
        let skipped = 0;
        while (!this.isEof()
            && (this.get()?.type !== type || (balance !== undefined && this.get()?.balance !== balance))) {
            this.index += 1;
            skipped += 1;
        }
        return skipped;
    }
    /**
     * Skips tokens until a token with the specified type or the end of the stream is reached. This is an extended
     * version of skipUntil that also returns the number of tokens skipped without calculating leading and trailing
     * whitespace tokens.
     *
     * @param type The type of token to skip until.
     * @param balance The balance level of the token to skip until.
     * @returns An array containing the number of tokens skipped and the number of tokens skipped without leading and
     * trailing whitespace tokens.
     */
    skipUntilExt(type, balance) {
        let i = this.index;
        let firstNonWsToken = -1; // -1 means no non-whitespace token found yet
        let lastNonWsToken = -1; // -1 means no non-whitespace token found yet
        while (i < this.tokens.length) {
            const currentToken = this.tokens[i];
            if (currentToken.type === TokenType$1.Whitespace) {
                i += 1;
                continue;
            }
            else if (currentToken.type === type && currentToken.balance === balance) {
                break;
            }
            if (firstNonWsToken === -1) {
                firstNonWsToken = i;
            }
            lastNonWsToken = i;
            i += 1;
        }
        const skipped = i - this.index;
        this.index = i;
        return {
            skipped,
            // if firstNonWsToken is -1, then lastNonWsToken is also -1
            skippedTrimmed: firstNonWsToken === -1 ? 0 : lastNonWsToken - firstNonWsToken + 1,
        };
    }
    /**
     * Expects that the end of the stream is not reached.
     */
    expectNotEof() {
        if (this.isEof()) {
            throw new AdblockSyntaxError('Unexpected end of input', this.baseOffset + this.source.length - 1, this.baseOffset + this.source.length);
        }
    }
    /**
     * Expects the current token to have a specific type and optional value and balance level.
     *
     * @param type The expected token type.
     * @param data Optional expectation data.
     * @throws If the end of the stream is reached or if the token type or expectation data does not match.
     */
    expect(type, data) {
        const token = this.get();
        if (!token) {
            throw new AdblockSyntaxError(sprintf(ERROR_MESSAGES$6.EXPECTED_TOKEN_BUT_GOT, getFormattedTokenName(type), END_OF_INPUT), this.baseOffset + this.source.length - 1, this.baseOffset + this.source.length);
        }
        if (token.type !== type) {
            throw new AdblockSyntaxError(sprintf(ERROR_MESSAGES$6.EXPECTED_TOKEN_BUT_GOT, getFormattedTokenName(type), getFormattedTokenName(token.type)), this.baseOffset + token.start, this.baseOffset + token.end);
        }
        if (data?.balance !== undefined && token.balance !== data.balance) {
            throw new AdblockSyntaxError(sprintf(ERROR_MESSAGES$6.EXPECTED_TOKEN_WITH_BALANCE_BUT_GOT, getFormattedTokenName(type), data.balance, token.balance), this.baseOffset + token.start, this.baseOffset + token.end);
        }
        if (data?.value && this.fragment() !== data.value) {
            throw new AdblockSyntaxError(sprintf(ERROR_MESSAGES$6.EXPECTED_TOKEN_WITH_VALUE_BUT_GOT, getFormattedTokenName(type), data.value, this.fragment()), this.baseOffset + token.start, this.baseOffset + token.end);
        }
    }
    /**
     * Gets the balance level of the token at the specified index.
     *
     * @param index The index of the token to retrieve the balance level for.
     * @returns The balance level of the token or 0 if the index is out of bounds.
     */
    getBalance(index = this.index) {
        return this.tokens[index]?.balance || 0;
    }
    /**
     * Checks whether the token stream contains any Extended CSS elements, such as `:contains()`, etc.
     *
     * @returns `true` if the stream contains any Extended CSS elements, otherwise `false`.
     */
    hasAnySelectorExtendedCssNode() {
        return this.hasAnySelectorExtendedCssNodeInternal(EXT_CSS_PSEUDO_CLASSES);
    }
    /**
     * Strictly checks whether the token stream contains any Extended CSS elements, such as `:contains()`.
     * Some Extended CSS elements are natively supported by browsers, like `:has()`.
     * This method is used to check for Extended CSS elements that are not natively supported by browsers,
     * this is why it called "strict", because it strictly checks for Extended CSS elements.
     *
     * @returns `true` if the stream contains any Extended CSS elements, otherwise `false`.
     */
    hasAnySelectorExtendedCssNodeStrict() {
        return this.hasAnySelectorExtendedCssNodeInternal(EXT_CSS_PSEUDO_CLASSES_STRICT);
    }
    /**
     * Checks whether the token stream contains any Extended CSS elements, such as `:has()`, `:contains()`, etc.
     *
     * @param pseudos Set of pseudo-classes to check for.
     *
     * @returns `true` if the stream contains any Extended CSS elements, otherwise `false`.
     */
    hasAnySelectorExtendedCssNodeInternal(pseudos) {
        for (let i = 0; i < this.tokens.length; i += 1) {
            const token = this.tokens[i];
            if (token.type === TokenType$1.Function) {
                const name = this.source.slice(token.start, token.end - 1); // omit the last parenthesis
                if (pseudos.has(name)) {
                    return true;
                }
            }
            else if (token.type === TokenType$1.OpenSquareBracket) {
                let j = i + 1;
                // skip whitespace
                while (j < this.tokens.length && this.tokens[j].type === TokenType$1.Whitespace) {
                    j += 1;
                }
                if (j < this.tokens.length && this.tokens[j].type === TokenType$1.Ident) {
                    const attr = this.source.slice(this.tokens[j].start, this.tokens[j].end);
                    // [-ext-<name>=...] or [-abp-<name>=...]
                    if (attr.startsWith(LEGACY_EXT_CSS_ATTRIBUTE_PREFIX) || attr.startsWith(ABP_EXT_CSS_PREFIX)) {
                        return true;
                    }
                }
                // do not check these tokens again
                i = j;
            }
        }
        return false;
    }
}

/**
 * @file Parser for AdGuard CSS injections.
 */
const REMOVE_PROPERTY = 'remove';
const REMOVE_VALUE = 'true';
const removeDeclaration = `${REMOVE_PROPERTY}${COLON}${SPACE}${REMOVE_VALUE}${SEMICOLON}`;
const ERROR_MESSAGES$4 = {
    MEDIA_QUERY_LIST_IS_EMPTY: 'Media query list is empty',
    SELECTOR_LIST_IS_EMPTY: 'Selector list is empty',
    DECLARATION_LIST_IS_EMPTY: 'Declaration list is empty',
};
/**
 * Parser for AdGuard CSS injection.
 */
class AdgCssInjectionParser extends ParserBase {
    /**
     * Parses an AdGuard CSS injection.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     *
     * @returns Parsed AdGuard CSS injection {@link CssInjectionRuleBody}.
     * @throws An {@link AdblockSyntaxError} if the selector list is syntactically invalid.
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0) {
        let mediaQueryList;
        const selectorList = { type: 'Value', value: EMPTY };
        const declarationList = { type: 'Value', value: EMPTY };
        const stream = new CssTokenStream(raw, baseOffset);
        // Skip leading whitespace characters
        stream.skipWhitespace();
        // We have two possible CSS injection formats:
        // 1. @media (media-query-list) { selector list { declarations separated by semicolons } }
        // 2. selector list { declarations separated by semicolons }
        // Handle '@media' case:
        let balanceShift = 0;
        if (stream.getOrFail().type === TokenType$1.AtKeyword) {
            // Currently only '@media' is supported, we should throw an error if we encounter anything else,
            // like '@supports' or '@charset', etc.
            stream.expect(TokenType$1.AtKeyword, { value: CSS_MEDIA_MARKER, balance: 0 });
            stream.advance();
            // Skip whitespace characters after @media keyword, if any
            // @media (media-query-list) { ...
            //       â†‘
            //       â”” this one (if any)
            stream.skipWhitespace();
            const mediaQueryListStart = stream.getOrFail().start;
            // Skip everything until we found the opening curly bracket of the declaration block
            // @media media-query-list { ...
            //                         â†‘
            //                         â”” this one
            let lastNonWsIndex = -1;
            while (!stream.isEof()) {
                const token = stream.getOrFail();
                if (token.type === TokenType$1.OpenCurlyBracket && token.balance === 1) {
                    break;
                }
                if (token.type !== TokenType$1.Whitespace) {
                    lastNonWsIndex = token.end;
                }
                stream.advance();
            }
            // If the skipped tokens count is 0 without leading and trailing whitespace characters, then the media query
            // list is empty
            if (lastNonWsIndex === -1) {
                throw new AdblockSyntaxError(ERROR_MESSAGES$4.MEDIA_QUERY_LIST_IS_EMPTY, baseOffset + mediaQueryListStart, baseOffset + raw.length);
            }
            // It is safe to use non-null assertion here, because we have already checked previous tokens.
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const mediaQueryListEnd = lastNonWsIndex;
            mediaQueryList = {
                type: 'Value',
                value: raw.slice(mediaQueryListStart, mediaQueryListEnd),
            };
            if (options.isLocIncluded) {
                mediaQueryList.start = baseOffset + mediaQueryListStart;
                mediaQueryList.end = baseOffset + mediaQueryListEnd;
            }
            // Next token should be an open curly bracket
            // @media (media-query-list) { ...
            //                           â†‘
            //                           â”” this one
            stream.expect(TokenType$1.OpenCurlyBracket);
            stream.advance();
            // '@media' at-rule wrap increases the balance level by 1 for the rule within the at-rule, because it
            // has its own { ... } block
            balanceShift = 1;
        }
        // Skip leading whitespace before the rule, if any
        // Note: rule = selector list { declarations separated by semicolons }
        stream.skipWhitespace();
        const selectorStart = stream.getOrFail().start;
        // Jump to the opening curly bracket of the declaration block, based on the balance level
        // .selector { padding-top: 10px; padding-bottom: 10px; }
        //           â†‘
        //           â”” this one
        const { skippedTrimmed: selectorTokensLength } = stream.skipUntilExt(TokenType$1.OpenCurlyBracket, balanceShift + 1);
        stream.expect(TokenType$1.OpenCurlyBracket);
        // If the skipped tokens count is 0 without leading and trailing whitespace characters, then the selector list
        // is empty
        if (selectorTokensLength === 0) {
            throw new AdblockSyntaxError(ERROR_MESSAGES$4.SELECTOR_LIST_IS_EMPTY, baseOffset + selectorStart, baseOffset + raw.length);
        }
        // It is safe to use non-null assertion here, because we have already checked previous tokens.
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const selectorEnd = stream.lookbehindForNonWs().end;
        selectorList.value = raw.slice(selectorStart, selectorEnd);
        if (options.isLocIncluded) {
            selectorList.start = baseOffset + selectorStart;
            selectorList.end = baseOffset + selectorEnd;
        }
        // Jump to the next token after the opening curly bracket of the declaration block
        // .selector { padding-top: 10px; padding-bottom: 10px; }
        //            â†‘
        //            â”” this one
        stream.advance();
        // Skip whitespace characters after the opening curly bracket of the declaration block, if any
        stream.skipWhitespace();
        // Jump to the closing curly bracket of the declaration block, based on the balance level
        // .selector { padding-top: 10px; padding-bottom: 10px; }
        //                                                      â†‘
        //                                                      â”” this one
        const declarationsStart = stream.getOrFail().start;
        const declarations = new Set();
        let declarationsEnd = -1;
        let remove = false;
        let lastNonWsIndex = -1;
        while (!stream.isEof()) {
            const token = stream.getOrFail();
            if (token.type === TokenType$1.CloseCurlyBracket && stream.getBalance() === balanceShift) {
                declarationsEnd = lastNonWsIndex;
                break;
            }
            if (token.type !== TokenType$1.Whitespace) {
                lastNonWsIndex = token.end;
            }
            if (token.type === TokenType$1.Ident && stream.lookahead()?.type === TokenType$1.Colon) {
                const ident = raw.slice(token.start, token.end);
                declarations.add(ident);
                // Consume ident and colon
                stream.advance();
                stream.advance();
                // only 'remove: true' is allowed
                if (ident === REMOVE_PROPERTY) {
                    // Skip whitespace after colon, if any
                    stream.skipWhitespace();
                    // Next token should be an ident, with value 'true'
                    stream.expect(TokenType$1.Ident, { value: REMOVE_VALUE });
                    stream.advance();
                    remove = true;
                }
            }
            else {
                stream.advance();
            }
        }
        if (declarationsEnd === -1) {
            throw new AdblockSyntaxError(ERROR_MESSAGES$4.DECLARATION_LIST_IS_EMPTY, baseOffset + declarationsStart, baseOffset + raw.length);
        }
        declarationList.value = raw.slice(declarationsStart, declarationsEnd);
        if (options.isLocIncluded) {
            declarationList.start = baseOffset + declarationsStart;
            declarationList.end = baseOffset + declarationsEnd;
        }
        // Eat the close curly bracket of the declaration block
        // .selector { padding-top: 10px; padding-bottom: 10px; }
        //                                                      â†‘
        //                                                      â”” this one
        stream.expect(TokenType$1.CloseCurlyBracket);
        stream.advance();
        // Skip whitespace after the rule, if any
        stream.skipWhitespace();
        // If we have a media query, we should have an extra close curly bracket
        if (balanceShift === 1) {
            stream.expect(TokenType$1.CloseCurlyBracket);
            stream.advance();
        }
        const result = {
            type: 'CssInjectionRuleBody',
            selectorList,
            declarationList,
            remove,
        };
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        if (mediaQueryList) {
            result.mediaQueryList = mediaQueryList;
        }
        return result;
    }
    /**
     * Serializes an AdGuard CSS injection node into a raw string.
     *
     * @param node Node to serialize.
     * @returns Raw string.
     */
    static generate(node) {
        const result = [];
        if (node.mediaQueryList) {
            result.push(CSS_MEDIA_MARKER, SPACE, node.mediaQueryList.value, SPACE, OPEN_CURLY_BRACKET, SPACE);
        }
        result.push(node.selectorList.value, SPACE, OPEN_CURLY_BRACKET, SPACE);
        if (node.remove) {
            result.push(removeDeclaration);
        }
        else if (node.declarationList?.value) {
            result.push(node.declarationList.value);
        }
        result.push(SPACE, CLOSE_CURLY_BRACKET);
        if (node.mediaQueryList) {
            result.push(SPACE, CLOSE_CURLY_BRACKET);
        }
        return result.join(EMPTY);
    }
}

/* eslint-disable no-param-reassign */
/**
 * @file Helpers for serializing scriptlet injection body nodes to binary format.
 * We keep the core logic here, because it can be reused for each scriptlet body parser.
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
var AbpSnippetBodySerializationMap;
(function (AbpSnippetBodySerializationMap) {
    AbpSnippetBodySerializationMap[AbpSnippetBodySerializationMap["Children"] = 1] = "Children";
    AbpSnippetBodySerializationMap[AbpSnippetBodySerializationMap["Start"] = 2] = "Start";
    AbpSnippetBodySerializationMap[AbpSnippetBodySerializationMap["End"] = 3] = "End";
})(AbpSnippetBodySerializationMap || (AbpSnippetBodySerializationMap = {}));
/**
 * Serializes a hint rule node to binary format.
 *
 * @param node Node to serialize.
 * @param buffer ByteBuffer for writing binary data.
 * @param frequentScriptletArgs Map of frequently used scriptlet names / arguments
 * and their serialization index (optional).
 */
const serializeScriptletBody = (node, buffer, frequentScriptletArgs) => {
    buffer.writeUint8(BinaryTypeMap.ScriptletInjectionRuleBodyNode);
    const { length } = node.children;
    buffer.writeUint8(AbpSnippetBodySerializationMap.Children);
    // note: we store the count, because re-construction of the array is faster if we know the length
    if (length > UINT8_MAX) {
        throw new Error(`Too many scriptlet children: ${length}, the limit is ${UINT8_MAX}`);
    }
    buffer.writeUint8(length);
    for (let i = 0; i < length; i += 1) {
        ParameterListParser.serialize(node.children[i], buffer, frequentScriptletArgs);
    }
    if (!isUndefined(node.start)) {
        buffer.writeUint8(AbpSnippetBodySerializationMap.Start);
        buffer.writeUint32(node.start);
    }
    if (!isUndefined(node.end)) {
        buffer.writeUint8(AbpSnippetBodySerializationMap.End);
        buffer.writeUint32(node.end);
    }
    buffer.writeUint8(NULL);
};
/**
 * Deserializes a hint rule node from binary format.
 *
 * @param buffer ByteBuffer for reading binary data.
 * @param node Destination node.
 * @param frequentScriptletArgs Map of frequently used scriptlet names / arguments
 * and their serialization index (optional).
 * @throws If the binary data is malformed.
 */
const deserializeScriptletBody = (buffer, node, frequentScriptletArgs) => {
    buffer.assertUint8(BinaryTypeMap.ScriptletInjectionRuleBodyNode);
    node.type = 'ScriptletInjectionRuleBody';
    let prop = buffer.readUint8();
    while (prop !== NULL) {
        switch (prop) {
            case AbpSnippetBodySerializationMap.Children:
                node.children = new Array(buffer.readUint8());
                // read children
                for (let i = 0; i < node.children.length; i += 1) {
                    // eslint-disable-next-line max-len
                    ParameterListParser.deserialize(buffer, node.children[i] = {}, frequentScriptletArgs);
                }
                break;
            case AbpSnippetBodySerializationMap.Start:
                node.start = buffer.readUint32();
                break;
            case AbpSnippetBodySerializationMap.End:
                node.end = buffer.readUint32();
                break;
            default:
                throw new Error(`Invalid property: ${prop}`);
        }
        prop = buffer.readUint8();
    }
};

/**
 * @file uBlock scriptlet injection body parser
 */
/**
 * `AbpSnippetInjectionBodyParser` is responsible for parsing the body of an Adblock Plus-style snippet rule.
 *
 * Please note that the parser will parse any scriptlet rule if it is syntactically correct.
 * For example, it will parse this:
 * ```adblock
 * example.com#$#snippet0 arg0
 * ```
 *
 * but it didn't check if the scriptlet `snippet0` actually supported by any adblocker.
 *
 * @see {@link https://help.eyeo.com/adblockplus/snippet-filters-tutorial}
 */
class AbpSnippetInjectionBodyParser extends ParserBase {
    /**
     * Error messages used by the parser.
     */
    static ERROR_MESSAGES = {
        EMPTY_SCRIPTLET_CALL: 'Empty ABP snippet call',
    };
    /**
     * Value map for binary serialization. This helps to reduce the size of the serialized data,
     * as it allows us to use a single byte to represent frequently used values.
     *
     * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
     *
     * @note Only 256 values can be represented this way.
     */
    // TODO: Update this map with the actual values
    static FREQUENT_ARGS_SERIALIZATION_MAP = new Map([
        ['abort-current-inline-script', 0],
        ['abort-on-property-read', 1],
        ['abort-on-property-write', 2],
        ['json-prune', 3],
        ['log', 4],
        ['prevent-listener', 5],
        ['cookie-remover', 6],
        ['override-property-read', 7],
        ['abort-on-iframe-property-read', 8],
        ['abort-on-iframe-property-write', 9],
        ['freeze-element', 10],
        ['json-override', 11],
        ['simulate-mouse-event', 12],
        ['strip-fetch-query-parameter', 13],
        ['hide-if-contains', 14],
        ['hide-if-contains-image', 15],
        ['hide-if-contains-image-hash', 16],
        ['hide-if-contains-similar-text', 17],
        ['hide-if-contains-visible-text', 18],
        ['hide-if-contains-and-matches-style', 19],
        ['hide-if-graph-matches', 20],
        ['hide-if-has-and-matches-style', 21],
        ['hide-if-labelled-by', 22],
        ['hide-if-matches-xpath', 23],
        ['hide-if-matches-computed-xpath', 24],
        ['hide-if-shadow-contains', 25],
        ['debug', 26],
        ['trace', 27],
        ['race', 28],
    ]);
    /**
     * Value map for binary deserialization. This helps to reduce the size of the serialized data,
     * as it allows us to use a single byte to represent frequently used values.
     */
    static FREQUENT_ARGS_DESERIALIZATION_MAP = new Map(Array.from(this.FREQUENT_ARGS_SERIALIZATION_MAP).map(([key, value]) => [value, key]));
    /**
     * Parses the body of an Adblock Plus-style snippet rule.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Node of the parsed scriptlet call body
     * @throws If the body is syntactically incorrect
     * @example
     * ```
     * #$#snippet0 arg0
     * ```
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0) {
        const result = {
            type: 'ScriptletInjectionRuleBody',
            children: [],
        };
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        let offset = 0;
        // Skip leading spaces
        offset = StringUtils.skipWS(raw, offset);
        while (offset < raw.length) {
            offset = StringUtils.skipWS(raw, offset);
            const scriptletCallStart = offset;
            // Find the next semicolon or the end of the string
            let semicolonIndex = StringUtils.findUnescapedNonStringNonRegexChar(raw, SEMICOLON, offset);
            if (semicolonIndex === -1) {
                semicolonIndex = raw.length;
            }
            const scriptletCallEnd = Math.max(StringUtils.skipWSBack(raw, semicolonIndex - 1) + 1, scriptletCallStart);
            const params = ParameterListParser.parse(raw.slice(scriptletCallStart, scriptletCallEnd), options, baseOffset + scriptletCallStart, SPACE);
            // Parse the scriptlet call
            result.children.push(params);
            // Skip the semicolon
            offset = semicolonIndex + 1;
        }
        if (result.children.length === 0) {
            throw new AdblockSyntaxError(this.ERROR_MESSAGES.EMPTY_SCRIPTLET_CALL, baseOffset, baseOffset + raw.length);
        }
        return result;
    }
    /**
     * Generates a string representation of the Adblock Plus-style snippet call body.
     *
     * @param node Scriptlet injection rule body
     * @returns String representation of the rule body
     */
    static generate(node) {
        const result = [];
        if (node.children.length === 0) {
            throw new Error(this.ERROR_MESSAGES.EMPTY_SCRIPTLET_CALL);
        }
        for (const scriptletCall of node.children) {
            if (scriptletCall.children.length === 0) {
                throw new Error(this.ERROR_MESSAGES.EMPTY_SCRIPTLET_CALL);
            }
            result.push(ParameterListParser.generate(scriptletCall, SPACE));
        }
        return result.join(SEMICOLON + SPACE);
    }
    /**
     * Serializes a scriptlet call body node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node, buffer) {
        serializeScriptletBody(node, buffer, this.FREQUENT_ARGS_SERIALIZATION_MAP);
    }
    /**
     * Deserializes a scriptlet call body node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node) {
        deserializeScriptletBody(buffer, node, this.FREQUENT_ARGS_DESERIALIZATION_MAP);
    }
}

/**
 * @file Utility functions for working with quotes
 */
/**
 * Set of all possible quote characters supported by the library
 */
const QUOTE_SET = new Set([
    SINGLE_QUOTE,
    DOUBLE_QUOTE,
    BACKTICK_QUOTE,
]);
/**
 * Possible quote types for scriptlet parameters
 */
var QuoteType;
(function (QuoteType) {
    /**
     * No quotes at all
     */
    QuoteType["None"] = "none";
    /**
     * Single quotes (`'`)
     */
    QuoteType["Single"] = "single";
    /**
     * Double quotes (`"`)
     */
    QuoteType["Double"] = "double";
    /**
     * Backtick quotes (`` ` ``)
     */
    QuoteType["Backtick"] = "backtick";
})(QuoteType || (QuoteType = {}));
/**
 * Utility functions for working with quotes
 */
class QuoteUtils {
    /**
     * Escape all unescaped occurrences of the character
     *
     * @param string String to escape
     * @param char Character to escape
     * @returns Escaped string
     */
    static escapeUnescapedOccurrences(string, char) {
        let result = EMPTY;
        for (let i = 0; i < string.length; i += 1) {
            if (string[i] === char && (i === 0 || string[i - 1] !== ESCAPE_CHARACTER)) {
                result += ESCAPE_CHARACTER;
            }
            result += string[i];
        }
        return result;
    }
    /**
     * Unescape all single escaped occurrences of the character
     *
     * @param string String to unescape
     * @param char Character to unescape
     * @returns Unescaped string
     */
    static unescapeSingleEscapedOccurrences(string, char) {
        let result = EMPTY;
        for (let i = 0; i < string.length; i += 1) {
            if (string[i] === char
                && string[i - 1] === ESCAPE_CHARACTER
                && (i === 1 || string[i - 2] !== ESCAPE_CHARACTER)) {
                result = result.slice(0, -1);
            }
            result += string[i];
        }
        return result;
    }
    /**
     * Get quote type of the string
     *
     * @param string String to check
     * @returns Quote type of the string
     */
    static getStringQuoteType(string) {
        // Don't check 1-character strings to avoid false positives
        if (string.length > 1) {
            if (string.startsWith(SINGLE_QUOTE) && string.endsWith(SINGLE_QUOTE)) {
                return QuoteType.Single;
            }
            if (string.startsWith(DOUBLE_QUOTE) && string.endsWith(DOUBLE_QUOTE)) {
                return QuoteType.Double;
            }
            if (string.startsWith(BACKTICK_QUOTE) && string.endsWith(BACKTICK_QUOTE)) {
                return QuoteType.Backtick;
            }
        }
        return QuoteType.None;
    }
    /**
     * Set quote type of the string
     *
     * @param string String to set quote type of
     * @param quoteType Quote type to set
     * @returns String with the specified quote type
     */
    static setStringQuoteType(string, quoteType) {
        const actualQuoteType = QuoteUtils.getStringQuoteType(string);
        switch (quoteType) {
            case QuoteType.None:
                if (actualQuoteType === QuoteType.Single) {
                    return QuoteUtils.escapeUnescapedOccurrences(string.slice(1, -1), SINGLE_QUOTE);
                }
                if (actualQuoteType === QuoteType.Double) {
                    return QuoteUtils.escapeUnescapedOccurrences(string.slice(1, -1), DOUBLE_QUOTE);
                }
                if (actualQuoteType === QuoteType.Backtick) {
                    return QuoteUtils.escapeUnescapedOccurrences(string.slice(1, -1), BACKTICK_QUOTE);
                }
                return string;
            case QuoteType.Single:
                if (actualQuoteType === QuoteType.None) {
                    return SINGLE_QUOTE + QuoteUtils.escapeUnescapedOccurrences(string, SINGLE_QUOTE) + SINGLE_QUOTE;
                }
                if (actualQuoteType === QuoteType.Double) {
                    return SINGLE_QUOTE
                        + QuoteUtils.escapeUnescapedOccurrences(QuoteUtils.unescapeSingleEscapedOccurrences(string.slice(1, -1), DOUBLE_QUOTE), SINGLE_QUOTE) + SINGLE_QUOTE;
                }
                if (actualQuoteType === QuoteType.Backtick) {
                    return SINGLE_QUOTE
                        + QuoteUtils.escapeUnescapedOccurrences(QuoteUtils.unescapeSingleEscapedOccurrences(string.slice(1, -1), BACKTICK_QUOTE), SINGLE_QUOTE) + SINGLE_QUOTE;
                }
                return string;
            case QuoteType.Double:
                if (actualQuoteType === QuoteType.None) {
                    return DOUBLE_QUOTE + QuoteUtils.escapeUnescapedOccurrences(string, DOUBLE_QUOTE) + DOUBLE_QUOTE;
                }
                if (actualQuoteType !== QuoteType.Double) {
                    // eslint-disable-next-line max-len
                    return DOUBLE_QUOTE
                        + QuoteUtils.escapeUnescapedOccurrences(QuoteUtils.unescapeSingleEscapedOccurrences(string.slice(1, -1), SINGLE_QUOTE), DOUBLE_QUOTE) + DOUBLE_QUOTE;
                }
                return string;
            case QuoteType.Backtick:
                if (actualQuoteType === QuoteType.None) {
                    // eslint-disable-next-line max-len
                    return BACKTICK_QUOTE + QuoteUtils.escapeUnescapedOccurrences(string, BACKTICK_QUOTE) + BACKTICK_QUOTE;
                }
                if (actualQuoteType !== QuoteType.Backtick) {
                    // eslint-disable-next-line max-len
                    return BACKTICK_QUOTE
                        + QuoteUtils.escapeUnescapedOccurrences(QuoteUtils.unescapeSingleEscapedOccurrences(string.slice(1, -1), SINGLE_QUOTE), BACKTICK_QUOTE) + BACKTICK_QUOTE;
                }
                return string;
            default:
                return string;
        }
    }
    /**
     * Removes bounding quotes from a string, if any
     *
     * @param string Input string
     * @returns String without quotes
     */
    static removeQuotes(string) {
        if (
        // We should check for string length to avoid false positives
        string.length > 1
            && (string[0] === SINGLE_QUOTE || string[0] === DOUBLE_QUOTE || string[0] === BACKTICK_QUOTE)
            && string[0] === string[string.length - 1]) {
            return string.slice(1, -1);
        }
        return string;
    }
    /**
     * Removes bounding quotes from a string, if any, and unescapes the escaped quotes,
     * like transforming `'abc\'def'` to `abc'def`.
     *
     * @param string Input string
     * @returns String without quotes
     */
    static removeQuotesAndUnescape(string) {
        if (
        // We should check for string length to avoid false positives
        string.length > 1
            && (string[0] === SINGLE_QUOTE || string[0] === DOUBLE_QUOTE || string[0] === BACKTICK_QUOTE)
            && string[0] === string[string.length - 1]) {
            return QuoteUtils.unescapeSingleEscapedOccurrences(string.slice(1, -1), string[0]);
        }
        return string;
    }
    /**
     * Wraps given `strings` with `quote` (defaults to single quote `'`)
     * and joins them with `separator` (defaults to comma+space `, `).
     *
     * @param strings Strings to quote and join.
     * @param quoteType Quote to use.
     * @param separator Separator to use.
     *
     * @returns String with joined items.
     *
     * @example
     * ['abc', 'def']: strings[]  ->  "'abc', 'def'": string
     */
    static quoteAndJoinStrings(strings, quoteType = QuoteType.Single, separator = `${COMMA}${SPACE}`) {
        return strings
            .map((s) => QuoteUtils.setStringQuoteType(s, quoteType))
            .join(separator);
    }
}

/* eslint-disable no-param-reassign */
class UboParameterListParser extends ParameterListParser {
    /**
     * Parses an "uBO-specific parameter list".
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @param separator Separator character (default: comma).
     * @param requireQuotes Whether to require quotes around the parameter values (default: false).
     * @param supportedQuotes Set of accepted quotes (default: {@link QUOTE_SET}).
     * @returns Parameter list node.
     *
     * @note Based on {@link https://github.com/gorhill/uBlock/blob/f9ab4b75041815e6e5690d80851189ae3dc660d0/src/js/static-filtering-parser.js#L607-L699} to provide consistency.
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0, separator = COMMA, requireQuotes = false, supportedQuotes = QUOTE_SET) {
        // Prepare the parameter list node
        const params = {
            type: 'ParameterList',
            children: [],
        };
        const { length } = raw;
        if (options.isLocIncluded) {
            params.start = baseOffset;
            params.end = baseOffset + length;
        }
        let offset = 0;
        // TODO: Eliminate the need for extraNull
        let extraNull = false;
        while (offset < length) {
            offset = StringUtils.skipWS(raw, offset);
            const paramStart = offset;
            let paramEnd = offset;
            if (supportedQuotes.has(raw[offset])) {
                // Find the closing quote
                const possibleClosingQuoteIndex = StringUtils.findNextUnescapedCharacter(raw, raw[offset], offset + 1);
                if (possibleClosingQuoteIndex !== -1) {
                    // Next non-whitespace character after the closing quote should be the separator
                    const nextSeparatorIndex = StringUtils.skipWS(raw, possibleClosingQuoteIndex + 1);
                    if (nextSeparatorIndex === length) {
                        if (requireQuotes) {
                            throw new AdblockSyntaxError('Expected separator, got end of string', baseOffset + nextSeparatorIndex, baseOffset + length);
                        }
                        // If the separator is not found, the param end is the end of the string
                        paramEnd = StringUtils.skipWSBack(raw, length - 1) + 1;
                        offset = length;
                    }
                    else if (raw[nextSeparatorIndex] === separator) {
                        // If the quote is followed by a separator, we can use it as a closing quote
                        paramEnd = possibleClosingQuoteIndex + 1;
                        offset = nextSeparatorIndex + 1;
                    }
                    else {
                        if (requireQuotes) {
                            throw new AdblockSyntaxError(`Expected separator, got: '${raw[nextSeparatorIndex]}'`, baseOffset + nextSeparatorIndex, baseOffset + length);
                        }
                        // Param end should be the last separator before the quote
                        offset = StringUtils.findNextUnescapedCharacterBackwards(raw, separator, possibleClosingQuoteIndex) + 1;
                        paramEnd = StringUtils.skipWSBack(raw, offset - 2) + 1;
                    }
                }
                else {
                    if (requireQuotes) {
                        throw new AdblockSyntaxError('Expected closing quote, got end of string', baseOffset + offset, baseOffset + length);
                    }
                    // If the closing quote is not found, the param end is the end of the string
                    paramEnd = StringUtils.skipWSBack(raw, length - 1) + 1;
                    offset = length;
                }
            }
            else {
                if (requireQuotes) {
                    throw new AdblockSyntaxError(`Expected quote, got: '${raw[offset]}'`, baseOffset + offset, baseOffset + length);
                }
                const nextSeparator = StringUtils.findNextUnescapedCharacter(raw, separator, offset);
                if (nextSeparator === -1) {
                    // If the separator is not found, the param end is the end of the string
                    paramEnd = StringUtils.skipWSBack(raw, length - 1) + 1;
                    offset = length;
                }
                else {
                    // Param end should be the last non-whitespace character before the separator
                    paramEnd = StringUtils.skipWSBack(raw, nextSeparator - 1) + 1;
                    offset = nextSeparator + 1;
                    if (StringUtils.skipWS(raw, length - 1) === nextSeparator) {
                        extraNull = true;
                    }
                }
            }
            if (paramStart < paramEnd) {
                params.children.push(ValueParser.parse(raw.slice(paramStart, paramEnd), options, baseOffset + paramStart));
            }
            else {
                params.children.push(null);
            }
        }
        if (extraNull) {
            params.children.push(null);
        }
        return params;
    }
}

/**
 * @file uBlock scriptlet injection body parser
 */
/**
 * `UboScriptletInjectionBodyParser` is responsible for parsing the body of a uBlock-style scriptlet rule.
 *
 * Please note that the parser will parse any scriptlet rule if it is syntactically correct.
 * For example, it will parse this:
 * ```adblock
 * example.com##+js(scriptlet0, arg0)
 * ```
 *
 * but it didn't check if the scriptlet `scriptlet0` actually supported by any adblocker.
 *
 * @see {@link https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#scriptlet-injection}
 */
class UboScriptletInjectionBodyParser extends ParserBase {
    /**
     * Error messages used by the parser.
     */
    static ERROR_MESSAGES = {
        NO_SCRIPTLET_MASK: `Invalid uBO scriptlet call, no scriptlet call mask '${UBO_SCRIPTLET_MASK}' found`,
        NO_OPENING_PARENTHESIS: `Invalid uBO scriptlet call, no opening parentheses '${OPEN_PARENTHESIS}' found`,
        NO_CLOSING_PARENTHESIS: `Invalid uBO scriptlet call, no closing parentheses '${CLOSE_PARENTHESIS}' found`,
        NO_SCRIPTLET_NAME: 'Invalid uBO scriptlet call, no scriptlet name specified',
        WHITESPACE_AFTER_MASK: 'Invalid uBO scriptlet call, whitespace is not allowed after the scriptlet call mask',
        NO_MULTIPLE_SCRIPTLET_CALLS: 'uBO syntaxes does not support multiple scriptlet calls within one single rule',
    };
    /**
     * Value map for binary serialization. This helps to reduce the size of the serialized data,
     * as it allows us to use a single byte to represent frequently used values.
     *
     * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
     *
     * @note Only 256 values can be represented this way.
     */
    // TODO: Update this map with the actual values
    static FREQUENT_ARGS_SERIALIZATION_MAP = new Map([
        ['abort-current-script.js', 0],
        ['acs.js', 1],
        ['abort-current-inline-script.js', 2],
        ['acis.js', 3],
        ['abort-on-property-read.js', 4],
        ['aopr.js', 5],
        ['abort-on-property-write.js', 6],
        ['aopw.js', 7],
        ['abort-on-stack-trace.js', 8],
        ['aost.js', 9],
        ['adjust-setInterval.js', 10],
        ['nano-setInterval-booster.js', 11],
        ['nano-sib.js', 12],
        ['adjust-setTimeout.js', 13],
        ['nano-setTimeout-booster.js', 14],
        ['nano-stb.js', 15],
        ['close-window.js', 16],
        ['window-close-if.js', 17],
        ['disable-newtab-links.js', 18],
        ['evaldata-prune.js', 19],
        ['json-prune.js', 20],
        ['addEventListener-logger.js', 21],
        ['aell.js', 22],
        ['m3u-prune.js', 23],
        ['nowebrtc.js', 24],
        ['addEventListener-defuser.js', 25],
        ['aeld.js', 26],
        ['prevent-addEventListener.js', 27],
        ['adfly-defuser.js', 28],
        ['noeval-if.js', 29],
        ['prevent-eval-if.js', 30],
        ['no-fetch-if.js', 31],
        ['prevent-fetch.js', 32],
        ['no-xhr-if.js', 33],
        ['prevent-xhr.js', 34],
        ['prevent-refresh.js', 35],
        ['refresh-defuser.js', 36],
        ['no-requestAnimationFrame-if.js', 37],
        ['norafif.js', 38],
        ['prevent-requestAnimationFrame.js', 39],
        ['no-setInterval-if.js', 40],
        ['nosiif.js', 41],
        ['prevent-setInterval.js', 42],
        ['setInterval-defuser.js', 43],
        ['no-setTimeout-if.js', 44],
        ['nostif.js', 45],
        ['prevent-setTimeout.js', 46],
        ['setTimeout-defuser.js', 47],
        ['no-window-open-if.js', 48],
        ['nowoif.js', 49],
        ['prevent-window-open.js', 50],
        ['window.open-defuser.js', 51],
        ['remove-attr.js', 52],
        ['ra.js', 53],
        ['remove-class.js', 54],
        ['rc.js', 55],
        ['remove-cookie.js', 56],
        ['cookie-remover.js', 57],
        ['remove-node-text.js', 58],
        ['rmnt.js', 59],
        ['set-attr.js', 60],
        ['set-constant.js', 61],
        ['set.js', 62],
        ['set-cookie.js', 63],
        ['set-local-storage-item.js', 64],
        ['set-session-storage-item.js', 65],
        ['xml-prune.js', 66],
        ['webrtc-if.js', 67],
        ['overlay-buster.js', 68],
        ['alert-buster.js', 69],
        ['golem.de.js', 70],
        ['href-sanitizer.js', 71],
        ['call-nothrow.js', 72],
        ['window.name-defuser.js', 73],
        ['spoof-css.js', 74],
        ['trusted-set-constant.js', 75],
        ['trusted-set.js', 76],
        ['trusted-set-cookie.js', 77],
        ['trusted-set-local-storage-item.js', 78],
        ['trusted-replace-fetch-response.js', 79],
        ['json-prune-fetch-response.js', 80],
        ['json-prune-xhr-response.js', 81],
        ['trusted-replace-xhr-response.js', 82],
        ['multiup.js', 83],
        ['prevent-canvas.js', 84],
        ['set-cookie-reload.js', 85],
        ['trusted-set-cookie-reload.js', 86],
        ['trusted-click-element.js', 87],
        ['trusted-prune-inbound-object.js', 88],
        ['trusted-prune-outbound-object.js', 89],
        ['trusted-set-session-storage-item.js', 90],
        ['trusted-replace-node-text.js', 91],
        ['trusted-rpnt.js', 92],
        ['replace-node-text.js', 93],
        ['rpnt.js', 94],
    ]);
    /**
     * Value map for binary deserialization. This helps to reduce the size of the serialized data,
     * as it allows us to use a single byte to represent frequently used values.
     */
    static FREQUENT_ARGS_DESERIALIZATION_MAP = new Map(Array.from(this.FREQUENT_ARGS_SERIALIZATION_MAP).map(([key, value]) => [value, key]));
    /**
     * Parses the body of a uBlock-style scriptlet rule.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Node of the parsed scriptlet call body
     * @throws If the body is syntactically incorrect
     * @example
     * ```
     * ##+js(scriptlet0, arg0)
     * ```
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0) {
        let offset = 0;
        // Skip leading spaces
        offset = StringUtils.skipWS(raw, offset);
        let scriptletMaskLength = 0;
        if (raw.startsWith(UBO_SCRIPTLET_MASK, offset)) {
            scriptletMaskLength = UBO_SCRIPTLET_MASK.length;
        }
        else if (raw.startsWith(UBO_SCRIPTLET_MASK_LEGACY, offset)) {
            scriptletMaskLength = UBO_SCRIPTLET_MASK_LEGACY.length;
        }
        // Scriptlet call should start with "+js"
        if (!scriptletMaskLength) {
            throw new AdblockSyntaxError(this.ERROR_MESSAGES.NO_SCRIPTLET_MASK, baseOffset + offset, baseOffset + raw.length);
        }
        offset += scriptletMaskLength;
        // Whitespace is not allowed after the mask
        if (raw[offset] === SPACE) {
            throw new AdblockSyntaxError(this.ERROR_MESSAGES.WHITESPACE_AFTER_MASK, baseOffset + offset, baseOffset + raw.length);
        }
        // Parameter list should be wrapped in parentheses
        if (raw[offset] !== OPEN_PARENTHESIS) {
            throw new AdblockSyntaxError(this.ERROR_MESSAGES.NO_OPENING_PARENTHESIS, baseOffset + offset, baseOffset + raw.length);
        }
        // Save the offset of the opening parentheses
        const openingParenthesesIndex = offset;
        // Skip whitespace from the end
        const closingParenthesesIndex = StringUtils.skipWSBack(raw, raw.length - 1);
        // Closing parentheses should be present
        if (raw[closingParenthesesIndex] !== CLOSE_PARENTHESIS
            || raw[closingParenthesesIndex - 1] === ESCAPE_CHARACTER) {
            throw new AdblockSyntaxError(this.ERROR_MESSAGES.NO_CLOSING_PARENTHESIS, baseOffset + offset, baseOffset + raw.length);
        }
        const result = {
            type: 'ScriptletInjectionRuleBody',
            children: [],
        };
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        // Special case: empty scriptlet call, like +js(), +js( ), etc.
        if (StringUtils.skipWS(raw, openingParenthesesIndex + 1) === closingParenthesesIndex) {
            return result;
        }
        // Parse parameter list
        const params = UboParameterListParser.parse(raw.slice(openingParenthesesIndex + 1, closingParenthesesIndex), options, baseOffset + openingParenthesesIndex + 1, COMMA);
        // Do not allow parameters without scriptlet: +js(, arg0, arg1)
        if (params.children.length > 0 && params.children[0] === null) {
            throw new AdblockSyntaxError(this.ERROR_MESSAGES.NO_SCRIPTLET_NAME, baseOffset + offset, baseOffset + raw.length);
        }
        result.children.push(params);
        return result;
    }
    /**
     * Generates a string representation of the uBlock scriptlet call body.
     *
     * @param node Scriptlet injection rule body
     * @returns String representation of the rule body
     */
    static generate(node) {
        const result = [];
        if (node.children.length > 1) {
            throw new Error(this.ERROR_MESSAGES.NO_MULTIPLE_SCRIPTLET_CALLS);
        }
        // During generation, we only support the modern scriptlet mask
        result.push(UBO_SCRIPTLET_MASK);
        result.push(OPEN_PARENTHESIS);
        if (node.children.length > 0) {
            const [parameterListNode] = node.children;
            result.push(ParameterListParser.generate(parameterListNode));
        }
        result.push(CLOSE_PARENTHESIS);
        return result.join(EMPTY);
    }
    /**
     * Serializes a scriptlet call body node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node, buffer) {
        serializeScriptletBody(node, buffer, this.FREQUENT_ARGS_SERIALIZATION_MAP);
    }
    /**
     * Deserializes a scriptlet call body node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node) {
        deserializeScriptletBody(buffer, node, this.FREQUENT_ARGS_DESERIALIZATION_MAP);
    }
}

/**
 * @file AdGuard scriptlet injection body parser
 */
/**
 * `AdgScriptletInjectionBodyParser` is responsible for parsing the body of an AdGuard-style scriptlet rule.
 *
 * Please note that the parser will parse any scriptlet rule if it is syntactically correct.
 * For example, it will parse this:
 * ```adblock
 * example.com#%#//scriptlet('scriptlet0', 'arg0')
 * ```
 *
 * but it didn't check if the scriptlet `scriptlet0` actually supported by any adblocker.
 *
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#scriptlets}
 */
class AdgScriptletInjectionBodyParser extends ParserBase {
    /**
     * Error messages used by the parser.
     */
    static ERROR_MESSAGES = {
        NO_SCRIPTLET_MASK: `Invalid ADG scriptlet call, no scriptlet call mask '${ADG_SCRIPTLET_MASK}' found`,
        NO_OPENING_PARENTHESIS: `Invalid ADG scriptlet call, no opening parentheses '${OPEN_PARENTHESIS}' found`,
        NO_CLOSING_PARENTHESIS: `Invalid ADG scriptlet call, no closing parentheses '${CLOSE_PARENTHESIS}' found`,
        WHITESPACE_AFTER_MASK: 'Invalid ADG scriptlet call, whitespace is not allowed after the scriptlet call mask',
        NO_MULTIPLE_SCRIPTLET_CALLS: 'ADG syntaxes does not support multiple scriptlet calls within one single rule',
        NO_INCONSISTENT_QUOTES: 'Invalid ADG scriptlet call, inconsistent quotes',
        NO_UNCLOSED_PARAMETER: 'Invalid ADG scriptlet call, unclosed parameter',
        EXPECTED_QUOTE: "Invalid ADG scriptlet call, expected quote, got '%s'",
        EXPECTED_COMMA: "Invalid ADG scriptlet call, expected comma, got '%s'",
    };
    /**
     * Value map for binary serialization. This helps to reduce the size of the serialized data,
     * as it allows us to use a single byte to represent frequently used values.
     *
     * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
     *
     * @note Only 256 values can be represented this way.
     */
    // TODO: Update this map with the actual values
    static FREQUENT_ARGS_SERIALIZATION_MAP = new Map([
        ['abort-current-inline-script', 0],
        ['abort-on-property-read', 1],
        ['abort-on-property-write', 2],
        ['abort-on-stack-trace', 3],
        ['adjust-setInterval', 4],
        ['adjust-setTimeout', 5],
        ['close-window', 6],
        ['debug-current-inline-script', 7],
        ['debug-on-property-read', 8],
        ['debug-on-property-write', 9],
        ['dir-string', 10],
        ['disable-newtab-links', 11],
        ['evaldata-prune', 12],
        ['json-prune', 13],
        ['log', 14],
        ['log-addEventListener', 15],
        ['log-eval', 16],
        ['log-on-stack-trace', 17],
        ['m3u-prune', 18],
        ['noeval', 19],
        ['nowebrtc', 20],
        ['no-topics', 21],
        ['prevent-addEventListener', 22],
        ['prevent-adfly', 23],
        ['prevent-bab', 24],
        ['prevent-eval-if', 25],
        ['prevent-fab-3.2.0', 26],
        ['prevent-fetch', 27],
        ['prevent-xhr', 28],
        ['prevent-popads-net', 29],
        ['prevent-refresh', 30],
        ['prevent-requestAnimationFrame', 31],
        ['prevent-setInterval', 32],
        ['prevent-setTimeout', 33],
        ['prevent-window-open', 34],
        ['remove-attr', 35],
        ['remove-class', 36],
        ['remove-cookie', 37],
        ['remove-node-text', 38],
        ['set-attr', 39],
        ['set-constant', 40],
        ['set-cookie', 41],
        ['set-cookie-reload', 42],
        ['set-local-storage-item', 43],
        ['set-popads-dummy', 44],
        ['set-session-storage-item', 45],
        ['xml-prune', 46],
    ]);
    /**
     * Value map for binary deserialization. This helps to reduce the size of the serialized data,
     * as it allows us to use a single byte to represent frequently used values.
     */
    static FREQUENT_ARGS_DESERIALIZATION_MAP = new Map(Array.from(this.FREQUENT_ARGS_SERIALIZATION_MAP).map(([key, value]) => [value, key]));
    /**
     * Parses the body of an AdGuard-style scriptlet rule.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Node of the parsed scriptlet call body
     * @throws If the body is syntactically incorrect
     * @example
     * ```
     * //scriptlet('scriptlet0', 'arg0')
     * ```
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0) {
        let offset = 0;
        // Skip leading spaces
        offset = StringUtils.skipWS(raw, offset);
        // Scriptlet call should start with "//scriptlet"
        if (!raw.startsWith(ADG_SCRIPTLET_MASK, offset)) {
            throw new AdblockSyntaxError(this.ERROR_MESSAGES.NO_SCRIPTLET_MASK, baseOffset + offset, baseOffset + raw.length);
        }
        offset += ADG_SCRIPTLET_MASK.length;
        // Whitespace is not allowed after the mask
        if (raw[offset] === SPACE) {
            throw new AdblockSyntaxError(this.ERROR_MESSAGES.WHITESPACE_AFTER_MASK, baseOffset + offset, baseOffset + raw.length);
        }
        // Parameter list should be wrapped in parentheses
        if (raw[offset] !== OPEN_PARENTHESIS) {
            throw new AdblockSyntaxError(this.ERROR_MESSAGES.NO_OPENING_PARENTHESIS, baseOffset + offset, baseOffset + raw.length);
        }
        // Save the offset of the opening parentheses
        const openingParenthesesIndex = offset;
        // Skip whitespace from the end
        const closingParenthesesIndex = StringUtils.skipWSBack(raw, raw.length - 1);
        // Closing parentheses should be present
        if (raw[closingParenthesesIndex] !== CLOSE_PARENTHESIS
            || raw[closingParenthesesIndex - 1] === ESCAPE_CHARACTER) {
            throw new AdblockSyntaxError(this.ERROR_MESSAGES.NO_CLOSING_PARENTHESIS, baseOffset + offset, baseOffset + raw.length);
        }
        // Skip space, if any
        offset = StringUtils.skipWS(raw, offset + 1);
        const result = {
            type: 'ScriptletInjectionRuleBody',
            children: [],
        };
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        // Special case: empty scriptlet call, like `//scriptlet()`, `//scriptlet( )` etc.
        if (StringUtils.skipWS(raw, openingParenthesesIndex + 1) === closingParenthesesIndex) {
            return result;
        }
        let detectedQuote = null;
        const parameterList = {
            type: 'ParameterList',
            children: [],
        };
        if (options.isLocIncluded) {
            parameterList.start = baseOffset + openingParenthesesIndex + 1;
            parameterList.end = baseOffset + closingParenthesesIndex;
        }
        while (offset < closingParenthesesIndex) {
            // Skip whitespace
            offset = StringUtils.skipWS(raw, offset);
            // Expect comma if not first parameter
            if (parameterList.children.length > 0) {
                if (raw[offset] !== COMMA) {
                    throw new AdblockSyntaxError(sprintf(AdgScriptletInjectionBodyParser.ERROR_MESSAGES.EXPECTED_COMMA, raw[offset]), baseOffset + offset, baseOffset + raw.length);
                }
                // Eat the comma
                offset += 1;
                // Skip whitespace
                offset = StringUtils.skipWS(raw, offset);
            }
            // Next character should be a quote
            if (raw[offset] === SINGLE_QUOTE || raw[offset] === DOUBLE_QUOTE) {
                if (isNull(detectedQuote)) {
                    detectedQuote = raw[offset];
                }
                else if (detectedQuote !== raw[offset]) {
                    throw new AdblockSyntaxError(AdgScriptletInjectionBodyParser.ERROR_MESSAGES.NO_INCONSISTENT_QUOTES, baseOffset + offset, baseOffset + raw.length);
                }
                // Find next unescaped same quote
                const closingQuoteIndex = StringUtils.findNextUnescapedCharacter(raw, detectedQuote, offset + 1);
                if (closingQuoteIndex === -1) {
                    throw new AdblockSyntaxError(AdgScriptletInjectionBodyParser.ERROR_MESSAGES.NO_UNCLOSED_PARAMETER, baseOffset + offset, baseOffset + raw.length);
                }
                // Save the parameter
                const parameter = ValueParser.parse(raw.slice(offset, closingQuoteIndex + 1), options, baseOffset + offset);
                parameterList.children.push(parameter);
                // Move after the closing quote
                offset = StringUtils.skipWS(raw, closingQuoteIndex + 1);
            }
            else {
                throw new AdblockSyntaxError(sprintf(AdgScriptletInjectionBodyParser.ERROR_MESSAGES.EXPECTED_QUOTE, raw[offset]), baseOffset + offset, baseOffset + raw.length);
            }
        }
        result.children.push(parameterList);
        return result;
    }
    /**
     * Generates a string representation of the AdGuard scriptlet call body.
     *
     * @param node Scriptlet injection rule body
     * @returns String representation of the rule body
     */
    static generate(node) {
        const result = [];
        if (node.children.length > 1) {
            throw new Error(this.ERROR_MESSAGES.NO_MULTIPLE_SCRIPTLET_CALLS);
        }
        result.push(ADG_SCRIPTLET_MASK);
        result.push(OPEN_PARENTHESIS);
        if (node.children.length > 0) {
            result.push(ParameterListParser.generate(node.children[0]));
        }
        result.push(CLOSE_PARENTHESIS);
        return result.join(EMPTY);
    }
    /**
     * Serializes a scriptlet call body node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node, buffer) {
        serializeScriptletBody(node, buffer, this.FREQUENT_ARGS_SERIALIZATION_MAP);
    }
    /**
     * Deserializes a scriptlet call body node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node) {
        deserializeScriptletBody(buffer, node, this.FREQUENT_ARGS_DESERIALIZATION_MAP);
    }
}

/* eslint-disable no-param-reassign */
/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const SEPARATOR_SERIALIZATION_MAP = new Map([
    ['##', 0],
    ['#@#', 1],
    ['#?#', 2],
    ['#@?#', 3],
    ['#$#', 4],
    ['#$?#', 5],
    ['#@$#', 6],
    ['#@$?#', 7],
    ['#%#', 8],
    ['#@%#', 9],
    ['$$', 10],
    ['$@$', 11],
]);
/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
const SEPARATOR_DESERIALIZATION_MAP = new Map(Array.from(SEPARATOR_SERIALIZATION_MAP).map(([key, value]) => [value, key]));
/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
const COSMETIC_RULE_TYPE_DESERIALIZATION_MAP = new Map([
    [BinaryTypeMap.ElementHidingRule, CosmeticRuleType.ElementHidingRule],
    [BinaryTypeMap.CssInjectionRule, CosmeticRuleType.CssInjectionRule],
    [BinaryTypeMap.ScriptletInjectionRule, CosmeticRuleType.ScriptletInjectionRule],
    [BinaryTypeMap.JsInjectionRule, CosmeticRuleType.JsInjectionRule],
    [BinaryTypeMap.HtmlFilteringRule, CosmeticRuleType.HtmlFilteringRule],
]);
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
var ElementHidingRuleSerializationMap;
(function (ElementHidingRuleSerializationMap) {
    ElementHidingRuleSerializationMap[ElementHidingRuleSerializationMap["SelectorList"] = 1] = "SelectorList";
    ElementHidingRuleSerializationMap[ElementHidingRuleSerializationMap["Start"] = 2] = "Start";
    ElementHidingRuleSerializationMap[ElementHidingRuleSerializationMap["End"] = 3] = "End";
})(ElementHidingRuleSerializationMap || (ElementHidingRuleSerializationMap = {}));
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
var CssInjectionRuleSerializationMap;
(function (CssInjectionRuleSerializationMap) {
    CssInjectionRuleSerializationMap[CssInjectionRuleSerializationMap["SelectorList"] = 1] = "SelectorList";
    CssInjectionRuleSerializationMap[CssInjectionRuleSerializationMap["DeclarationList"] = 2] = "DeclarationList";
    CssInjectionRuleSerializationMap[CssInjectionRuleSerializationMap["MediaQueryList"] = 3] = "MediaQueryList";
    CssInjectionRuleSerializationMap[CssInjectionRuleSerializationMap["Remove"] = 4] = "Remove";
    CssInjectionRuleSerializationMap[CssInjectionRuleSerializationMap["Start"] = 5] = "Start";
    CssInjectionRuleSerializationMap[CssInjectionRuleSerializationMap["End"] = 6] = "End";
})(CssInjectionRuleSerializationMap || (CssInjectionRuleSerializationMap = {}));
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
var CosmeticRuleSerializationMap;
(function (CosmeticRuleSerializationMap) {
    CosmeticRuleSerializationMap[CosmeticRuleSerializationMap["Syntax"] = 1] = "Syntax";
    CosmeticRuleSerializationMap[CosmeticRuleSerializationMap["Exception"] = 2] = "Exception";
    CosmeticRuleSerializationMap[CosmeticRuleSerializationMap["Separator"] = 3] = "Separator";
    CosmeticRuleSerializationMap[CosmeticRuleSerializationMap["Modifiers"] = 4] = "Modifiers";
    CosmeticRuleSerializationMap[CosmeticRuleSerializationMap["Domains"] = 5] = "Domains";
    CosmeticRuleSerializationMap[CosmeticRuleSerializationMap["Body"] = 6] = "Body";
    CosmeticRuleSerializationMap[CosmeticRuleSerializationMap["Start"] = 7] = "Start";
    CosmeticRuleSerializationMap[CosmeticRuleSerializationMap["End"] = 8] = "End";
})(CosmeticRuleSerializationMap || (CosmeticRuleSerializationMap = {}));
/**
 * Possible error messages for uBO selectors. Formatted with {@link sprintf}.
 */
const ERROR_MESSAGES$3 = {
    EMPTY_RULE_BODY: 'Empty rule body',
    INVALID_BODY_FOR_SEPARATOR: "Body '%s' is not valid for the '%s' cosmetic rule separator",
    MISSING_ADGUARD_MODIFIER_LIST_END: "Missing '%s' at the end of the AdGuard modifier list in pattern '%s'",
    MISSING_ADGUARD_MODIFIER_LIST_MARKER: "Missing '%s' at the beginning of the AdGuard modifier list in pattern '%s'",
    SYNTAXES_CANNOT_BE_MIXED: "'%s' syntax cannot be mixed with '%s' syntax",
    SYNTAX_DISABLED: "Parsing '%s' syntax is disabled, but the rule uses it",
};
const ADG_CSS_INJECTION_PATTERN = /^(?:.+){(?:.+)}$/;
/**
 * `CosmeticRuleParser` is responsible for parsing cosmetic rules.
 *
 * Where possible, it automatically detects the difference between supported syntaxes:
 *  - AdGuard
 *  - uBlock Origin
 *  - Adblock Plus
 *
 * If the syntax is common / cannot be determined, the parser gives `Common` syntax.
 *
 * Please note that syntactically correct rules are parsed even if they are not actually
 * compatible with the given adblocker. This is a completely natural behavior, meaningful
 * checking of compatibility is not done at the parser level.
 */
// TODO: Make raw body parsing optional
// TODO: Split into smaller sections
class CosmeticRuleParser extends ParserBase {
    /**
     * Determines whether a rule is a cosmetic rule. The rule is considered cosmetic if it
     * contains a cosmetic rule separator.
     *
     * @param raw Raw rule
     * @returns `true` if the rule is a cosmetic rule, `false` otherwise
     */
    static isCosmeticRule(raw) {
        const trimmed = raw.trim();
        if (CommentRuleParser.isCommentRule(trimmed)) {
            return false;
        }
        return CosmeticRuleSeparatorUtils.find(trimmed) !== null;
    }
    /**
     * Parses a cosmetic rule. The structure of the cosmetic rules:
     *  - pattern (AdGuard pattern can have modifiers, other syntaxes don't)
     *  - separator
     *  - body
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns
     * Parsed cosmetic rule AST or null if it failed to parse based on the known cosmetic rules
     * @throws If the input matches the cosmetic rule pattern but syntactically invalid
     */
    // TODO: Split to smaller functions
    static parse(raw, options = defaultParserOptions, baseOffset = 0) {
        // Find cosmetic rule separator - each cosmetic rule must have it, otherwise it is not a cosmetic rule
        const separatorResult = CosmeticRuleSeparatorUtils.find(raw);
        if (!separatorResult) {
            return null;
        }
        let syntax = AdblockSyntax.Common;
        let modifiers;
        const patternStart = StringUtils.skipWS(raw);
        const patternEnd = StringUtils.skipWSBack(raw, separatorResult.start - 1) + 1;
        const bodyStart = StringUtils.skipWS(raw, separatorResult.end);
        const bodyEnd = StringUtils.skipWSBack(raw) + 1;
        // Note we use '<=' instead of '===' because we have bidirectional trim
        if (bodyEnd <= bodyStart) {
            throw new AdblockSyntaxError(ERROR_MESSAGES$3.EMPTY_RULE_BODY, baseOffset, baseOffset + raw.length);
        }
        // Step 1. Parse the pattern: it can be a domain list or a domain list with modifiers (AdGuard)
        const rawPattern = raw.slice(patternStart, patternEnd);
        let patternOffset = patternStart;
        if (rawPattern[patternOffset] === OPEN_SQUARE_BRACKET) {
            // Save offset to the beginning of the modifier list for later
            const modifierListStart = patternOffset;
            // Consume opening square bracket
            patternOffset += 1;
            // Skip whitespace after opening square bracket
            patternOffset = StringUtils.skipWS(rawPattern, patternOffset);
            // Open square bracket should be followed by a modifier separator: [$
            if (rawPattern[patternOffset] !== DOLLAR_SIGN) {
                throw new AdblockSyntaxError(sprintf(ERROR_MESSAGES$3.MISSING_ADGUARD_MODIFIER_LIST_MARKER, DOLLAR_SIGN, rawPattern), baseOffset + patternOffset, baseOffset + rawPattern.length);
            }
            // Consume modifier separator
            patternOffset += 1;
            // Skip whitespace after modifier separator
            patternOffset = StringUtils.skipWS(rawPattern, patternOffset);
            // Modifier list ends with the last unescaped square bracket
            // We search for the last unescaped square bracket, because some modifiers can contain square brackets,
            // e.g. [$domain=/example[0-9]\.(com|org)/]##.ad
            const modifierListEnd = StringUtils.findLastUnescapedCharacter(rawPattern, CLOSE_SQUARE_BRACKET);
            if (modifierListEnd === -1) {
                throw new AdblockSyntaxError(sprintf(ERROR_MESSAGES$3.MISSING_ADGUARD_MODIFIER_LIST_END, CLOSE_SQUARE_BRACKET, rawPattern), baseOffset + patternOffset, baseOffset + rawPattern.length);
            }
            // Parse modifier list
            modifiers = ModifierListParser.parse(raw.slice(patternOffset, modifierListEnd), options, baseOffset + patternOffset);
            // Expand modifier list location to include the opening and closing square brackets
            if (options.isLocIncluded) {
                modifiers.start = baseOffset + modifierListStart;
                modifiers.end = baseOffset + modifierListEnd + 1;
            }
            // Consume modifier list
            patternOffset = modifierListEnd + 1;
            // Change the syntax to ADG
            syntax = AdblockSyntax.Adg;
        }
        // Skip whitespace after modifier list
        patternOffset = StringUtils.skipWS(rawPattern, patternOffset);
        // Parse domains
        const domains = DomainListParser.parse(rawPattern.slice(patternOffset), options, baseOffset + patternOffset);
        // Step 2. Parse the separator
        const separator = {
            type: 'Value',
            value: separatorResult.separator,
        };
        if (options.isLocIncluded) {
            separator.start = baseOffset + separatorResult.start;
            separator.end = baseOffset + separatorResult.end;
        }
        const exception = CosmeticRuleSeparatorUtils.isException(separatorResult.separator);
        // Step 3. Parse the rule body
        let rawBody = raw.slice(bodyStart, bodyEnd);
        /**
         * Ensures that the rule syntax is common or the expected one. This function is used to prevent mixing
         * different syntaxes in the same rule.
         *
         * @example
         * The following rule mixes AdGuard and uBO syntaxes, because it uses AdGuard modifier list and uBO
         * CSS injection:
         * ```adblock
         * [$path=/something]example.com##.foo:style(color: red)
         * ```
         * In this case, parser sets syntax to AdGuard, because it detects the AdGuard modifier list, but
         * when parsing the rule body, it detects uBO CSS injection, which is not compatible with AdGuard.
         *
         * @param expectedSyntax Expected syntax
         * @throws If the rule syntax is not common or the expected one
         */
        const expectCommonOrSpecificSyntax = (expectedSyntax) => {
            if (syntax !== AdblockSyntax.Common && syntax !== expectedSyntax) {
                throw new AdblockSyntaxError(sprintf(ERROR_MESSAGES$3.SYNTAXES_CANNOT_BE_MIXED, expectedSyntax, syntax), baseOffset + patternStart, baseOffset + bodyEnd);
            }
        };
        let uboSelector;
        // Parse UBO rule modifiers
        if (options.parseUboSpecificRules) {
            uboSelector = UboSelectorParser.parse(rawBody, options, baseOffset + bodyStart);
            rawBody = uboSelector.selector.value;
            // Do not allow ADG modifiers and UBO modifiers in the same rule
            if (uboSelector.modifiers && uboSelector.modifiers.children.length > 0) {
                // If modifiers are present, that means that the ADG modifier list was parsed
                expectCommonOrSpecificSyntax(AdblockSyntax.Ubo);
                // Change the syntax to uBO
                syntax = AdblockSyntax.Ubo;
                // Store the rule modifiers
                // Please note that not each special uBO modifier is a rule modifier, some of them are
                // used for CSS injection, for example `:style()` and `:remove()`
                for (const modifier of uboSelector.modifiers.children) {
                    // TODO: Add support for matches-media and element hiding rules
                    // TODO: Improve this condition if new uBO modifiers are added
                    if (modifier.name.value === UboPseudoName.MatchesPath) {
                        // Prepare the modifier list if it does not exist yet
                        if (!modifiers) {
                            modifiers = {
                                type: 'ModifierList',
                                children: [],
                            };
                            if (options.isLocIncluded) {
                                modifiers.start = baseOffset + bodyStart;
                                modifiers.end = baseOffset + bodyEnd;
                            }
                        }
                        modifiers.children.push(modifier);
                    }
                }
            }
        }
        const raws = {
            text: raw,
        };
        const baseRule = {
            category: RuleCategory.Cosmetic,
            exception,
            modifiers,
            domains,
            separator,
        };
        if (options.includeRaws) {
            baseRule.raws = raws;
        }
        if (options.isLocIncluded) {
            baseRule.start = baseOffset;
            baseRule.end = baseOffset + raw.length;
        }
        const parseUboCssInjection = () => {
            if (!uboSelector || !uboSelector.modifiers || uboSelector.modifiers.children?.length < 1) {
                return null;
            }
            expectCommonOrSpecificSyntax(AdblockSyntax.Ubo);
            const selectorList = uboSelector.selector;
            let declarationList;
            let mediaQueryList;
            let remove = false;
            for (const modifier of uboSelector.modifiers.children) {
                switch (modifier.name.value) {
                    case UboPseudoName.Style:
                        declarationList = modifier.value;
                        break;
                    case UboPseudoName.Remove:
                        declarationList = {
                            type: 'Value',
                            value: '',
                        };
                        remove = true;
                        break;
                    case UboPseudoName.MatchesMedia:
                        mediaQueryList = modifier.value;
                        break;
                }
            }
            // If neither `:style()` nor `:remove()` is present
            if (!declarationList) {
                return null;
            }
            const body = {
                type: 'CssInjectionRuleBody',
                selectorList,
                declarationList,
                mediaQueryList,
                remove,
            };
            if (options.isLocIncluded) {
                body.start = baseOffset + bodyStart;
                body.end = baseOffset + bodyEnd;
            }
            return {
                syntax: AdblockSyntax.Ubo,
                type: CosmeticRuleType.CssInjectionRule,
                body,
            };
        };
        const parseElementHiding = () => {
            const selectorList = {
                type: 'Value',
                value: rawBody,
            };
            if (options.isLocIncluded) {
                selectorList.start = baseOffset + bodyStart;
                selectorList.end = baseOffset + bodyEnd;
            }
            const body = {
                type: 'ElementHidingRuleBody',
                selectorList,
            };
            if (options.isLocIncluded) {
                body.start = baseOffset + bodyStart;
                body.end = baseOffset + bodyEnd;
            }
            return {
                syntax,
                type: CosmeticRuleType.ElementHidingRule,
                body,
            };
        };
        const parseAdgCssInjection = () => {
            // TODO: Improve this detection. Need to cover the following cases:
            // #$#body { color: red;
            // #$#@media (min-width: 100px) { body { color: red; }
            // ADG CSS injection
            if (!ADG_CSS_INJECTION_PATTERN.test(rawBody)) {
                return null;
            }
            expectCommonOrSpecificSyntax(AdblockSyntax.Adg);
            return {
                syntax: AdblockSyntax.Adg,
                type: CosmeticRuleType.CssInjectionRule,
                body: AdgCssInjectionParser.parse(rawBody, options, baseOffset + bodyStart),
            };
        };
        const parseAbpSnippetInjection = () => {
            if (!options.parseAbpSpecificRules) {
                throw new AdblockSyntaxError(sprintf(ERROR_MESSAGES$3.SYNTAX_DISABLED, AdblockSyntax.Abp), baseOffset + bodyStart, baseOffset + bodyEnd);
            }
            expectCommonOrSpecificSyntax(AdblockSyntax.Abp);
            const body = AbpSnippetInjectionBodyParser.parse(rawBody, options, baseOffset + bodyStart);
            if (options.isLocIncluded) {
                body.start = baseOffset + bodyStart;
                body.end = baseOffset + bodyEnd;
            }
            return {
                syntax: AdblockSyntax.Abp,
                type: CosmeticRuleType.ScriptletInjectionRule,
                body,
            };
        };
        const parseUboScriptletInjection = () => {
            if (!rawBody.startsWith(UBO_SCRIPTLET_MASK) && !rawBody.startsWith(UBO_SCRIPTLET_MASK_LEGACY)) {
                return null;
            }
            if (!options.parseUboSpecificRules) {
                throw new AdblockSyntaxError(sprintf(ERROR_MESSAGES$3.SYNTAX_DISABLED, AdblockSyntax.Ubo), baseOffset + bodyStart, baseOffset + bodyEnd);
            }
            expectCommonOrSpecificSyntax(AdblockSyntax.Ubo);
            const body = UboScriptletInjectionBodyParser.parse(rawBody, options, baseOffset + bodyStart);
            if (options.isLocIncluded) {
                body.start = baseOffset + bodyStart;
                body.end = baseOffset + bodyEnd;
            }
            return {
                syntax: AdblockSyntax.Ubo,
                type: CosmeticRuleType.ScriptletInjectionRule,
                body,
            };
        };
        const parseAdgScriptletInjection = () => {
            // ADG scriptlet injection
            if (!rawBody.startsWith(ADG_SCRIPTLET_MASK)) {
                return null;
            }
            expectCommonOrSpecificSyntax(AdblockSyntax.Adg);
            const body = AdgScriptletInjectionBodyParser.parse(rawBody, options, baseOffset + bodyStart);
            if (options.isLocIncluded) {
                body.start = baseOffset + bodyStart;
                body.end = baseOffset + bodyEnd;
            }
            return {
                syntax: AdblockSyntax.Adg,
                type: CosmeticRuleType.ScriptletInjectionRule,
                body,
            };
        };
        const parseAdgJsInjection = () => {
            expectCommonOrSpecificSyntax(AdblockSyntax.Adg);
            const body = {
                type: 'Value',
                value: rawBody,
            };
            if (options.isLocIncluded) {
                body.start = baseOffset + bodyStart;
                body.end = baseOffset + bodyEnd;
            }
            return {
                syntax: AdblockSyntax.Adg,
                type: CosmeticRuleType.JsInjectionRule,
                body,
            };
        };
        const parseUboHtmlFiltering = () => {
            if (!rawBody.startsWith(UBO_HTML_MASK)) {
                return null;
            }
            if (!options.parseUboSpecificRules) {
                throw new AdblockSyntaxError(sprintf(ERROR_MESSAGES$3.SYNTAX_DISABLED, AdblockSyntax.Ubo), baseOffset + bodyStart, baseOffset + bodyEnd);
            }
            expectCommonOrSpecificSyntax(AdblockSyntax.Ubo);
            const body = {
                type: 'Value',
                value: rawBody,
            };
            if (options.isLocIncluded) {
                body.start = baseOffset + bodyStart;
                body.end = baseOffset + bodyEnd;
            }
            return {
                syntax: AdblockSyntax.Ubo,
                type: CosmeticRuleType.HtmlFilteringRule,
                body,
            };
        };
        const parseAdgHtmlFiltering = () => {
            expectCommonOrSpecificSyntax(AdblockSyntax.Adg);
            const body = {
                type: 'Value',
                value: rawBody,
            };
            if (options.isLocIncluded) {
                body.start = baseOffset + bodyStart;
                body.end = baseOffset + bodyEnd;
            }
            return {
                syntax: AdblockSyntax.Adg,
                type: CosmeticRuleType.HtmlFilteringRule,
                body,
            };
        };
        // Create a fast lookup table for cosmetic rule separators and their parsing functions.
        // One separator can have multiple parsing functions. If the first function returns null,
        // the next function is called, and so on.
        // If all functions return null, an error should be thrown.
        const separatorMap = {
            '##': [parseUboHtmlFiltering, parseUboScriptletInjection, parseUboCssInjection, parseElementHiding],
            '#@#': [parseUboHtmlFiltering, parseUboScriptletInjection, parseUboCssInjection, parseElementHiding],
            '#?#': [parseUboCssInjection, parseElementHiding],
            '#@?#': [parseUboCssInjection, parseElementHiding],
            '#$#': [parseAdgCssInjection, parseAbpSnippetInjection],
            '#@$#': [parseAdgCssInjection, parseAbpSnippetInjection],
            '#$?#': [parseAdgCssInjection],
            '#@$?#': [parseAdgCssInjection],
            '#%#': [parseAdgScriptletInjection, parseAdgJsInjection],
            '#@%#': [parseAdgScriptletInjection, parseAdgJsInjection],
            $$: [parseAdgHtmlFiltering],
            '$@$': [parseAdgHtmlFiltering],
        };
        const parseFunctions = separatorMap[separatorResult.separator];
        let restProps;
        for (const parseFunction of parseFunctions) {
            restProps = parseFunction();
            if (restProps) {
                break;
            }
        }
        // If none of the parsing functions returned a result, it means that the rule is unknown / invalid.
        if (!restProps) {
            throw new AdblockSyntaxError(sprintf(ERROR_MESSAGES$3.INVALID_BODY_FOR_SEPARATOR, rawBody, separatorResult.separator), baseOffset + bodyStart, baseOffset + bodyEnd);
        }
        // Combine the base rule with the rest of the properties.
        return {
            ...baseRule,
            ...restProps,
        };
    }
    /**
     * Generates the rule pattern from the AST.
     *
     * @param node Cosmetic rule node
     * @returns Raw rule pattern
     * @example
     * - '##.foo' â†’ ''
     * - 'example.com,example.org##.foo' â†’ 'example.com,example.org'
     * - '[$path=/foo/bar]example.com##.foo' â†’ '[$path=/foo/bar]example.com'
     */
    static generatePattern(node) {
        let result = EMPTY;
        // AdGuard modifiers (if any)
        if (node.syntax === AdblockSyntax.Adg && node.modifiers && node.modifiers.children.length > 0) {
            result += OPEN_SQUARE_BRACKET;
            result += DOLLAR_SIGN;
            result += ModifierListParser.generate(node.modifiers);
            result += CLOSE_SQUARE_BRACKET;
        }
        // Domain list (if any)
        result += DomainListParser.generate(node.domains);
        return result;
    }
    /**
     * Generates the rule body from the node.
     *
     * @param node Cosmetic rule node
     * @returns Raw rule body
     * @example
     * - '##.foo' â†’ '.foo'
     * - 'example.com,example.org##.foo' â†’ '.foo'
     * - 'example.com#%#//scriptlet('foo')' â†’ '//scriptlet('foo')'
     */
    static generateBody(node) {
        let result = EMPTY;
        // Body
        switch (node.type) {
            case CosmeticRuleType.ElementHidingRule:
                result = node.body.selectorList.value;
                break;
            case CosmeticRuleType.CssInjectionRule:
                if (node.syntax === AdblockSyntax.Adg) {
                    result = AdgCssInjectionParser.generate(node.body);
                }
                else if (node.syntax === AdblockSyntax.Ubo) {
                    if (node.body.mediaQueryList) {
                        result += COLON;
                        result += UboPseudoName.MatchesMedia;
                        result += OPEN_PARENTHESIS;
                        result += node.body.mediaQueryList.value;
                        result += CLOSE_PARENTHESIS;
                        result += SPACE;
                    }
                    result += node.body.selectorList.value;
                    if (node.body.remove) {
                        result += COLON;
                        result += UboPseudoName.Remove;
                        result += OPEN_PARENTHESIS;
                        result += CLOSE_PARENTHESIS;
                    }
                    else if (node.body.declarationList) {
                        result += COLON;
                        result += UboPseudoName.Style;
                        result += OPEN_PARENTHESIS;
                        result += node.body.declarationList.value;
                        result += CLOSE_PARENTHESIS;
                    }
                }
                break;
            case CosmeticRuleType.HtmlFilteringRule:
            case CosmeticRuleType.JsInjectionRule:
                result = node.body.value;
                break;
            case CosmeticRuleType.ScriptletInjectionRule:
                switch (node.syntax) {
                    case AdblockSyntax.Adg:
                        result = AdgScriptletInjectionBodyParser.generate(node.body);
                        break;
                    case AdblockSyntax.Abp:
                        result = AbpSnippetInjectionBodyParser.generate(node.body);
                        break;
                    case AdblockSyntax.Ubo:
                        result = UboScriptletInjectionBodyParser.generate(node.body);
                        break;
                    default:
                        throw new Error('Scriptlet rule should have an explicit syntax');
                }
                break;
            default:
                throw new Error('Unknown cosmetic rule type');
        }
        return result;
    }
    /**
     * Converts a cosmetic rule AST into a string.
     *
     * @param node Cosmetic rule AST
     * @returns Raw string
     */
    static generate(node) {
        let result = EMPTY;
        // Pattern
        result += CosmeticRuleParser.generatePattern(node);
        // Separator
        result += node.separator.value;
        // uBO rule modifiers
        if (node.syntax === AdblockSyntax.Ubo && node.modifiers) {
            node.modifiers.children.forEach((modifier) => {
                result += COLON;
                result += modifier.name.value;
                if (modifier.value) {
                    result += OPEN_PARENTHESIS;
                    result += modifier.value.value;
                    result += CLOSE_PARENTHESIS;
                }
            });
            // If there are at least one modifier, add a space
            if (node.modifiers.children.length) {
                result += SPACE;
            }
        }
        // Body
        result += CosmeticRuleParser.generateBody(node);
        return result;
    }
    /**
     * Serializes an element hiding rule body node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serializeElementHidingBody(node, buffer) {
        buffer.writeUint8(BinaryTypeMap.ElementHidingRuleBody);
        buffer.writeUint8(ElementHidingRuleSerializationMap.SelectorList);
        ValueParser.serialize(node.selectorList, buffer);
        if (!isUndefined(node.start)) {
            buffer.writeUint8(ElementHidingRuleSerializationMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(ElementHidingRuleSerializationMap.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Deserializes an element hiding rule body node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserializeElementHidingBody(buffer, node) {
        buffer.assertUint8(BinaryTypeMap.ElementHidingRuleBody);
        node.type = 'ElementHidingRuleBody';
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case ElementHidingRuleSerializationMap.SelectorList:
                    ValueParser.deserialize(buffer, node.selectorList = {});
                    break;
                case ElementHidingRuleSerializationMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case ElementHidingRuleSerializationMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Unknown property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
    /**
     * Serializes a CSS injection rule body node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serializeCssInjectionBody(node, buffer) {
        buffer.writeUint8(BinaryTypeMap.CssInjectionRuleBody);
        if (node.mediaQueryList) {
            buffer.writeUint8(CssInjectionRuleSerializationMap.MediaQueryList);
            ValueParser.serialize(node.mediaQueryList, buffer);
        }
        buffer.writeUint8(CssInjectionRuleSerializationMap.SelectorList);
        ValueParser.serialize(node.selectorList, buffer);
        if (node.declarationList) {
            buffer.writeUint8(CssInjectionRuleSerializationMap.DeclarationList);
            ValueParser.serialize(node.declarationList, buffer);
        }
        if (node.remove) {
            buffer.writeUint8(CssInjectionRuleSerializationMap.Remove);
        }
        if (!isUndefined(node.start)) {
            buffer.writeUint8(CssInjectionRuleSerializationMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(CssInjectionRuleSerializationMap.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Deserializes CSS injection rule body node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserializeCssInjectionBody(buffer, node) {
        buffer.assertUint8(BinaryTypeMap.CssInjectionRuleBody);
        node.type = 'CssInjectionRuleBody';
        node.remove = false;
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case CssInjectionRuleSerializationMap.MediaQueryList:
                    ValueParser.deserialize(buffer, node.mediaQueryList = {});
                    break;
                case CssInjectionRuleSerializationMap.SelectorList:
                    ValueParser.deserialize(buffer, node.selectorList = {});
                    break;
                case CssInjectionRuleSerializationMap.DeclarationList:
                    ValueParser.deserialize(buffer, node.declarationList = {});
                    break;
                case CssInjectionRuleSerializationMap.Remove:
                    node.remove = true;
                    break;
                case CssInjectionRuleSerializationMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case CssInjectionRuleSerializationMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Unknown property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
    /**
     * Serializes a cosmetic rule node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    // TODO: add support for raws, if ever needed
    static serialize(node, buffer) {
        // specific properties
        switch (node.type) {
            case CosmeticRuleType.ElementHidingRule:
                // rule type
                buffer.writeUint8(BinaryTypeMap.ElementHidingRule);
                // syntax
                buffer.writeUint8(SYNTAX_SERIALIZATION_MAP.get(node.syntax) ?? 0);
                // rule body
                CosmeticRuleParser.serializeElementHidingBody(node.body, buffer);
                break;
            case CosmeticRuleType.CssInjectionRule:
                // rule type
                buffer.writeUint8(BinaryTypeMap.CssInjectionRule);
                // syntax
                buffer.writeUint8(SYNTAX_SERIALIZATION_MAP.get(node.syntax) ?? 0);
                // rule body
                CosmeticRuleParser.serializeCssInjectionBody(node.body, buffer);
                break;
            case CosmeticRuleType.JsInjectionRule:
                // rule type
                buffer.writeUint8(BinaryTypeMap.JsInjectionRule);
                // syntax
                buffer.writeUint8(SYNTAX_SERIALIZATION_MAP.get(node.syntax) ?? 0);
                // rule body
                ValueParser.serialize(node.body, buffer);
                break;
            case CosmeticRuleType.HtmlFilteringRule:
                // rule type
                buffer.writeUint8(BinaryTypeMap.HtmlFilteringRule);
                // syntax
                buffer.writeUint8(SYNTAX_SERIALIZATION_MAP.get(node.syntax) ?? 0);
                // rule body
                ValueParser.serialize(node.body, buffer);
                break;
            case CosmeticRuleType.ScriptletInjectionRule:
                // rule type
                buffer.writeUint8(BinaryTypeMap.ScriptletInjectionRule);
                // syntax
                buffer.writeUint8(SYNTAX_SERIALIZATION_MAP.get(node.syntax) ?? 0);
                // rule body
                switch (node.syntax) {
                    case AdblockSyntax.Adg:
                        AdgScriptletInjectionBodyParser.serialize(node.body, buffer);
                        break;
                    case AdblockSyntax.Abp:
                        AbpSnippetInjectionBodyParser.serialize(node.body, buffer);
                        break;
                    case AdblockSyntax.Ubo:
                        UboScriptletInjectionBodyParser.serialize(node.body, buffer);
                        break;
                    default:
                        throw new Error('Scriptlet rule should have an explicit syntax');
                }
                break;
            default:
                throw new Error('Unknown cosmetic rule type');
        }
        // common properties
        buffer.writeUint8(CosmeticRuleSerializationMap.Exception);
        buffer.writeUint8(node.exception ? 1 : 0);
        buffer.writeUint8(CosmeticRuleSerializationMap.Separator);
        ValueParser.serialize(node.separator, buffer, SEPARATOR_SERIALIZATION_MAP);
        if (node.modifiers) {
            buffer.writeUint8(CosmeticRuleSerializationMap.Modifiers);
            ModifierListParser.serialize(node.modifiers, buffer);
        }
        buffer.writeUint8(CosmeticRuleSerializationMap.Domains);
        DomainListParser.serialize(node.domains, buffer);
        if (!isUndefined(node.start)) {
            buffer.writeUint8(CosmeticRuleSerializationMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(CosmeticRuleSerializationMap.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Deserializes a cosmetic rule node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer, node) {
        const type = COSMETIC_RULE_TYPE_DESERIALIZATION_MAP.get(buffer.readUint8());
        if (isUndefined(type)) {
            throw new Error(`Unknown rule type: ${type}`);
        }
        node.type = type;
        node.category = RuleCategory.Cosmetic;
        const syntax = SYNTAX_DESERIALIZATION_MAP.get(buffer.readUint8()) ?? AdblockSyntax.Common;
        node.syntax = syntax;
        node.modifiers = undefined;
        switch (type) {
            case CosmeticRuleType.ElementHidingRule:
                CosmeticRuleParser.deserializeElementHidingBody(buffer, node.body = {});
                break;
            case CosmeticRuleType.CssInjectionRule:
                CosmeticRuleParser.deserializeCssInjectionBody(buffer, node.body = {});
                break;
            case CosmeticRuleType.JsInjectionRule:
                ValueParser.deserialize(buffer, node.body = {});
                break;
            case CosmeticRuleType.HtmlFilteringRule:
                ValueParser.deserialize(buffer, node.body = {});
                break;
            case CosmeticRuleType.ScriptletInjectionRule:
                switch (syntax) {
                    case AdblockSyntax.Adg:
                        // eslint-disable-next-line max-len
                        AdgScriptletInjectionBodyParser.deserialize(buffer, node.body = {});
                        break;
                    case AdblockSyntax.Abp:
                        AbpSnippetInjectionBodyParser.deserialize(buffer, node.body = {});
                        break;
                    case AdblockSyntax.Ubo:
                        // eslint-disable-next-line max-len
                        UboScriptletInjectionBodyParser.deserialize(buffer, node.body = {});
                        break;
                    default:
                        throw new Error('Scriptlet rule should have an explicit syntax');
                }
                break;
            default:
                throw new Error('Unknown cosmetic rule type');
        }
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case CosmeticRuleSerializationMap.Exception:
                    node.exception = buffer.readUint8() === 1;
                    break;
                case CosmeticRuleSerializationMap.Separator:
                    ValueParser.deserialize(buffer, node.separator = {}, SEPARATOR_DESERIALIZATION_MAP);
                    break;
                case CosmeticRuleSerializationMap.Modifiers:
                    node.modifiers = {};
                    ModifierListParser.deserialize(buffer, node.modifiers);
                    break;
                case CosmeticRuleSerializationMap.Domains:
                    DomainListParser.deserialize(buffer, node.domains = {});
                    break;
                case CosmeticRuleSerializationMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case CosmeticRuleSerializationMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Unknown property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
}

/* eslint-disable no-param-reassign */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
var NetworkRuleSerializationMap;
(function (NetworkRuleSerializationMap) {
    NetworkRuleSerializationMap[NetworkRuleSerializationMap["Syntax"] = 1] = "Syntax";
    NetworkRuleSerializationMap[NetworkRuleSerializationMap["Raws"] = 2] = "Raws";
    NetworkRuleSerializationMap[NetworkRuleSerializationMap["Exception"] = 3] = "Exception";
    NetworkRuleSerializationMap[NetworkRuleSerializationMap["Pattern"] = 4] = "Pattern";
    NetworkRuleSerializationMap[NetworkRuleSerializationMap["ModifierList"] = 5] = "ModifierList";
    NetworkRuleSerializationMap[NetworkRuleSerializationMap["Start"] = 6] = "Start";
    NetworkRuleSerializationMap[NetworkRuleSerializationMap["End"] = 7] = "End";
})(NetworkRuleSerializationMap || (NetworkRuleSerializationMap = {}));
/**
 * `NetworkRuleParser` is responsible for parsing network rules.
 *
 * Please note that this will parse all syntactically correct network rules.
 * Modifier compatibility is not checked at the parser level.
 *
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules}
 * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#basic}
 */
class NetworkRuleParser extends ParserBase {
    /**
     * Parses a network rule (also known as basic rule).
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Network rule AST
     *
     * @throws If the rule is syntactically incorrect.
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0) {
        let offset = 0;
        // Skip leading whitespace
        offset = StringUtils.skipWS(raw, offset);
        // Handle exception rules
        let exception = false;
        // Rule starts with exception marker, eg @@||example.com,
        // where @@ is the exception marker
        if (raw.startsWith(NETWORK_RULE_EXCEPTION_MARKER, offset)) {
            offset += NETWORK_RULE_EXCEPTION_MARKER_LEN;
            exception = true;
        }
        // Save the start of the pattern
        const patternStart = offset;
        // Find corresponding (last) separator ($) character (if any)
        const separatorIndex = NetworkRuleParser.findNetworkRuleSeparatorIndex(raw);
        // Save the end of the pattern
        const patternEnd = separatorIndex === -1
            ? StringUtils.skipWSBack(raw) + 1
            : StringUtils.skipWSBack(raw, separatorIndex - 1) + 1;
        // Parse pattern
        const pattern = ValueParser.parse(raw.slice(patternStart, patternEnd), options, baseOffset + patternStart);
        // Parse modifiers (if any)
        let modifiers;
        // Find start and end index of the modifiers
        const modifiersStart = separatorIndex + 1;
        const modifiersEnd = StringUtils.skipWSBack(raw) + 1;
        if (separatorIndex !== -1) {
            modifiers = ModifierListParser.parse(raw.slice(modifiersStart, modifiersEnd), options, baseOffset + modifiersStart);
        }
        // Throw error if there is no pattern and no modifiers
        if (pattern.value.length === 0 && (modifiers === undefined || modifiers.children.length === 0)) {
            throw new AdblockSyntaxError('Network rule must have a pattern or modifiers', baseOffset, baseOffset + raw.length);
        }
        const result = {
            type: NetworkRuleType.NetworkRule,
            category: RuleCategory.Network,
            syntax: AdblockSyntax.Common,
            exception,
            pattern,
            modifiers,
        };
        if (options.includeRaws) {
            result.raws = {
                text: raw,
            };
        }
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        return result;
    }
    /**
     * Finds the index of the separator character in a network rule.
     *
     * @param rule Network rule to check
     * @returns The index of the separator character, or -1 if there is no separator
     */
    static findNetworkRuleSeparatorIndex(rule) {
        // As we are looking for the last separator, we start from the end of the string
        for (let i = rule.length - 1; i >= 0; i -= 1) {
            // If we find a potential separator, we should check
            // - if it's not escaped
            // - if it's not followed by a regex marker, for example: `example.org^$removeparam=/regex$/`
            // eslint-disable-next-line max-len
            if (rule[i] === NETWORK_RULE_SEPARATOR && rule[i + 1] !== REGEX_MARKER && rule[i - 1] !== ESCAPE_CHARACTER) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Converts a network rule (basic rule) AST to a string.
     *
     * @param node Network rule node
     * @returns Raw string
     */
    static generate(node) {
        let result = EMPTY;
        // If the rule is an exception, add the exception marker: `@@||example.org`
        if (node.exception) {
            result += NETWORK_RULE_EXCEPTION_MARKER;
        }
        // Add the pattern: `||example.org`
        result += node.pattern.value;
        // If there are modifiers, add a separator and the modifiers: `||example.org$important`
        if (node.modifiers && node.modifiers.children.length > 0) {
            result += NETWORK_RULE_SEPARATOR;
            result += ModifierListParser.generate(node.modifiers);
        }
        return result;
    }
    /**
     * Serializes a network rule node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    // TODO: add support for raws, if ever needed
    static serialize(node, buffer) {
        buffer.writeUint8(BinaryTypeMap.NetworkRuleNode);
        buffer.writeUint8(NetworkRuleSerializationMap.Syntax);
        buffer.writeUint8(SYNTAX_SERIALIZATION_MAP.get(node.syntax) ?? 0);
        buffer.writeUint8(NetworkRuleSerializationMap.Exception);
        buffer.writeUint8(node.exception ? 1 : 0);
        buffer.writeUint8(NetworkRuleSerializationMap.Pattern);
        ValueParser.serialize(node.pattern, buffer);
        if (!isUndefined(node.modifiers)) {
            buffer.writeUint8(NetworkRuleSerializationMap.ModifierList);
            ModifierListParser.serialize(node.modifiers, buffer);
        }
        if (!isUndefined(node.start)) {
            buffer.writeUint8(NetworkRuleSerializationMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(NetworkRuleSerializationMap.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Deserializes a modifier node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(BinaryTypeMap.NetworkRuleNode);
        node.type = NetworkRuleType.NetworkRule;
        node.category = RuleCategory.Network;
        node.modifiers = undefined;
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case NetworkRuleSerializationMap.Syntax:
                    node.syntax = SYNTAX_DESERIALIZATION_MAP.get(buffer.readUint8()) ?? AdblockSyntax.Common;
                    break;
                case NetworkRuleSerializationMap.Exception:
                    node.exception = buffer.readUint8() === 1;
                    break;
                case NetworkRuleSerializationMap.Pattern:
                    ValueParser.deserialize(buffer, node.pattern = {});
                    break;
                case NetworkRuleSerializationMap.ModifierList:
                    ModifierListParser.deserialize(buffer, node.modifiers = {});
                    break;
                case NetworkRuleSerializationMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case NetworkRuleSerializationMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}.`);
            }
            prop = buffer.readUint8();
        }
    }
}

/* eslint-disable no-param-reassign */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
var HostRuleSerializationMap;
(function (HostRuleSerializationMap) {
    HostRuleSerializationMap[HostRuleSerializationMap["Syntax"] = 1] = "Syntax";
    HostRuleSerializationMap[HostRuleSerializationMap["Raws"] = 2] = "Raws";
    HostRuleSerializationMap[HostRuleSerializationMap["Ip"] = 3] = "Ip";
    HostRuleSerializationMap[HostRuleSerializationMap["HostnameList"] = 4] = "HostnameList";
    HostRuleSerializationMap[HostRuleSerializationMap["Comment"] = 5] = "Comment";
    HostRuleSerializationMap[HostRuleSerializationMap["Start"] = 6] = "Start";
    HostRuleSerializationMap[HostRuleSerializationMap["End"] = 7] = "End";
})(HostRuleSerializationMap || (HostRuleSerializationMap = {}));
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
var HostnameListNodeSerializationMap;
(function (HostnameListNodeSerializationMap) {
    HostnameListNodeSerializationMap[HostnameListNodeSerializationMap["Children"] = 1] = "Children";
    HostnameListNodeSerializationMap[HostnameListNodeSerializationMap["Start"] = 2] = "Start";
    HostnameListNodeSerializationMap[HostnameListNodeSerializationMap["End"] = 3] = "End";
})(HostnameListNodeSerializationMap || (HostnameListNodeSerializationMap = {}));
/**
 * `HostRuleParser` is responsible for parsing hosts-like rules.
 *
 * HostRule is a structure for simple host-level rules (i.e. /etc/hosts syntax).
 * It also supports "just domain" syntax. In this case, the IP will be set to 0.0.0.0.
 *
 * Rules syntax looks like this:
 * ```text
 * IP_address canonical_hostname [aliases...]
 * ```
 *
 * @example
 * `192.168.1.13 bar.mydomain.org bar` -- ipv4
 * `ff02::1 ip6-allnodes` -- ipv6
 * `::1 localhost ip6-localhost ip6-loopback` -- ipv6 aliases
 * `example.org` -- "just domain" syntax
 * @see {@link http://man7.org/linux/man-pages/man5/hosts.5.html}
 */
class HostRuleParser extends ParserBase {
    static NULL_IP = '0.0.0.0';
    static COMMENT_MARKER = '#';
    /**
     * Parses an etc/hosts-like rule.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Host rule node.
     *
     * @throws If the input contains invalid data.
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0) {
        let offset = StringUtils.skipWS(raw, 0);
        const parts = [];
        let lastPartStartIndex = offset;
        let comment = null;
        const rawLength = raw.length;
        const parsePartIfNeeded = (startIndex, endIndex) => {
            if (startIndex < endIndex) {
                parts.push(ValueParser.parse(raw.slice(startIndex, endIndex), options, baseOffset + startIndex));
            }
        };
        while (offset < rawLength) {
            if (StringUtils.isWhitespace(raw[offset])) {
                parsePartIfNeeded(lastPartStartIndex, offset);
                offset = StringUtils.skipWS(raw, offset);
                lastPartStartIndex = offset;
            }
            else if (raw[offset] === HostRuleParser.COMMENT_MARKER) {
                const commentStart = offset;
                offset = StringUtils.skipWS(raw, offset + 1);
                comment = ValueParser.parse(raw.slice(offset), options, baseOffset + commentStart);
                offset = rawLength;
                lastPartStartIndex = offset;
            }
            else {
                offset += 1;
            }
        }
        parsePartIfNeeded(lastPartStartIndex, offset);
        const partsLength = parts.length;
        if (partsLength < 1) {
            throw new Error('Host rule must have at least one domain name or an IP address and a domain name');
        }
        const result = {
            category: RuleCategory.Network,
            type: NetworkRuleType.HostRule,
            syntax: AdblockSyntax.Common,
        };
        if (partsLength === 1) {
            // "Just domain" syntax, e.g. `example.org`
            // In this case, domain should be valid and IP will be set to 0.0.0.0 by default
            if (tldts.getDomain(parts[0].value) !== parts[0].value) {
                throw new Error(`Not a valid domain: ${parts[0].value}`);
            }
            result.ip = {
                type: 'Value',
                value: HostRuleParser.NULL_IP,
            };
            result.hostnames = {
                type: 'HostnameList',
                children: parts,
            };
        }
        else if (partsLength > 1) {
            // IP + domain list syntax
            const [ip, ...hostnames] = parts;
            if (!isIp(ip.value)) {
                throw new Error(`Invalid IP address: ${ip.value}`);
            }
            for (const { value } of hostnames) {
                if (tldts.getHostname(value) !== value) {
                    throw new Error(`Not a valid hostname: ${value}`);
                }
            }
            result.ip = ip;
            result.hostnames = {
                type: 'HostnameList',
                children: hostnames,
            };
        }
        if (comment) {
            result.comment = comment;
        }
        if (options.includeRaws) {
            result.raws = {
                text: raw,
            };
        }
        return result;
    }
    /**
     * Converts a host rule node to a raw string.
     *
     * @param node Host rule node.
     * @returns Raw string.
     */
    static generate(node) {
        const result = [];
        if (node.ip) {
            result.push(node.ip.value);
        }
        if (node.hostnames) {
            result.push(SPACE);
            result.push(node.hostnames.children.map(({ value }) => value).join(SPACE));
        }
        if (node.comment) {
            result.push(SPACE);
            result.push(HostRuleParser.COMMENT_MARKER);
            result.push(SPACE);
            result.push(node.comment.value);
        }
        return result.join(EMPTY);
    }
    /**
     * Serializes a hostname list node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serializeHostnameList(node, buffer) {
        buffer.writeUint8(BinaryTypeMap.HostnameListNode);
        if (!isUndefined(node.start)) {
            buffer.writeUint8(HostnameListNodeSerializationMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(HostnameListNodeSerializationMap.End);
            buffer.writeUint32(node.end);
        }
        const count = node.children.length;
        if (count) {
            // note: we store the count, because re-construction of the array is faster if we know the length
            if (count > UINT16_MAX) {
                throw new Error(`Too many children: ${count}, the limit is ${UINT16_MAX}`);
            }
            buffer.writeUint8(HostnameListNodeSerializationMap.Children);
            buffer.writeUint16(count);
            for (let i = 0; i < count; i += 1) {
                ValueParser.serialize(node.children[i], buffer);
            }
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Deserializes a hostname list node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserializeHostnameList(buffer, node) {
        buffer.assertUint8(BinaryTypeMap.HostnameListNode);
        node.type = 'HostnameList';
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case HostnameListNodeSerializationMap.Children:
                    node.children = new Array(buffer.readUint16());
                    // read children
                    for (let i = 0; i < node.children.length; i += 1) {
                        ValueParser.deserialize(buffer, node.children[i] = {});
                    }
                    break;
                case HostnameListNodeSerializationMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case HostnameListNodeSerializationMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Unknown property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
    /**
     * Serializes a host rule node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    // TODO: add support for raws, if ever needed
    static serialize(node, buffer) {
        buffer.writeUint8(BinaryTypeMap.HostRuleNode);
        buffer.writeUint8(HostRuleSerializationMap.Syntax);
        buffer.writeUint8(SYNTAX_SERIALIZATION_MAP.get(node.syntax) ?? 0);
        if (node.ip) {
            buffer.writeUint8(HostRuleSerializationMap.Ip);
            ValueParser.serialize(node.ip, buffer);
        }
        if (node.hostnames) {
            buffer.writeUint8(HostRuleSerializationMap.HostnameList);
            HostRuleParser.serializeHostnameList(node.hostnames, buffer);
        }
        if (node.comment) {
            buffer.writeUint8(HostRuleSerializationMap.Comment);
            ValueParser.serialize(node.comment, buffer);
        }
        if (!isUndefined(node.start)) {
            buffer.writeUint8(HostRuleSerializationMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(HostRuleSerializationMap.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Deserializes a modifier node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(BinaryTypeMap.HostRuleNode);
        node.category = RuleCategory.Network;
        node.type = NetworkRuleType.HostRule;
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case HostRuleSerializationMap.Syntax:
                    node.syntax = SYNTAX_DESERIALIZATION_MAP.get(buffer.readUint8()) ?? AdblockSyntax.Common;
                    break;
                case HostRuleSerializationMap.Ip:
                    node.ip = {};
                    ValueParser.deserialize(buffer, node.ip);
                    break;
                case HostRuleSerializationMap.HostnameList:
                    node.hostnames = {};
                    HostRuleParser.deserializeHostnameList(buffer, node.hostnames);
                    break;
                case HostRuleSerializationMap.Comment:
                    node.comment = {};
                    ValueParser.deserialize(buffer, node.comment);
                    break;
                case HostRuleSerializationMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case HostRuleSerializationMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}.`);
            }
            prop = buffer.readUint8();
        }
    }
}

/* eslint-disable no-param-reassign */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
var EmptyRuleSerializationMap;
(function (EmptyRuleSerializationMap) {
    EmptyRuleSerializationMap[EmptyRuleSerializationMap["Start"] = 1] = "Start";
    EmptyRuleSerializationMap[EmptyRuleSerializationMap["End"] = 2] = "End";
})(EmptyRuleSerializationMap || (EmptyRuleSerializationMap = {}));
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
var InvalidRuleErrorNodeSerializationMap;
(function (InvalidRuleErrorNodeSerializationMap) {
    InvalidRuleErrorNodeSerializationMap[InvalidRuleErrorNodeSerializationMap["Name"] = 1] = "Name";
    InvalidRuleErrorNodeSerializationMap[InvalidRuleErrorNodeSerializationMap["Message"] = 2] = "Message";
    InvalidRuleErrorNodeSerializationMap[InvalidRuleErrorNodeSerializationMap["Start"] = 3] = "Start";
    InvalidRuleErrorNodeSerializationMap[InvalidRuleErrorNodeSerializationMap["End"] = 4] = "End";
})(InvalidRuleErrorNodeSerializationMap || (InvalidRuleErrorNodeSerializationMap = {}));
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the binary schema version.!
 *
 * @note Only 256 values can be represented this way.
 */
var InvalidRuleSerializationMap;
(function (InvalidRuleSerializationMap) {
    InvalidRuleSerializationMap[InvalidRuleSerializationMap["Error"] = 1] = "Error";
    InvalidRuleSerializationMap[InvalidRuleSerializationMap["Start"] = 2] = "Start";
    InvalidRuleSerializationMap[InvalidRuleSerializationMap["End"] = 3] = "End";
})(InvalidRuleSerializationMap || (InvalidRuleSerializationMap = {}));
/**
 * `RuleParser` is responsible for parsing the rules.
 *
 * It automatically determines the category and syntax of the rule, so you can pass any kind of rule to it.
 */
class RuleParser extends ParserBase {
    /**
     * Helper method to parse host rules if the `parseHostRules` option is enabled, otherwise it will
     * parse network rules.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Host rule or network rule node.
     */
    static parseHostOrNetworkRule(raw, options, baseOffset) {
        if (options.parseHostRules) {
            try {
                return HostRuleParser.parse(raw, options, baseOffset);
            }
            catch (error) {
                // Ignore the error, and fall back to network rule parser
            }
        }
        return NetworkRuleParser.parse(raw, options, baseOffset);
    }
    /**
     * Parse an adblock rule. You can pass any kind of rule to this method, since it will automatically determine
     * the category and syntax. If the rule is syntactically invalid, then an error will be thrown. If the
     * syntax / compatibility cannot be determined clearly, then the value of the `syntax` property will be
     * `Common`.
     *
     * For example, let's have this network rule:
     * ```adblock
     * ||example.org^$important
     * ```
     * The `syntax` property will be `Common`, since the rule is syntactically correct in every adblockers, but we
     * cannot determine at parsing level whether `important` is an existing option or not, nor if it exists, then
     * which adblocker supports it. This is why the `syntax` property is simply `Common` at this point.
     * The concrete COMPATIBILITY of the rule will be determined later, in a different, higher-level layer, called
     * "Compatibility table".
     *
     * But we can determinate the concrete syntax of this rule:
     * ```adblock
     * example.org#%#//scriptlet("scriptlet0", "arg0")
     * ```
     * since it is clearly an AdGuard-specific rule and no other adblockers uses this syntax natively. However, we also
     * cannot determine the COMPATIBILITY of this rule, as it is not clear at this point whether the `scriptlet0`
     * scriptlet is supported by AdGuard or not. This is also the task of the "Compatibility table". Here, we simply
     * mark the rule with the `AdGuard` syntax in this case.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Adblock rule node
     * @throws If the input matches a pattern but syntactically invalid
     * @example
     * Take a look at the following example:
     * ```js
     * // Parse a network rule
     * const ast1 = RuleParser.parse("||example.org^$important");
     *
     * // Parse another network rule
     * const ast2 = RuleParser.parse("/ads.js^$important,third-party,domain=example.org|~example.com");
     *
     * // Parse a cosmetic rule
     * const ast2 = RuleParser.parse("example.org##.banner");
     *
     * // Parse another cosmetic rule
     * const ast3 = RuleParser.parse("example.org#?#.banner:-abp-has(.ad)");
     *
     * // Parse a comment rule
     * const ast4 = RuleParser.parse("! Comment");
     *
     * // Parse an empty rule
     * const ast5 = RuleParser.parse("");
     *
     * // Parse a comment rule (with metadata)
     * const ast6 = RuleParser.parse("! Title: Example");
     *
     * // Parse a pre-processor rule
     * const ast7 = RuleParser.parse("!#if (adguard)");
     * ```
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0) {
        try {
            // Empty lines / rules (handle it just for convenience)
            if (raw.trim().length === 0) {
                const result = {
                    type: 'EmptyRule',
                    category: RuleCategory.Empty,
                    syntax: AdblockSyntax.Common,
                };
                if (options.includeRaws) {
                    result.raws = {
                        text: raw,
                    };
                }
                if (options.isLocIncluded) {
                    result.start = baseOffset;
                    result.end = baseOffset + raw.length;
                }
                return result;
            }
            // Try to parse the rule with all sub-parsers. If a rule doesn't match
            // the pattern of a parser, then it will return `null`. For example, a
            // network rule will not match the pattern of a comment rule, since it
            // doesn't start with comment marker. But if the rule matches the
            // pattern of a parser, then it will return the AST of the rule, or
            // throw an error if the rule is syntactically invalid.
            if (options.ignoreComments) {
                if (CommentRuleParser.isCommentRule(raw)) {
                    const result = {
                        type: 'EmptyRule',
                        category: RuleCategory.Empty,
                        syntax: AdblockSyntax.Common,
                    };
                    if (options.includeRaws) {
                        result.raws = {
                            text: raw,
                        };
                    }
                    if (options.isLocIncluded) {
                        result.start = baseOffset;
                        result.end = baseOffset + raw.length;
                    }
                    return result;
                }
                return CosmeticRuleParser.parse(raw, options, baseOffset)
                    || RuleParser.parseHostOrNetworkRule(raw, options, baseOffset);
            }
            return CommentRuleParser.parse(raw, options, baseOffset)
                || CosmeticRuleParser.parse(raw, options, baseOffset)
                || RuleParser.parseHostOrNetworkRule(raw, options, baseOffset);
        }
        catch (error) {
            // If tolerant mode is disabled or the error is not known, then simply
            // re-throw the error
            if (!options.tolerant || !(error instanceof Error)) {
                throw error;
            }
            const errorNode = {
                type: 'InvalidRuleError',
                name: error.name,
                message: error.message,
            };
            // If the error is an AdblockSyntaxError, then we can add the
            // location of the error to the result
            if (error instanceof AdblockSyntaxError) {
                errorNode.start = error.start;
                errorNode.end = error.end;
            }
            // Otherwise, return an invalid rule (tolerant mode)
            const result = {
                type: 'InvalidRule',
                category: RuleCategory.Invalid,
                syntax: AdblockSyntax.Common,
                raw,
                error: errorNode,
            };
            if (options.includeRaws) {
                result.raws = {
                    text: raw,
                };
            }
            if (options.isLocIncluded) {
                result.start = baseOffset;
                result.end = baseOffset + raw.length;
            }
            return result;
        }
    }
    /**
     * Converts a rule AST to a string.
     *
     * @param ast - Adblock rule AST
     * @returns Raw string
     * @example
     * Take a look at the following example:
     * ```js
     * // Parse the rule to the AST
     * const ast = RuleParser.parse("example.org##.banner");
     * // Generate the rule from the AST
     * const raw = RuleParser.generate(ast);
     * // Print the generated rule
     * console.log(raw); // "example.org##.banner"
     * ```
     */
    static generate(ast) {
        switch (ast.category) {
            // Empty lines
            case RuleCategory.Empty:
                return EMPTY;
            // Invalid rules
            case RuleCategory.Invalid:
                return ast.raw;
            // Comment rules
            case RuleCategory.Comment:
                return CommentRuleParser.generate(ast);
            // Cosmetic / non-basic rules
            case RuleCategory.Cosmetic:
                return CosmeticRuleParser.generate(ast);
            // Network / basic rules
            case RuleCategory.Network:
                switch (ast.type) {
                    case NetworkRuleType.HostRule:
                        return HostRuleParser.generate(ast);
                    case NetworkRuleType.NetworkRule:
                        return NetworkRuleParser.generate(ast);
                    default:
                        throw new Error('Unknown network rule type');
                }
            default:
                throw new Error('Unknown rule category');
        }
    }
    /**
     * Serializes an empty rule node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serializeEmptyRule(node, buffer) {
        buffer.writeUint8(BinaryTypeMap.EmptyRule);
        if (!isUndefined(node.start)) {
            buffer.writeUint8(EmptyRuleSerializationMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(EmptyRuleSerializationMap.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Deserializes an empty rule node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserializeEmptyRule(buffer, node) {
        buffer.assertUint8(BinaryTypeMap.EmptyRule);
        node.type = 'EmptyRule';
        node.category = RuleCategory.Empty;
        node.syntax = AdblockSyntax.Common;
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case EmptyRuleSerializationMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case EmptyRuleSerializationMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}.`);
            }
            prop = buffer.readUint8();
        }
    }
    /**
     * Serializes an invalid rule error node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serializeInvalidRuleErrorNode(node, buffer) {
        buffer.writeUint8(BinaryTypeMap.InvalidRuleErrorNode);
        buffer.writeUint8(InvalidRuleErrorNodeSerializationMap.Name);
        buffer.writeString(node.name);
        buffer.writeUint8(InvalidRuleErrorNodeSerializationMap.Message);
        buffer.writeString(node.message);
        if (!isUndefined(node.start)) {
            buffer.writeUint8(InvalidRuleErrorNodeSerializationMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(InvalidRuleErrorNodeSerializationMap.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Deserializes an invalid rule error node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserializeInvalidRuleErrorNode(buffer, node) {
        buffer.assertUint8(BinaryTypeMap.InvalidRuleErrorNode);
        node.type = 'InvalidRuleError';
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case InvalidRuleErrorNodeSerializationMap.Name:
                    node.name = buffer.readString();
                    break;
                case InvalidRuleErrorNodeSerializationMap.Message:
                    node.message = buffer.readString();
                    break;
                case InvalidRuleErrorNodeSerializationMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case InvalidRuleErrorNodeSerializationMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}.`);
            }
            prop = buffer.readUint8();
        }
    }
    /**
     * Serializes an invalid rule node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serializeInvalidRule(node, buffer) {
        buffer.writeUint8(BinaryTypeMap.InvalidRule);
        buffer.writeUint8(InvalidRuleSerializationMap.Error);
        RuleParser.serializeInvalidRuleErrorNode(node.error, buffer);
        if (!isUndefined(node.start)) {
            buffer.writeUint8(InvalidRuleSerializationMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(InvalidRuleSerializationMap.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Deserializes an invalid rule node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserializeInvalidRule(buffer, node) {
        buffer.assertUint8(BinaryTypeMap.InvalidRule);
        node.type = 'InvalidRule';
        node.category = RuleCategory.Invalid;
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case InvalidRuleSerializationMap.Error:
                    RuleParser.deserializeInvalidRuleErrorNode(buffer, node.error = {});
                    break;
                case InvalidRuleSerializationMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case InvalidRuleSerializationMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}.`);
            }
            prop = buffer.readUint8();
        }
    }
    /**
     * Serializes a rule node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    // TODO: add support for raws, if ever needed
    static serialize(node, buffer) {
        switch (node.category) {
            case RuleCategory.Comment:
                CommentRuleParser.serialize(node, buffer);
                break;
            case RuleCategory.Cosmetic:
                CosmeticRuleParser.serialize(node, buffer);
                break;
            case RuleCategory.Network:
                switch (node.type) {
                    case NetworkRuleType.HostRule:
                        HostRuleParser.serialize(node, buffer);
                        break;
                    case NetworkRuleType.NetworkRule:
                        NetworkRuleParser.serialize(node, buffer);
                        break;
                    default:
                        throw new Error('Unknown network rule type');
                }
                break;
            case RuleCategory.Empty:
                RuleParser.serializeEmptyRule(node, buffer);
                break;
            case RuleCategory.Invalid:
                RuleParser.serializeInvalidRule(node, buffer);
                break;
            default:
                throw new Error('Unknown rule category');
        }
    }
    /**
     * Deserializes a rule node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer, node) {
        // lookup instead of storing +1 byte
        const type = buffer.peekUint8();
        switch (type) {
            case BinaryTypeMap.AgentRuleNode:
            case BinaryTypeMap.HintRuleNode:
            case BinaryTypeMap.PreProcessorCommentRuleNode:
            case BinaryTypeMap.MetadataCommentRuleNode:
            case BinaryTypeMap.ConfigCommentRuleNode:
            case BinaryTypeMap.CommentRuleNode:
                CommentRuleParser.deserialize(buffer, node);
                break;
            case BinaryTypeMap.ElementHidingRule:
            case BinaryTypeMap.CssInjectionRule:
            case BinaryTypeMap.ScriptletInjectionRule:
            case BinaryTypeMap.HtmlFilteringRule:
            case BinaryTypeMap.JsInjectionRule:
                CosmeticRuleParser.deserialize(buffer, node);
                break;
            case BinaryTypeMap.NetworkRuleNode:
                NetworkRuleParser.deserialize(buffer, node);
                break;
            case BinaryTypeMap.HostRuleNode:
                HostRuleParser.deserialize(buffer, node);
                break;
            case BinaryTypeMap.EmptyRule:
                RuleParser.deserializeEmptyRule(buffer, node);
                break;
            case BinaryTypeMap.InvalidRule:
                RuleParser.deserializeInvalidRule(buffer, node);
                break;
            default:
                throw new Error('Unknown rule category');
        }
    }
}

const APP_LIST_SEPARATOR = PIPE;
/**
 * `AppListParser` is responsible for parsing an app list.
 *
 * @see {@link https://adguard.app/kb/general/ad-filtering/create-own-filters/#app-modifier}
 */
class AppListParser extends ParserBase {
    /**
     * Parses an app list which items are separated by `|`,
     * e.g. `Example.exe|com.example.osx`.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     *
     * @returns App list AST.
     * @throws An {@link AdblockSyntaxError} if the app list is syntactically invalid.
     * @throws An {@link Error} if the options are invalid.
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0) {
        const result = {
            type: ListNodeType.AppList,
            separator: APP_LIST_SEPARATOR,
            children: parseListItems(raw, options, baseOffset, APP_LIST_SEPARATOR, ListItemNodeType.App),
        };
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        return result;
    }
}

const METHOD_LIST_SEPARATOR = PIPE;
/**
 * `MethodListParser` is responsible for parsing a method list.
 *
 * @see {@link https://adguard.app/kb/general/ad-filtering/create-own-filters/#method-modifier}
 */
class MethodListParser extends ParserBase {
    /**
     * Parses a method list which items are separated by `|`,
     * e.g. `get|post|put`.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     *
     * @returns Method list AST.
     * @throws An {@link AdblockSyntaxError} if the method list is syntactically invalid.
     * @throws An {@link Error} if the options are invalid.
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0) {
        const result = {
            type: ListNodeType.MethodList,
            separator: METHOD_LIST_SEPARATOR,
            children: parseListItems(raw, options, baseOffset, METHOD_LIST_SEPARATOR, ListItemNodeType.Method),
        };
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        return result;
    }
}

const STEALTH_OPTION_LIST_SEPARATOR = PIPE;
/**
 * `StealthOptionListParser` is responsible for parsing a list of stealth options.
 *
 * @see {@link https://adguard.app/kb/general/ad-filtering/create-own-filters/#stealth-modifier}
 */
class StealthOptionListParser extends ParserBase {
    /**
     * Parses a stealth option list which items are separated by `|`,
     * e.g. `dpi|ip`.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     *
     * @returns Stealth option list AST.
     * @throws An {@link AdblockSyntaxError} if the stealth option list is syntactically invalid.
     * @throws An {@link Error} if the options are invalid.
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0) {
        const result = {
            type: ListNodeType.StealthOptionList,
            separator: STEALTH_OPTION_LIST_SEPARATOR,
            // eslint-disable-next-line max-len
            children: parseListItems(raw, options, baseOffset, STEALTH_OPTION_LIST_SEPARATOR, ListItemNodeType.StealthOption),
        };
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        return result;
    }
}

/* eslint-disable no-param-reassign */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
var FilterListNodeSerializationMap;
(function (FilterListNodeSerializationMap) {
    FilterListNodeSerializationMap[FilterListNodeSerializationMap["Children"] = 1] = "Children";
    FilterListNodeSerializationMap[FilterListNodeSerializationMap["Start"] = 2] = "Start";
    FilterListNodeSerializationMap[FilterListNodeSerializationMap["End"] = 3] = "End";
})(FilterListNodeSerializationMap || (FilterListNodeSerializationMap = {}));
/**
 * `FilterListParser` is responsible for parsing a whole adblock filter list (list of rules).
 * It is a wrapper around `RuleParser` which parses each line separately.
 */
class FilterListParser extends ParserBase {
    /**
     * Parses a whole adblock filter list (list of rules).
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns AST of the source code (list of rules)
     * @example
     * ```js
     * import { readFileSync } from 'fs';
     * import { FilterListParser } from '@adguard/agtree';
     *
     * // Read filter list content from file
     * const content = readFileSync('your-adblock-filter-list.txt', 'utf-8');
     *
     * // Parse the filter list content, then do something with the AST
     * const ast = FilterListParser.parse(content);
     * ```
     * @throws If one of the rules is syntactically invalid (if `tolerant` is `false`)
     */
    static parse(raw, options = defaultParserOptions, baseOffset = 0) {
        // Actual position in the source code
        let offset = 0;
        // Collect adblock rules here
        const rules = [];
        // Start offset of the current line (initially it's 0)
        let lineStartOffset = offset;
        while (offset < raw.length) {
            // Check if we found a new line
            if (StringUtils.isEOL(raw[offset])) {
                // Rule text
                const text = raw.slice(lineStartOffset, offset);
                // Parse the rule
                const rule = RuleParser.parse(text, options, lineStartOffset);
                // Get newline type (possible values: 'crlf', 'lf', 'cr' or undefined if no newline found)
                let nl;
                if (raw[offset] === CR) {
                    if (raw[offset + 1] === LF) {
                        nl = 'crlf';
                    }
                    else {
                        nl = 'cr';
                    }
                }
                else if (raw[offset] === LF) {
                    nl = 'lf';
                }
                // Add newline type to the rule (rule parser already added raws.text)
                if (!rule.raws) {
                    rule.raws = {
                        text,
                        nl,
                    };
                }
                else {
                    rule.raws.nl = nl;
                }
                // Add the rule to the list
                rules.push(rule);
                // Update offset: add 2 if we found CRLF, otherwise add 1
                offset += nl === 'crlf' ? 2 : 1;
                // Update line start offset
                lineStartOffset = offset;
            }
            else {
                // No new line found, just increase offset
                offset += 1;
            }
        }
        // Parse the last rule (it doesn't end with a new line)
        rules.push(RuleParser.parse(raw.slice(lineStartOffset, offset), options, baseOffset + lineStartOffset));
        // Return the list of rules (FilterList node)
        const result = {
            type: 'FilterList',
            children: rules,
        };
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        return result;
    }
    /**
     * Serializes a whole adblock filter list (list of rules).
     *
     * @param ast AST to generate
     * @param preferRaw If `true`, then the parser will use `raws.text` property of each rule
     * if it is available. Default is `false`.
     * @returns Serialized filter list
     */
    static generate(ast, preferRaw = false) {
        let result = EMPTY;
        for (let i = 0; i < ast.children.length; i += 1) {
            const rule = ast.children[i];
            if (preferRaw && rule.raws?.text) {
                result += rule.raws.text;
            }
            else {
                result += RuleParser.generate(rule);
            }
            switch (rule.raws?.nl) {
                case 'crlf':
                    result += CRLF;
                    break;
                case 'cr':
                    result += CR;
                    break;
                case 'lf':
                    result += LF;
                    break;
                default:
                    if (i !== ast.children.length - 1) {
                        result += LF;
                    }
                    break;
            }
        }
        return result;
    }
    /**
     * Serializes a filter list node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    // TODO: add support for raws, if ever needed
    static serialize(node, buffer) {
        buffer.writeUint8(BinaryTypeMap.FilterListNode);
        buffer.writeUint8(FilterListNodeSerializationMap.Children);
        const count = node.children.length;
        buffer.writeUint32(count);
        for (let i = 0; i < count; i += 1) {
            RuleParser.serialize(node.children[i], buffer);
        }
        if (!isUndefined(node.start)) {
            buffer.writeUint8(FilterListNodeSerializationMap.Start);
            buffer.writeUint32(node.start);
        }
        if (!isUndefined(node.end)) {
            buffer.writeUint8(FilterListNodeSerializationMap.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(NULL);
    }
    /**
     * Deserializes a filter list node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(BinaryTypeMap.FilterListNode);
        node.type = 'FilterList';
        let prop = buffer.readUint8();
        while (prop !== NULL) {
            switch (prop) {
                case FilterListNodeSerializationMap.Children:
                    node.children = new Array(buffer.readUint32());
                    for (let i = 0; i < node.children.length; i += 1) {
                        RuleParser.deserialize(buffer, node.children[i] = {});
                    }
                    break;
                case FilterListNodeSerializationMap.Start:
                    node.start = buffer.readUint32();
                    break;
                case FilterListNodeSerializationMap.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}.`);
            }
            prop = buffer.readUint8();
        }
    }
    /**
     * Helper method to jump to the children of the filter list node.
     *
     * Filter lists serialized in binary format are structured as follows:
     * - `FilterListNode` filter list node indicator (1 byte)
     * - Properties:
     *      - `Children` (1 byte) - children count, followed by children nodes
     *      - `Start` (1 byte) - start offset, if present, followed by the value
     *      - `End` (1 byte) - end offset, if present, followed by the value
     *      - `NULL` (1 byte) - closing indicator
     *
     * This method skips indicators, reads the children count and returns it.
     * This way the buffer is positioned at the beginning of the children nodes.
     *
     * @param buffer Reference to the input byte buffer.
     * @returns Number of children nodes.
     */
    static jumpToChildren(buffer) {
        buffer.assertUint8(BinaryTypeMap.FilterListNode); // filter list indicator
        let prop = buffer.readUint8();
        while (prop) {
            switch (prop) {
                case FilterListNodeSerializationMap.Children:
                    return buffer.readUint32();
                case FilterListNodeSerializationMap.Start:
                case FilterListNodeSerializationMap.End:
                    buffer.readUint32(); // ignore value
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}.`);
            }
            prop = buffer.readUint8();
        }
        return 0;
    }
}

/**
 * @file Customized error class for conversion errors.
 */
const ERROR_NAME$1 = 'RuleConversionError';
/**
 * Customized error class for conversion errors.
 */
class RuleConversionError extends Error {
    /**
     * Constructs a new `RuleConversionError` instance.
     *
     * @param message Error message
     */
    constructor(message) {
        super(message);
        this.name = ERROR_NAME$1;
    }
}

/**
 * @file Customized error for binary schema mismatch.
 */
const ERROR_NAME = 'BinarySchemaMismatchError';
/**
 * Customized error for binary schema mismatch.
 */
class BinarySchemaMismatchError extends Error {
    /**
     * Expected schema version.
     */
    expectedVersion;
    /**
     * Actual schema version.
     */
    actualVersion;
    /**
     * Constructs a new `BinarySchemaMismatchError` instance.
     *
     * @param expectedVersion Expected schema version.
     * @param actualVersion Actual schema version.
     */
    constructor(expectedVersion, actualVersion) {
        super(`Expected schema version ${expectedVersion}, but got ${actualVersion}`);
        this.name = ERROR_NAME;
        this.expectedVersion = expectedVersion;
        this.actualVersion = actualVersion;
    }
}

/**
 * Prefixes for different adblockers to describe the platform-specific modifiers data
 * stored in the yaml files.
 */
const BLOCKER_PREFIX = {
    [AdblockSyntax.Adg]: 'adg_',
    [AdblockSyntax.Ubo]: 'ubo_',
    [AdblockSyntax.Abp]: 'abp_',
};
/**
 * Set of all allowed characters for app name except the dot `.`.
 */
const APP_NAME_ALLOWED_CHARS = new Set([
    ...CAPITAL_LETTERS,
    ...SMALL_LETTERS,
    ...NUMBERS,
    UNDERSCORE,
]);
/**
 * Allowed methods for $method modifier.
 *
 * @see {@link https://adguard.app/kb/general/ad-filtering/create-own-filters/#method-modifier}
 */
const ALLOWED_METHODS = new Set([
    'connect',
    'delete',
    'get',
    'head',
    'options',
    'patch',
    'post',
    'put',
    'trace',
]);
/**
 * Allowed stealth options for $stealth modifier.
 *
 * @see {@link https://adguard.app/kb/general/ad-filtering/create-own-filters/#stealth-modifier}
 */
const ALLOWED_STEALTH_OPTIONS = new Set([
    'searchqueries',
    'donottrack',
    '3p-cookie',
    '1p-cookie',
    '3p-cache',
    '3p-auth',
    'webrtc',
    'push',
    'location',
    'flash',
    'java',
    'referrer',
    'useragent',
    'ip',
    'xclientdata',
    'dpi',
]);
/**
 * Allowed CSP directives for $csp modifier.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy#directives}
 */
const ALLOWED_CSP_DIRECTIVES = new Set([
    'base-uri',
    'child-src',
    'connect-src',
    'default-src',
    'fenced-frame-src',
    'font-src',
    'form-action',
    'frame-ancestors',
    'frame-src',
    'img-src',
    'manifest-src',
    'media-src',
    'navigate-to',
    'object-src',
    'plugin-types',
    'prefetch-src',
    'referrer',
    'report-to',
    'report-uri',
    'require-trusted-types-for',
    'sandbox',
    'script-src',
    'script-src-attr',
    'script-src-elem',
    'style-src',
    'style-src-attr',
    'style-src-elem',
    'trusted-types',
    'upgrade-insecure-requests',
    'worker-src',
]);
/**
 * Allowed directives for $permissions modifier.
 *
 * @see {@link https://adguard.app/kb/general/ad-filtering/create-own-filters/#permissions-modifier}
 */
const ALLOWED_PERMISSION_DIRECTIVES = new Set([
    'accelerometer',
    'ambient-light-sensor',
    'autoplay',
    'battery',
    'browsing-topics',
    'camera',
    'display-capture',
    'document-domain',
    'encrypted-media',
    'execution-while-not-rendered',
    'execution-while-out-of-viewport',
    'fullscreen',
    'gamepad',
    'geolocation',
    'gyroscope',
    'hid',
    'identity-credentials-get',
    'idle-detection',
    'join-ad-interest-group',
    'local-fonts',
    'magnetometer',
    'microphone',
    'midi',
    'payment',
    'picture-in-picture',
    'publickey-credentials-create',
    'publickey-credentials-get',
    'run-ad-auction',
    'screen-wake-lock',
    'serial',
    'speaker-selection',
    'storage-access',
    'usb',
    'web-share',
    'xr-spatial-tracking',
]);
/**
 * One of available tokens for $permission modifier value.
 *
 * @see {@link https://w3c.github.io/webappsec-permissions-policy/#structured-header-serialization}
 */
const PERMISSIONS_TOKEN_SELF = 'self';
/**
 * One of allowlist values for $permissions modifier.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Permissions_Policy#allowlists}
 */
const EMPTY_PERMISSIONS_ALLOWLIST = `${OPEN_PARENTHESIS}${CLOSE_PARENTHESIS}`;
/**
 * Allowed directives for $referrerpolicy modifier.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy}
 */
const REFERRER_POLICY_DIRECTIVES = new Set([
    'no-referrer',
    'no-referrer-when-downgrade',
    'origin',
    'origin-when-cross-origin',
    'same-origin',
    'strict-origin',
    'strict-origin-when-cross-origin',
    'unsafe-url',
]);
/**
 * Prefixes for error messages used in modifier validation.
 */
const VALIDATION_ERROR_PREFIX = {
    BLOCK_ONLY: 'Only blocking rules may contain the modifier',
    EXCEPTION_ONLY: 'Only exception rules may contain the modifier',
    INVALID_CSP_DIRECTIVES: 'Invalid CSP directives for the modifier',
    INVALID_LIST_VALUES: 'Invalid values for the modifier',
    INVALID_NOOP: 'Invalid noop modifier',
    INVALID_PERMISSION_DIRECTIVE: 'Invalid Permissions-Policy directive for the modifier',
    INVALID_PERMISSION_ORIGINS: 'Origins in the value is invalid for the modifier and the directive',
    INVALID_PERMISSION_ORIGIN_QUOTES: 'Double quotes should be used for origins in the value of the modifier',
    INVALID_REFERRER_POLICY_DIRECTIVE: 'Invalid Referrer-Policy directive for the modifier',
    MIXED_NEGATIONS: 'Simultaneous usage of negated and not negated values is forbidden for the modifier',
    NO_CSP_VALUE: 'No CSP value for the modifier and the directive',
    NO_CSP_DIRECTIVE_QUOTE: 'CSP directives should no be quoted for the modifier',
    NO_UNESCAPED_PERMISSION_COMMA: 'Unescaped comma in the value is not allowed for the modifier',
    // TODO: implement later for $scp and $permissions
    // NO_VALUE_ONLY_FOR_EXCEPTION: 'Modifier without value can be used only in exception rules',
    NOT_EXISTENT: 'Non-existent modifier',
    NOT_NEGATABLE_MODIFIER: 'Non-negatable modifier',
    NOT_NEGATABLE_VALUE: 'Values cannot be negated for the modifier',
    NOT_SUPPORTED: 'The adblocker does not support the modifier',
    REMOVED: 'Removed and no longer supported modifier',
    VALUE_FORBIDDEN: 'Value is not allowed for the modifier',
    VALUE_INVALID: 'Value is invalid for the modifier',
    VALUE_REQUIRED: 'Value is required for the modifier',
};
/**
 * Prefixes for error messages related to issues in the source YAML files' data.
 */
const SOURCE_DATA_ERROR_PREFIX = {
    INVALID_VALUE_FORMAT_REGEXP: "Invalid regular expression in 'value_format' for the modifier",
    NO_DEPRECATION_MESSAGE: "Property 'deprecation_message' is required for the 'deprecated' modifier",
    NO_VALUE_FORMAT_FOR_ASSIGNABLE: "Property 'value_format' should be specified for the assignable modifier",
};

/**
 * Validates the noop modifier (i.e. only underscores).
 *
 * @param value Value of the modifier.
 *
 * @returns True if the modifier is valid, false otherwise.
 */
const isValidNoopModifier = (value) => {
    return value.split('').every((char) => char === UNDERSCORE);
};
/**
 * Returns invalid validation result with given error message.
 *
 * @param error Error message.
 *
 * @returns Validation result `{ valid: false, error }`.
 */
const getInvalidValidationResult = (error) => {
    return {
        valid: false,
        error,
    };
};
/**
 * Returns invalid validation result which uses {@link VALIDATION_ERROR_PREFIX.VALUE_REQUIRED} as prefix
 * and specifies the given `modifierName` in the error message.
 *
 * @param modifierName Modifier name.
 *
 * @returns Validation result `{ valid: false, error }`.
 */
const getValueRequiredValidationResult = (modifierName) => {
    return getInvalidValidationResult(`${VALIDATION_ERROR_PREFIX.VALUE_REQUIRED}: '${modifierName}'`);
};

/**
 * @file Utility functions for domain and hostname validation.
 */
/**
 * Marker for a wildcard top-level domain â€” `.*`.
 *
 * @example
 * `example.*` â€” matches with any TLD, e.g. `example.org`, `example.com`, etc.
 */
const WILDCARD_TLD = DOT + WILDCARD;
/**
 * Marker for a wildcard subdomain â€” `*.`.
 *
 * @example
 * `*.example.org` â€” matches with any subdomain, e.g. `foo.example.org` or `bar.example.org`
 */
const WILDCARD_SUBDOMAIN = WILDCARD + DOT;
class DomainUtils {
    /**
     * Check if the input is a valid domain or hostname.
     *
     * @param domain Domain to check
     * @returns `true` if the domain is valid, `false` otherwise
     */
    static isValidDomainOrHostname(domain) {
        let domainToCheck = domain;
        // Wildcard-only domain, typically a generic rule
        if (domainToCheck === WILDCARD) {
            return true;
        }
        // https://adguard.com/kb/general/ad-filtering/create-own-filters/#wildcard-for-tld
        if (domainToCheck.endsWith(WILDCARD_TLD)) {
            // Remove the wildcard TLD
            domainToCheck = domainToCheck.substring(0, domainToCheck.length - WILDCARD_TLD.length);
        }
        if (domainToCheck.startsWith(WILDCARD_SUBDOMAIN)) {
            // Remove the wildcard subdomain
            domainToCheck = domainToCheck.substring(WILDCARD_SUBDOMAIN.length);
        }
        // Parse the domain with tldts
        const tldtsResult = parse(domainToCheck);
        // Check if the domain is valid
        return domainToCheck === tldtsResult.domain || domainToCheck === tldtsResult.hostname;
    }
}

/**
 * Pre-defined available validators for modifiers with custom `value_format`.
 */
var CustomValueFormatValidatorName;
(function (CustomValueFormatValidatorName) {
    CustomValueFormatValidatorName["App"] = "pipe_separated_apps";
    CustomValueFormatValidatorName["Csp"] = "csp_value";
    // there are some differences between $domain and $denyallow
    CustomValueFormatValidatorName["DenyAllow"] = "pipe_separated_denyallow_domains";
    CustomValueFormatValidatorName["Domain"] = "pipe_separated_domains";
    CustomValueFormatValidatorName["Method"] = "pipe_separated_methods";
    CustomValueFormatValidatorName["Permissions"] = "permissions_value";
    CustomValueFormatValidatorName["ReferrerPolicy"] = "referrerpolicy_value";
    CustomValueFormatValidatorName["StealthOption"] = "pipe_separated_stealth_options";
})(CustomValueFormatValidatorName || (CustomValueFormatValidatorName = {}));
/**
 * Checks whether the `chunk` of app name (which if splitted by dot `.`) is valid.
 * Only letters, numbers, and underscore `_` are allowed.
 *
 * @param chunk Chunk of app name to check.
 *
 * @returns True if the `chunk` is valid part of app name, false otherwise.
 */
const isValidAppNameChunk = (chunk) => {
    // e.g. 'Example..exe'
    if (chunk.length === 0) {
        return false;
    }
    for (let i = 0; i < chunk.length; i += 1) {
        const char = chunk[i];
        if (!APP_NAME_ALLOWED_CHARS.has(char)) {
            return false;
        }
    }
    return true;
};
/**
 * Checks whether the given `value` is valid app name as $app modifier value.
 *
 * @param value App name to check.
 *
 * @returns True if the `value` is valid app name, false otherwise.
 */
const isValidAppModifierValue = (value) => {
    // $app modifier does not support wildcard tld
    // https://adguard.app/kb/general/ad-filtering/create-own-filters/#app-modifier
    if (value.includes(WILDCARD)) {
        return false;
    }
    return value
        .split(DOT)
        .every((chunk) => isValidAppNameChunk(chunk));
};
/**
 * Checks whether the given `value` is valid HTTP method as $method modifier value.
 *
 * @param value Method to check.
 *
 * @returns True if the `value` is valid HTTP method, false otherwise.
 */
const isValidMethodModifierValue = (value) => {
    return ALLOWED_METHODS.has(value);
};
/**
 * Checks whether the given `value` is valid option as $stealth modifier value.
 *
 * @param value Stealth option to check.
 *
 * @returns True if the `value` is valid stealth option, false otherwise.
 */
const isValidStealthModifierValue = (value) => {
    return ALLOWED_STEALTH_OPTIONS.has(value);
};
/**
 * Checks whether the given `rawOrigin` is valid as Permissions Allowlist origin.
 *
 * @see {@link https://w3c.github.io/webappsec-permissions-policy/#allowlists}
 *
 * @param rawOrigin The raw origin.
 *
 * @returns True if the origin is valid, false otherwise.
 */
const isValidPermissionsOrigin = (rawOrigin) => {
    // origins should be quoted by double quote
    const actualQuoteType = QuoteUtils.getStringQuoteType(rawOrigin);
    if (actualQuoteType !== QuoteType.Double) {
        return false;
    }
    const origin = QuoteUtils.removeQuotes(rawOrigin);
    try {
        // validate the origin by URL constructor
        // https://w3c.github.io/webappsec-permissions-policy/#algo-parse-policy-directive
        new URL(origin);
    }
    catch (e) {
        return false;
    }
    return true;
};
/**
 * Checks whether the given `value` is valid domain as $denyallow modifier value.
 * Important: wildcard tld are not supported, compared to $domain.
 *
 * @param value Value to check.
 *
 * @returns True if the `value` is valid domain and does not contain wildcard `*`, false otherwise.
 */
const isValidDenyAllowModifierValue = (value) => {
    // $denyallow modifier does not support wildcard tld
    // https://adguard.app/kb/general/ad-filtering/create-own-filters/#denyallow-modifier
    // but here we are simply checking whether the value contains wildcard `*`, not ends with `.*`
    if (value.includes(WILDCARD)) {
        return false;
    }
    // TODO: add cache for domains validation
    return DomainUtils.isValidDomainOrHostname(value);
};
/**
 * Checks whether the given `value` is valid domain as $domain modifier value.
 *
 * @param value Value to check.
 *
 * @returns True if the `value` is valid domain, false otherwise.
 */
const isValidDomainModifierValue = (value) => {
    // TODO: add cache for domains validation
    return DomainUtils.isValidDomainOrHostname(value);
};
/**
 * Checks whether the all list items' exceptions are `false`.
 * Those items which `exception` is `true` is to be specified in the validation result error message.
 *
 * @param modifierName Modifier name.
 * @param listItems List items to check.
 *
 * @returns Validation result.
 */
const customNoNegatedListItemsValidator = (modifierName, listItems) => {
    const negatedValues = [];
    listItems.forEach((listItem) => {
        if (listItem.exception) {
            negatedValues.push(listItem.value);
        }
    });
    if (negatedValues.length > 0) {
        const valuesToStr = QuoteUtils.quoteAndJoinStrings(negatedValues);
        return getInvalidValidationResult(`${VALIDATION_ERROR_PREFIX.NOT_NEGATABLE_VALUE}: '${modifierName}': ${valuesToStr}`);
    }
    return { valid: true };
};
/**
 * Checks whether the all list items' exceptions are consistent,
 * i.e. all items are either negated or not negated.
 *
 * The `exception` value of the first item is used as a reference, and all other items are checked against it.
 * Those items which `exception` is not consistent with the first item
 * is to be specified in the validation result error message.
 *
 * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#method-modifier}
 *
 * @param modifierName Modifier name.
 * @param listItems List items to check.
 *
 * @returns Validation result.
 */
const customConsistentExceptionsValidator = (modifierName, listItems) => {
    const firstException = listItems[0].exception;
    const nonConsistentItemValues = [];
    listItems.forEach((listItem) => {
        if (listItem.exception !== firstException) {
            nonConsistentItemValues.push(listItem.value);
        }
    });
    if (nonConsistentItemValues.length > 0) {
        const valuesToStr = QuoteUtils.quoteAndJoinStrings(nonConsistentItemValues);
        return getInvalidValidationResult(`${VALIDATION_ERROR_PREFIX.MIXED_NEGATIONS}: '${modifierName}': ${valuesToStr}`);
    }
    return { valid: true };
};
/**
 * Checks whether the given `modifier` value is valid.
 * Supposed to validate the value of modifiers which values are lists separated by pipe `|` â€”
 * $app, $domain, $denyallow, $method.
 *
 * @param modifier Modifier AST node.
 * @param listParser Parser function for parsing modifier value
 * which is supposed to be a list separated by pipe `|`.
 * @param isValidListItem Predicate function for checking of modifier's list item validity,
 * e.g. $denyallow modifier does not support wildcard tld, but $domain does.
 * @param customListValidator Optional; custom validator for specific modifier,
 * e.g. $denyallow modifier does not support negated domains.
 *
 * @returns Result of modifier domains validation.
 */
const validateListItemsModifier = (modifier, listParser, isValidListItem, customListValidator) => {
    const modifierName = modifier.name.value;
    const defaultInvalidValueResult = getValueRequiredValidationResult(modifierName);
    if (!modifier.value?.value) {
        return defaultInvalidValueResult;
    }
    let theList;
    try {
        theList = listParser(modifier.value.value, defaultParserOptions, 0, PIPE);
    }
    catch (e) {
        if (e instanceof AdblockSyntaxError) {
            return {
                valid: false,
                error: e.message,
            };
        }
        return defaultInvalidValueResult;
    }
    const invalidListItems = [];
    theList.children.forEach((item) => {
        // different validators are used for $denyallow and $domain modifiers
        // because of different requirements and restrictions
        if (!isValidListItem(item.value)) {
            invalidListItems.push(item.value);
        }
    });
    if (invalidListItems.length > 0) {
        const itemsToStr = QuoteUtils.quoteAndJoinStrings(invalidListItems);
        return getInvalidValidationResult(`${VALIDATION_ERROR_PREFIX.INVALID_LIST_VALUES}: '${modifierName}': ${itemsToStr}`);
    }
    // IMPORTANT: run custom validator after all other checks
    // Some lists should be fully checked, not just the list items:
    // e.g. Safari does not support allowed and disallowed domains for $domain in the same list
    // or   domains cannot be negated for $denyallow modifier
    if (customListValidator) {
        return customListValidator(modifierName, theList.children);
    }
    return { valid: true };
};
/**
 * Validates 'pipe_separated_apps' custom value format.
 * Used for $app modifier.
 *
 * @param modifier Modifier AST node.
 *
 * @returns Validation result.
 */
const validatePipeSeparatedApps = (modifier) => {
    return validateListItemsModifier(modifier, (raw) => AppListParser.parse(raw), isValidAppModifierValue);
};
/**
 * Validates 'pipe_separated_denyallow_domains' custom value format.
 * Used for $denyallow modifier.
 *
 * @param modifier Modifier AST node.
 *
 * @returns Validation result.
 */
const validatePipeSeparatedDenyAllowDomains = (modifier) => {
    return validateListItemsModifier(modifier, DomainListParser.parse, isValidDenyAllowModifierValue, customNoNegatedListItemsValidator);
};
/**
 * Validates 'pipe_separated_domains' custom value format.
 * Used for $domains modifier.
 *
 * @param modifier Modifier AST node.
 *
 * @returns Validation result.
 */
const validatePipeSeparatedDomains = (modifier) => {
    return validateListItemsModifier(modifier, DomainListParser.parse, isValidDomainModifierValue);
};
/**
 * Validates 'pipe_separated_methods' custom value format.
 * Used for $method modifier.
 *
 * @param modifier Modifier AST node.
 *
 * @returns Validation result.
 */
const validatePipeSeparatedMethods = (modifier) => {
    return validateListItemsModifier(modifier, (raw) => MethodListParser.parse(raw), isValidMethodModifierValue, customConsistentExceptionsValidator);
};
/**
 * Validates 'pipe_separated_stealth_options' custom value format.
 * Used for $stealth modifier.
 *
 * @param modifier Modifier AST node.
 *
 * @returns Validation result.
 */
const validatePipeSeparatedStealthOptions = (modifier) => {
    return validateListItemsModifier(modifier, (raw) => StealthOptionListParser.parse(raw), isValidStealthModifierValue, customNoNegatedListItemsValidator);
};
/**
 * Validates `csp_value` custom value format.
 * Used for $csp modifier.
 *
 * @param modifier Modifier AST node.
 *
 * @returns Validation result.
 */
const validateCspValue = (modifier) => {
    const modifierName = modifier.name.value;
    if (!modifier.value?.value) {
        return getValueRequiredValidationResult(modifierName);
    }
    // $csp modifier value may contain multiple directives
    // e.g. "csp=child-src 'none'; frame-src 'self' *; worker-src 'none'"
    const policyDirectives = modifier.value.value
        .split(SEMICOLON)
        // rule with $csp modifier may end with semicolon
        // e.g. "$csp=sandbox allow-same-origin;"
        // TODO: add predicate helper for `(i) => !!i`
        .filter((i) => !!i);
    const invalidValueValidationResult = getInvalidValidationResult(`${VALIDATION_ERROR_PREFIX.VALUE_INVALID}: '${modifierName}': "${modifier.value.value}"`);
    if (policyDirectives.length === 0) {
        return invalidValueValidationResult;
    }
    const invalidDirectives = [];
    for (let i = 0; i < policyDirectives.length; i += 1) {
        const policyDirective = policyDirectives[i].trim();
        if (!policyDirective) {
            return invalidValueValidationResult;
        }
        const chunks = policyDirective.split(SPACE);
        const [directive, ...valueChunks] = chunks;
        // e.g. "csp=child-src 'none'; ; worker-src 'none'"
        // validator it here          â†‘
        if (!directive) {
            return invalidValueValidationResult;
        }
        if (!ALLOWED_CSP_DIRECTIVES.has(directive)) {
            // e.g. "csp='child-src' 'none'"
            if (ALLOWED_CSP_DIRECTIVES.has(QuoteUtils.removeQuotes(directive))) {
                return getInvalidValidationResult(`${VALIDATION_ERROR_PREFIX.NO_CSP_DIRECTIVE_QUOTE}: '${modifierName}': ${directive}`);
            }
            invalidDirectives.push(directive);
            continue;
        }
        if (valueChunks.length === 0) {
            return getInvalidValidationResult(`${VALIDATION_ERROR_PREFIX.NO_CSP_VALUE}: '${modifierName}': '${directive}'`);
        }
    }
    if (invalidDirectives.length > 0) {
        const directivesToStr = QuoteUtils.quoteAndJoinStrings(invalidDirectives, QuoteType.Double);
        return getInvalidValidationResult(`${VALIDATION_ERROR_PREFIX.INVALID_CSP_DIRECTIVES}: '${modifierName}': ${directivesToStr}`);
    }
    return { valid: true };
};
/**
 * Validates permission allowlist origins in the value of $permissions modifier.
 *
 * @see {@link https://w3c.github.io/webappsec-permissions-policy/#allowlists}
 *
 * @param allowlistChunks Array of allowlist chunks.
 * @param directive Permission directive name.
 * @param modifierName Modifier name.
 *
 * @returns Validation result.
 */
const validatePermissionAllowlistOrigins = (allowlistChunks, directive, modifierName) => {
    const invalidOrigins = [];
    for (let i = 0; i < allowlistChunks.length; i += 1) {
        const chunk = allowlistChunks[i].trim();
        // skip few spaces between origins (they were splitted by space)
        // e.g. 'geolocation=("https://example.com"  "https://*.example.com")'
        if (chunk.length === 0) {
            continue;
        }
        /**
         * 'self' should be checked case-insensitively
         *
         * @see {@link https://w3c.github.io/webappsec-permissions-policy/#algo-parse-policy-directive}
         *
         * @example 'geolocation=(self)'
         */
        if (chunk.toLowerCase() === PERMISSIONS_TOKEN_SELF) {
            continue;
        }
        if (QuoteUtils.getStringQuoteType(chunk) !== QuoteType.Double) {
            return getInvalidValidationResult(
            // eslint-disable-next-line max-len
            `${VALIDATION_ERROR_PREFIX.INVALID_PERMISSION_ORIGIN_QUOTES}: '${modifierName}': '${directive}': '${QuoteUtils.removeQuotes(chunk)}'`);
        }
        if (!isValidPermissionsOrigin(chunk)) {
            invalidOrigins.push(chunk);
        }
    }
    if (invalidOrigins.length > 0) {
        const originsToStr = QuoteUtils.quoteAndJoinStrings(invalidOrigins);
        return getInvalidValidationResult(
        // eslint-disable-next-line max-len
        `${VALIDATION_ERROR_PREFIX.INVALID_PERMISSION_ORIGINS}: '${modifierName}': '${directive}': ${originsToStr}`);
    }
    return { valid: true };
};
/**
 * Validates permission allowlist in the modifier value.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Permissions_Policy#allowlists}
 * @see {@link https://w3c.github.io/webappsec-permissions-policy/#allowlists}
 *
 * @param allowlist Allowlist value.
 * @param directive Permission directive name.
 * @param modifierName Modifier name.
 *
 * @returns Validation result.
 */
const validatePermissionAllowlist = (allowlist, directive, modifierName) => {
    // `*` is one of available permissions tokens
    // e.g. 'fullscreen=*'
    // https://w3c.github.io/webappsec-permissions-policy/#structured-header-serialization
    if (allowlist === WILDCARD
        // e.g. 'autoplay=()'
        || allowlist === EMPTY_PERMISSIONS_ALLOWLIST) {
        return { valid: true };
    }
    if (!(allowlist.startsWith(OPEN_PARENTHESIS) && allowlist.endsWith(CLOSE_PARENTHESIS))) {
        return getInvalidValidationResult(`${VALIDATION_ERROR_PREFIX.VALUE_INVALID}: '${modifierName}'`);
    }
    const allowlistChunks = allowlist.slice(1, -1).split(SPACE);
    return validatePermissionAllowlistOrigins(allowlistChunks, directive, modifierName);
};
/**
 * Validates single permission in the modifier value.
 *
 * @param permission Single permission value.
 * @param modifierName Modifier name.
 * @param modifierValue Modifier value.
 *
 * @returns Validation result.
 */
const validateSinglePermission = (permission, modifierName, modifierValue) => {
    // empty permission in the rule
    // e.g. 'permissions=storage-access=()\\, \\, camera=()'
    // the validator is here                 â†‘
    if (!permission) {
        return getInvalidValidationResult(`${VALIDATION_ERROR_PREFIX.VALUE_INVALID}: '${modifierName}'`);
    }
    if (permission.includes(COMMA)) {
        return getInvalidValidationResult(`${VALIDATION_ERROR_PREFIX.NO_UNESCAPED_PERMISSION_COMMA}: '${modifierName}': '${modifierValue}'`);
    }
    const [directive, allowlist] = permission.split(EQUALS);
    if (!ALLOWED_PERMISSION_DIRECTIVES.has(directive)) {
        return getInvalidValidationResult(`${VALIDATION_ERROR_PREFIX.INVALID_PERMISSION_DIRECTIVE}: '${modifierName}': '${directive}'`);
    }
    return validatePermissionAllowlist(allowlist, directive, modifierName);
};
/**
 * Validates `permissions_value` custom value format.
 * Used for $permissions modifier.
 *
 * @param modifier Modifier AST node.
 *
 * @returns Validation result.
 */
const validatePermissions = (modifier) => {
    if (!modifier.value?.value) {
        return getValueRequiredValidationResult(modifier.name.value);
    }
    const modifierName = modifier.name.value;
    const modifierValue = modifier.value.value;
    // multiple permissions may be separated by escaped commas
    const permissions = modifier.value.value.split(`${BACKSLASH}${COMMA}`);
    for (let i = 0; i < permissions.length; i += 1) {
        const permission = permissions[i].trim();
        const singlePermissionValidationResult = validateSinglePermission(permission, modifierName, modifierValue);
        if (!singlePermissionValidationResult.valid) {
            return singlePermissionValidationResult;
        }
    }
    return { valid: true };
};
/**
 * Validates `referrerpolicy_value` custom value format.
 * Used for $referrerpolicy modifier.
 *
 * @param modifier Modifier AST node.
 *
 * @returns Validation result.
 */
const validateReferrerPolicy = (modifier) => {
    if (!modifier.value?.value) {
        return getValueRequiredValidationResult(modifier.name.value);
    }
    const modifierName = modifier.name.value;
    const modifierValue = modifier.value.value;
    if (!REFERRER_POLICY_DIRECTIVES.has(modifierValue)) {
        // eslint-disable-next-line max-len
        return getInvalidValidationResult(`${VALIDATION_ERROR_PREFIX.INVALID_REFERRER_POLICY_DIRECTIVE}: '${modifierName}': '${modifierValue}'`);
    }
    return { valid: true };
};
/**
 * Map of all available pre-defined validators for modifiers with custom `value_format`.
 */
const CUSTOM_VALUE_FORMAT_MAP = {
    [CustomValueFormatValidatorName.App]: validatePipeSeparatedApps,
    [CustomValueFormatValidatorName.Csp]: validateCspValue,
    [CustomValueFormatValidatorName.DenyAllow]: validatePipeSeparatedDenyAllowDomains,
    [CustomValueFormatValidatorName.Domain]: validatePipeSeparatedDomains,
    [CustomValueFormatValidatorName.Method]: validatePipeSeparatedMethods,
    [CustomValueFormatValidatorName.Permissions]: validatePermissions,
    [CustomValueFormatValidatorName.ReferrerPolicy]: validateReferrerPolicy,
    [CustomValueFormatValidatorName.StealthOption]: validatePipeSeparatedStealthOptions,
};
/**
 * Returns whether the given `valueFormat` is a valid custom value format validator name.
 *
 * @param valueFormat Value format for the modifier.
 *
 * @returns True if `valueFormat` is a supported pre-defined value format validator name, false otherwise.
 */
const isCustomValueFormatValidator = (valueFormat) => {
    return Object.keys(CUSTOM_VALUE_FORMAT_MAP).includes(valueFormat);
};
/**
 * Checks whether the value for given `modifier` is valid.
 *
 * @param modifier Modifier AST node.
 * @param valueFormat Value format for the modifier.
 *
 * @returns Validation result.
 */
const validateValue = (modifier, valueFormat) => {
    if (isCustomValueFormatValidator(valueFormat)) {
        const validator = CUSTOM_VALUE_FORMAT_MAP[valueFormat];
        return validator(modifier);
    }
    const modifierName = modifier.name.value;
    if (!modifier.value?.value) {
        return getValueRequiredValidationResult(modifierName);
    }
    let xRegExp;
    try {
        xRegExp = XRegExp(valueFormat);
    }
    catch (e) {
        throw new Error(`${SOURCE_DATA_ERROR_PREFIX.INVALID_VALUE_FORMAT_REGEXP}: '${modifierName}'`);
    }
    const isValid = xRegExp.test(modifier.value?.value);
    if (!isValid) {
        return getInvalidValidationResult(`${VALIDATION_ERROR_PREFIX.VALUE_INVALID}: '${modifierName}'`);
    }
    return { valid: true };
};

/**
 * @file Clone related utilities
 *
 * We should keep clone related functions in this file. Thus, we just provide
 * a simple interface for cloning values, we use it across the AGTree project,
 * and the implementation "under the hood" can be improved later, if needed.
 */
/**
 * Clones an input value to avoid side effects. Use it only in justified cases,
 * because it can impact performance negatively.
 *
 * @param value Value to clone
 * @returns Cloned value
 */
function clone(value) {
    // TODO: Replace cloneDeep with a more efficient implementation
    return cloneDeep(value);
}

/* eslint-disable no-bitwise */
/**
 * @file Provides platform enums.
 * The difference between specific and generic platforms is that specific platforms are individual platforms
 * (e.g. AdGuard for Windows, AdGuard for Android, etc.),
 * while generic platforms are groups of specific platforms
 * (e.g. AdGuard for any OS, AdGuard for any Chromium-based extension, etc.).
 */
/**
 * List of specific platforms.
 */
var SpecificPlatform;
(function (SpecificPlatform) {
    SpecificPlatform[SpecificPlatform["AdgOsWindows"] = 1] = "AdgOsWindows";
    SpecificPlatform[SpecificPlatform["AdgOsMac"] = 2] = "AdgOsMac";
    SpecificPlatform[SpecificPlatform["AdgOsAndroid"] = 4] = "AdgOsAndroid";
    SpecificPlatform[SpecificPlatform["AdgExtChrome"] = 8] = "AdgExtChrome";
    SpecificPlatform[SpecificPlatform["AdgExtOpera"] = 16] = "AdgExtOpera";
    SpecificPlatform[SpecificPlatform["AdgExtEdge"] = 32] = "AdgExtEdge";
    SpecificPlatform[SpecificPlatform["AdgExtFirefox"] = 64] = "AdgExtFirefox";
    SpecificPlatform[SpecificPlatform["AdgCbAndroid"] = 128] = "AdgCbAndroid";
    SpecificPlatform[SpecificPlatform["AdgCbIos"] = 256] = "AdgCbIos";
    SpecificPlatform[SpecificPlatform["AdgCbSafari"] = 512] = "AdgCbSafari";
    SpecificPlatform[SpecificPlatform["UboExtChrome"] = 1024] = "UboExtChrome";
    SpecificPlatform[SpecificPlatform["UboExtOpera"] = 2048] = "UboExtOpera";
    SpecificPlatform[SpecificPlatform["UboExtEdge"] = 4096] = "UboExtEdge";
    SpecificPlatform[SpecificPlatform["UboExtFirefox"] = 8192] = "UboExtFirefox";
    SpecificPlatform[SpecificPlatform["AbpExtChrome"] = 16384] = "AbpExtChrome";
    SpecificPlatform[SpecificPlatform["AbpExtOpera"] = 32768] = "AbpExtOpera";
    SpecificPlatform[SpecificPlatform["AbpExtEdge"] = 65536] = "AbpExtEdge";
    SpecificPlatform[SpecificPlatform["AbpExtFirefox"] = 131072] = "AbpExtFirefox";
})(SpecificPlatform || (SpecificPlatform = {}));
/**
 * List of generic platforms (combinations of specific platforms).
 */
var GenericPlatform;
(function (GenericPlatform) {
    GenericPlatform[GenericPlatform["AdgOsAny"] = 7] = "AdgOsAny";
    GenericPlatform[GenericPlatform["AdgSafariAny"] = 768] = "AdgSafariAny";
    GenericPlatform[GenericPlatform["AdgExtChromium"] = 56] = "AdgExtChromium";
    GenericPlatform[GenericPlatform["AdgExtAny"] = 120] = "AdgExtAny";
    GenericPlatform[GenericPlatform["AdgAny"] = 1023] = "AdgAny";
    GenericPlatform[GenericPlatform["UboExtChromium"] = 7168] = "UboExtChromium";
    GenericPlatform[GenericPlatform["UboExtAny"] = 15360] = "UboExtAny";
    GenericPlatform[GenericPlatform["UboAny"] = 15360] = "UboAny";
    GenericPlatform[GenericPlatform["AbpExtChromium"] = 114688] = "AbpExtChromium";
    GenericPlatform[GenericPlatform["AbpExtAny"] = 245760] = "AbpExtAny";
    GenericPlatform[GenericPlatform["AbpAny"] = 245760] = "AbpAny";
    GenericPlatform[GenericPlatform["Any"] = 262143] = "Any";
})(GenericPlatform || (GenericPlatform = {}));

/* eslint-disable no-bitwise */
/**
 * @file Provides platform mapping and helper functions.
 */
/**
 * Map of specific platforms string names to their corresponding enum values.
 */
const SPECIFIC_PLATFORM_MAP = new Map([
    ['adg_os_windows', SpecificPlatform.AdgOsWindows],
    ['adg_os_mac', SpecificPlatform.AdgOsMac],
    ['adg_os_android', SpecificPlatform.AdgOsAndroid],
    ['adg_ext_chrome', SpecificPlatform.AdgExtChrome],
    ['adg_ext_opera', SpecificPlatform.AdgExtOpera],
    ['adg_ext_edge', SpecificPlatform.AdgExtEdge],
    ['adg_ext_firefox', SpecificPlatform.AdgExtFirefox],
    ['adg_cb_android', SpecificPlatform.AdgCbAndroid],
    ['adg_cb_ios', SpecificPlatform.AdgCbIos],
    ['adg_cb_safari', SpecificPlatform.AdgCbSafari],
    ['ubo_ext_chrome', SpecificPlatform.UboExtChrome],
    ['ubo_ext_opera', SpecificPlatform.UboExtOpera],
    ['ubo_ext_edge', SpecificPlatform.UboExtEdge],
    ['ubo_ext_firefox', SpecificPlatform.UboExtFirefox],
    ['abp_ext_chrome', SpecificPlatform.AbpExtChrome],
    ['abp_ext_opera', SpecificPlatform.AbpExtOpera],
    ['abp_ext_edge', SpecificPlatform.AbpExtEdge],
    ['abp_ext_firefox', SpecificPlatform.AbpExtFirefox],
]);
/**
 * Map of specific platforms enum values to their corresponding string names.
 *
 * @note Reverse of {@link SPECIFIC_PLATFORM_MAP}.
 */
const SPECIFIC_PLATFORM_MAP_REVERSE = new Map([...SPECIFIC_PLATFORM_MAP].map(([key, value]) => [value, key]));
/**
 * Map of generic platforms string names to their corresponding enum values.
 */
const GENERIC_PLATFORM_MAP = new Map([
    ['adg_os_any', GenericPlatform.AdgOsAny],
    ['adg_safari_any', GenericPlatform.AdgSafariAny],
    ['adg_ext_chromium', GenericPlatform.AdgExtChromium],
    ['adg_ext_any', GenericPlatform.AdgExtAny],
    ['adg_any', GenericPlatform.AdgAny],
    ['ubo_ext_chromium', GenericPlatform.UboExtChromium],
    ['ubo_ext_any', GenericPlatform.UboExtAny],
    ['ubo_any', GenericPlatform.UboAny],
    ['abp_ext_chromium', GenericPlatform.AbpExtChromium],
    ['abp_ext_any', GenericPlatform.AbpExtAny],
    ['abp_any', GenericPlatform.AbpAny],
    ['any', GenericPlatform.Any],
]);
/**
 * Check if the platform is a generic platform.
 *
 * @param platform Platform to check.
 *
 * @returns True if the platform is a generic platform, false otherwise.
 */
const isGenericPlatform = (platform) => {
    // if more than one bit is set, it's a generic platform
    return !!(platform & (platform - 1));
};
/**
 * Returns the platform enum value for the given platform string name.
 *
 * @param platform Platform string name, e.g., 'adg_os_windows'.
 *
 * @returns Specific or generic platform enum value.
 * @throws Error if the platform is unknown.
 */
const getPlatformId = (platform) => {
    const specificPlatform = SPECIFIC_PLATFORM_MAP.get(platform);
    if (specificPlatform) {
        return specificPlatform;
    }
    const genericPlatform = GENERIC_PLATFORM_MAP.get(platform);
    if (genericPlatform) {
        return genericPlatform;
    }
    throw new Error(`Unknown platform: ${platform}`);
};
/**
 * Returns the specific platform string name for the given platform enum value.
 *
 * @param platform Specific platform enum value.
 *
 * @returns Specific platform string name, e.g., 'adg_os_windows'.
 * @throws Error if the platform is unknown.
 */
const getSpecificPlatformName = (platform) => {
    const specificPlatform = SPECIFIC_PLATFORM_MAP_REVERSE.get(platform);
    if (!specificPlatform) {
        throw new Error(`Unknown platform: ${platform}`);
    }
    return specificPlatform;
};

/* eslint-disable no-bitwise */
/**
 * @file Provides common compatibility table methods.
 */
/**
 * Base compatibility table class which provides common methods to work with compatibility data.
 *
 * @template T Compatibility data schema.
 */
class CompatibilityTableBase {
    /**
     * Compatibility table data.
     */
    data;
    /**
     * Optional name transformer function. If provided,
     * it will be called in all methods before processing compatibility data names.
     */
    nameTransformer;
    /**
     * Creates a new instance of the common compatibility table.
     *
     * @param data Compatibility table data.
     * @param nameTransformer Optional name transformer function.
     */
    constructor(data, nameTransformer = null) {
        this.data = data;
        this.nameTransformer = nameTransformer;
    }
    /**
     * Helper method to get a 'row' from the compatibility table data by name.
     *
     * @param name Compatibility data name.
     * @returns Compatibility table row storage or `null` if not found.
     */
    getRowStorage(name) {
        const idx = this.data.map[name];
        if (isUndefined(idx)) {
            return null;
        }
        return this.data.shared[idx];
    }
    /**
     * Checks whether a compatibility data `name` exists for any platform.
     *
     * @note Technically, do the same as `exists()` method with generic platform _any_
     * but it is faster because it does not apply complex logic.
     *
     * @param name Compatibility data name.
     *
     * @returns True if the compatibility data exists, false otherwise.
     */
    existsAny(name) {
        const normalizedName = this.nameTransformer ? this.nameTransformer(name) : name;
        return !isUndefined(this.data.map[normalizedName]);
    }
    /**
     * Checks whether a compatibility data `name` exists for a specified platform.
     *
     * @param name Compatibility data name.
     * @param platform Specific or generic platform.
     *
     * @returns True if the compatibility data exists, false otherwise.
     */
    exists(name, platform) {
        const normalizedName = this.nameTransformer ? this.nameTransformer(name) : name;
        const data = this.getRowStorage(normalizedName);
        if (!data) {
            return false;
        }
        const isMatch = (idx) => {
            const el = data.shared[idx];
            return !isUndefined(el) && (el.name === normalizedName || !!el.aliases?.includes(normalizedName));
        };
        if (isGenericPlatform(platform)) {
            // Since indexes are specific platforms in the compatibility table data,
            // we can't index them directly if the platform is generic (union of specific platforms).
            // In this case, we need to iterate over the keys and return true on the first match.
            const keys = Object.keys(data.map);
            for (let i = 0; i < keys.length; i += 1) {
                const key = Number(keys[i]);
                if (platform & key) {
                    const idx = data.map[key];
                    if (isMatch(idx)) {
                        return true;
                    }
                }
            }
            return false;
        }
        const idx = data.map[platform];
        return isMatch(idx);
    }
    /**
     * Returns a compatibility data by name and specific platform.
     *
     * @param name The name of the compatibility data.
     * @param platform The specific platform.
     *
     * @returns A single compatibility data or `null` if not found.
     */
    getSingle(name, platform) {
        const normalizedName = this.nameTransformer ? this.nameTransformer(name) : name;
        const data = this.getRowStorage(normalizedName);
        if (!data) {
            return null;
        }
        const idx = data.map[platform];
        return isUndefined(idx) ? null : data.shared[idx];
    }
    /**
     * Returns all compatibility data records for name and specified platform.
     *
     * @param name Compatibility data name.
     * @param platform Specific or generic platform.
     *
     * @returns Multiple records grouped by platforms.
     * Technically, it is an object where keys are platform enums values and values are compatibility data records.
     *
     * @note Platform enum values can be converted to string names using {@link getSpecificPlatformName} on demand.
     */
    getMultiple(name, platform) {
        const normalizedName = this.nameTransformer ? this.nameTransformer(name) : name;
        const data = this.getRowStorage(normalizedName);
        if (!data) {
            return null;
        }
        if (isGenericPlatform(platform)) {
            const result = {};
            const keys = Object.keys(data.map);
            for (let i = 0; i < keys.length; i += 1) {
                const key = Number(keys[i]);
                if (platform & key) {
                    const idx = data.map[key];
                    if (!isUndefined(idx)) {
                        result[key] = data.shared[idx];
                    }
                }
            }
            return result;
        }
        const idx = data.map[platform];
        if (isUndefined(idx)) {
            return null;
        }
        return { key: data.shared[idx] };
    }
    /**
     * Returns all compatibility data records for the specified platform.
     *
     * @param platform Specific or generic platform.
     *
     * @returns Array of multiple records grouped by platforms.
     */
    getAllMultiple(platform) {
        const result = [];
        for (let i = 0; i < this.data.shared.length; i += 1) {
            const data = this.data.shared[i];
            const names = new Set(data.shared.map(({ name }) => name));
            names.forEach((name) => {
                const multipleRecords = this.getMultiple(name, platform);
                if (multipleRecords) {
                    result.push(multipleRecords);
                }
            });
        }
        return result;
    }
    /**
     * Returns the first compatibility data record for name and specified platform.
     *
     * @param name Compatibility data name.
     * @param platform Specific or generic platform.
     *
     * @returns First found compatibility data record or `null` if not found.
     */
    getFirst(name, platform) {
        const normalizedName = this.nameTransformer ? this.nameTransformer(name) : name;
        const data = this.getRowStorage(normalizedName);
        if (!data) {
            return null;
        }
        if (isGenericPlatform(platform)) {
            const keys = Object.keys(data.map);
            for (let i = 0; i < keys.length; i += 1) {
                const key = Number(keys[i]);
                if (platform & key) {
                    const idx = data.map[key];
                    if (!isUndefined(idx)) {
                        // return the first found record
                        return data.shared[idx];
                    }
                }
            }
            return null;
        }
        const idx = data.map[platform];
        if (isUndefined(idx)) {
            return null;
        }
        return data.shared[idx];
    }
    /**
     * Returns all compatibility data records for the specified name.
     *
     * @param name Compatibility data name.
     *
     * @returns Array of multiple records grouped by platforms.
     */
    getRow(name) {
        const normalizedName = this.nameTransformer ? this.nameTransformer(name) : name;
        const data = this.getRowStorage(normalizedName);
        if (!data) {
            return [];
        }
        return data.shared;
    }
    /**
     * Returns all compatibility data grouped by products.
     *
     * @returns Array of multiple records grouped by products.
     */
    getRowsByProduct() {
        const result = [];
        for (let i = 0; i < this.data.shared.length; i += 1) {
            const data = this.data.shared[i];
            const keys = Object.keys(data.map);
            const row = {
                [AdblockSyntax.Adg]: {},
                [AdblockSyntax.Ubo]: {},
                [AdblockSyntax.Abp]: {},
            };
            for (let j = 0; j < keys.length; j += 1) {
                const key = Number(keys[j]);
                if (key & GenericPlatform.AdgAny) {
                    row[AdblockSyntax.Adg][key] = data.shared[data.map[key]];
                }
                else if (key & GenericPlatform.UboAny) {
                    row[AdblockSyntax.Ubo][key] = data.shared[data.map[key]];
                }
                else if (key & GenericPlatform.AbpAny) {
                    row[AdblockSyntax.Abp][key] = data.shared[data.map[key]];
                }
            }
            result.push(row);
        }
        return result;
    }
}

/**
 * Simple deep freeze implementation.
 * It freezes the object and all its properties recursively.
 *
 * @param object Object to freeze.
 *
 * @returns Frozen object.
 *
 * @template T Type of the object to freeze.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze#deep_freezing}
 */
const deepFreeze = (object) => {
    // Retrieve the property names defined on object
    const propNames = Reflect.ownKeys(object);
    // Freeze properties before freezing self
    for (const name of propNames) {
        const value = object[name];
        if ((value && typeof value === 'object') || typeof value === 'function') {
            deepFreeze(value);
        }
    }
    return Object.freeze(object);
};

/**
 * @file Compatibility tables for modifiers.
 */
/**
 * Transforms the name of the modifier to a normalized form.
 * This is a special case: the noop modifier normally '_', but it can consist of any number of characters,
 * e.g. '____' is also valid. In this case, we need to normalize the name to '_'.
 *
 * @param name Modifier name to normalize.
 * @returns Normalized modifier name.
 */
const noopModifierNameNormalizer = (name) => {
    if (name.startsWith(UNDERSCORE)) {
        if (name.split(EMPTY).every((char) => char === UNDERSCORE)) {
            // in compatibility tables, we just store '_', so we need to reduce the number of underscores to 1
            // before checking the existence of the noop modifier
            return UNDERSCORE;
        }
    }
    return name;
};
/**
 * Compatibility table for modifiers.
 */
class ModifiersCompatibilityTable extends CompatibilityTableBase {
    /**
     * Creates a new instance of the compatibility table for modifiers.
     *
     * @param data Compatibility table data.
     */
    constructor(data) {
        super(data, noopModifierNameNormalizer);
    }
}
/**
 * Deep freeze the compatibility table data to avoid accidental modifications.
 */
deepFreeze(modifiersCompatibilityTableData);
/**
 * Compatibility table instance for modifiers.
 */
const modifiersCompatibilityTable = new ModifiersCompatibilityTable(modifiersCompatibilityTableData);

/**
 * @file Validator for modifiers.
 */
const convertSyntaxToGenericPlatform = (syntax) => {
    switch (syntax) {
        case AdblockSyntax.Adg:
            return GenericPlatform.AdgAny;
        case AdblockSyntax.Ubo:
            return GenericPlatform.UboAny;
        case AdblockSyntax.Abp:
            return GenericPlatform.AbpAny;
        default:
            throw new Error(`Unknown syntax: ${syntax}`);
    }
};
/**
 * Fully checks whether the given `modifier` valid for given blocker `syntax`:
 * is it supported by the blocker, deprecated, assignable, negatable, etc.
 *
 * @param syntax Adblock syntax to check the modifier for.
 * 'Common' is not supported, it should be specific â€” 'AdGuard', 'uBlockOrigin', or 'AdblockPlus'.
 * @param modifier Parsed modifier AST node.
 * @param isException Whether the modifier is used in exception rule.
 * Needed to check whether the modifier is allowed only in blocking or exception rules.
 *
 * @returns Result of modifier validation.
 */
const validateForSpecificSyntax = (syntax, modifier, isException) => {
    if (syntax === AdblockSyntax.Common) {
        throw new Error(`Syntax should be specific, '${AdblockSyntax.Common}' is not supported`);
    }
    const modifierName = modifier.name.value;
    const blockerPrefix = BLOCKER_PREFIX[syntax];
    if (!blockerPrefix) {
        throw new Error(`Unknown syntax: ${syntax}`);
    }
    // needed for validation of negation, assignment, etc.
    const specificBlockerData = modifiersCompatibilityTable.getFirst(modifierName, convertSyntaxToGenericPlatform(syntax));
    // if no specific blocker data is found
    if (!specificBlockerData) {
        return getInvalidValidationResult(`${VALIDATION_ERROR_PREFIX.NOT_SUPPORTED}: '${modifierName}'`);
    }
    // e.g. 'object-subrequest'
    if (specificBlockerData.removed) {
        return getInvalidValidationResult(`${VALIDATION_ERROR_PREFIX.REMOVED}: '${modifierName}'`);
    }
    if (specificBlockerData.deprecated) {
        if (!specificBlockerData.deprecationMessage) {
            throw new Error(`${SOURCE_DATA_ERROR_PREFIX.NO_DEPRECATION_MESSAGE}: '${modifierName}'`);
        }
        // prepare the message which is multiline in the yaml file
        const warn = specificBlockerData.deprecationMessage.replace(NEWLINE, SPACE);
        return {
            valid: true,
            warn,
        };
    }
    if (specificBlockerData.blockOnly && isException) {
        return getInvalidValidationResult(`${VALIDATION_ERROR_PREFIX.BLOCK_ONLY}: '${modifierName}'`);
    }
    if (specificBlockerData.exceptionOnly && !isException) {
        return getInvalidValidationResult(`${VALIDATION_ERROR_PREFIX.EXCEPTION_ONLY}: '${modifierName}'`);
    }
    // e.g. '~domain=example.com'
    if (!specificBlockerData.negatable && modifier.exception) {
        return getInvalidValidationResult(`${VALIDATION_ERROR_PREFIX.NOT_NEGATABLE_MODIFIER}: '${modifierName}'`);
    }
    // e.g. 'domain'
    if (specificBlockerData.assignable) {
        if (!modifier.value) {
            // TODO: ditch value_optional after custom validators are implemented for value_format for all modifiers.
            // This checking should be done in each separate custom validator,
            // because $csp and $permissions without value can be used only in extension rules,
            // but $cookie with no value can be used in both blocking and exception rules.
            /**
             * Some assignable modifiers can be used without a value,
             * e.g. '@@||example.com^$cookie'.
             */
            if (specificBlockerData.valueOptional) {
                return { valid: true };
            }
            // for other assignable modifiers the value is required
            return getValueRequiredValidationResult(modifierName);
        }
        /**
         * TODO: consider to return `{ valid: true, warn: 'Modifier value may be specified' }` (???)
         * for $stealth modifier without a value
         * but only after the extension will support value for $stealth:
         * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/2107
         */
        if (!specificBlockerData.valueFormat) {
            throw new Error(`${SOURCE_DATA_ERROR_PREFIX.NO_VALUE_FORMAT_FOR_ASSIGNABLE}: '${modifierName}'`);
        }
        return validateValue(modifier, specificBlockerData.valueFormat);
    }
    if (modifier?.value) {
        // e.g. 'third-party=true'
        return getInvalidValidationResult(`${VALIDATION_ERROR_PREFIX.VALUE_FORBIDDEN}: '${modifierName}'`);
    }
    return { valid: true };
};
// TODO: move to modifier.ts and use index.ts only for exporting
/**
 * Modifier validator class.
 */
class ModifierValidator {
    /**
     * Simply checks whether the modifier exists in any adblocker.
     *
     * **Deprecated** and **removed** modifiers are considered as **existent**.
     *
     * @param modifier Already parsed modifier AST node.
     *
     * @returns True if modifier exists, false otherwise.
     */
    // eslint-disable-next-line class-methods-use-this
    exists = (modifier) => {
        return modifiersCompatibilityTable.existsAny(modifier.name.value);
    };
    /**
     * Checks whether the given `modifier` is valid for specified `syntax`.
     *
     * For `Common` syntax it simply checks whether the modifier exists.
     * For specific syntax the validation is more complex â€”
     * deprecated, assignable, negatable and other requirements are checked.
     *
     * @param syntax Adblock syntax to check the modifier for.
     * @param rawModifier Modifier AST node.
     * @param isException Whether the modifier is used in exception rule, default to false.
     * Needed to check whether the modifier is allowed only in blocking or exception rules.
     *
     * @returns Result of modifier validation.
     */
    validate = (syntax, rawModifier, isException = false) => {
        const modifier = clone(rawModifier);
        // special case: handle noop modifier which may be used as multiple underscores (not just one)
        // https://adguard.com/kb/general/ad-filtering/create-own-filters/#noop-modifier
        if (modifier.name.value.startsWith(UNDERSCORE)) {
            // check whether the modifier value contains something else besides underscores
            if (!isValidNoopModifier(modifier.name.value)) {
                return getInvalidValidationResult(`${VALIDATION_ERROR_PREFIX.INVALID_NOOP}: '${modifier.name.value}'`);
            }
            // otherwise, replace the modifier value with single underscore.
            // it is needed to check whether the modifier is supported by specific adblocker due to the syntax
            modifier.name.value = UNDERSCORE;
        }
        if (!this.exists(modifier)) {
            return getInvalidValidationResult(`${VALIDATION_ERROR_PREFIX.NOT_EXISTENT}: '${modifier.name.value}'`);
        }
        // for 'Common' syntax we cannot check something more
        if (syntax === AdblockSyntax.Common) {
            return { valid: true };
        }
        return validateForSpecificSyntax(syntax, modifier, isException);
    };
}
const modifierValidator = new ModifierValidator();

/**
 * @file Base class for converters
 *
 * TS doesn't support abstract static methods, so we should use
 * a workaround and extend this class instead of implementing it
 */
/* eslint-disable jsdoc/require-returns-check */
/* eslint-disable @typescript-eslint/no-unused-vars */
/**
 * Basic class for rule converters
 */
class ConverterBase {
    /**
     * Converts some data to AdGuard format
     *
     * @param data Data to convert
     * @returns An object which follows the {@link ConversionResult} interface. Its `result` property contains
     * the converted node, and its `isConverted` flag indicates whether the original node was converted.
     * If the node was not converted, the result will contain the original node with the same object reference
     * @throws If the data is invalid or incompatible
     */
    static convertToAdg(data) {
        throw new NotImplementedError();
    }
    /**
     * Converts some data to Adblock Plus format
     *
     * @param data Data to convert
     * @returns An object which follows the {@link ConversionResult} interface. Its `result` property contains
     * the converted node, and its `isConverted` flag indicates whether the original node was converted.
     * If the node was not converted, the result will contain the original node with the same object reference
     * @throws If the data is invalid or incompatible
     */
    static convertToAbp(data) {
        throw new NotImplementedError();
    }
    /**
     * Converts some data to uBlock Origin format
     *
     * @param data Data to convert
     * @returns An object which follows the {@link ConversionResult} interface. Its `result` property contains
     * the converted node, and its `isConverted` flag indicates whether the original node was converted.
     * If the node was not converted, the result will contain the original node with the same object reference
     * @throws If the data is invalid or incompatible
     */
    static convertToUbo(data) {
        throw new NotImplementedError();
    }
}

/**
 * @file Base class for rule converters
 *
 * TS doesn't support abstract static methods, so we should use
 * a workaround and extend this class instead of implementing it
 */
/* eslint-disable jsdoc/require-returns-check */
/* eslint-disable @typescript-eslint/no-unused-vars */
/**
 * Basic class for rule converters
 */
class RuleConverterBase extends ConverterBase {
    /**
     * Converts an adblock filtering rule to AdGuard format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToAdg(rule) {
        throw new NotImplementedError();
    }
    /**
     * Converts an adblock filtering rule to Adblock Plus format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToAbp(rule) {
        throw new NotImplementedError();
    }
    /**
     * Converts an adblock filtering rule to uBlock Origin format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToUbo(rule) {
        throw new NotImplementedError();
    }
}

/**
 * @file Conversion result interface and helper functions
 */
/**
 * Helper function to create a generic conversion result.
 *
 * @param result Conversion result
 * @param isConverted Indicates whether the input item was converted
 * @template T Type of the item to convert
 * @template U Type of the conversion result (defaults to `T`, but can be `T[]` as well)
 * @returns Generic conversion result
 */
// eslint-disable-next-line max-len
function createConversionResult(result, isConverted) {
    return {
        result,
        isConverted,
    };
}
/**
 * Helper function to create a node conversion result.
 *
 * @param nodes Array of nodes
 * @param isConverted Indicates whether the input item was converted
 * @template T Type of the node (extends `Node`)
 * @returns Node conversion result
 */
function createNodeConversionResult(nodes, isConverted) {
    return createConversionResult(nodes, isConverted);
}

/**
 * @file Comment rule converter
 */
/**
 * Comment rule converter class
 *
 * @todo Implement `convertToUbo` and `convertToAbp`
 */
class CommentRuleConverter extends RuleConverterBase {
    /**
     * Converts a comment rule to AdGuard format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToAdg(rule) {
        // TODO: Add support for other comment types, if needed
        // Main task is # -> ! conversion
        switch (rule.type) {
            case CommentRuleType.CommentRule:
                // Check if the rule needs to be converted
                if (rule.type === CommentRuleType.CommentRule && rule.marker.value === CommentMarker.Hashmark) {
                    // Add a ! to the beginning of the comment
                    // TODO: Replace with custom clone method
                    const ruleClone = clone(rule);
                    ruleClone.marker.value = CommentMarker.Regular;
                    // Add the hashmark to the beginning of the comment text
                    ruleClone.text.value = `${SPACE}${CommentMarker.Hashmark}${ruleClone.text.value}`;
                    return createNodeConversionResult([ruleClone], true);
                }
                return createNodeConversionResult([rule], false);
            // Leave any other comment rule as is
            default:
                return createNodeConversionResult([rule], false);
        }
    }
}

/**
 * @file Regular expression utilities
 */
// Special RegExp constants
const REGEX_START = CARET; // '^'
const REGEX_END = DOLLAR_SIGN; // '$'
const REGEX_ANY_CHARACTERS = DOT + ASTERISK; // '.*'
// Special adblock pattern symbols and their RegExp equivalents
const ADBLOCK_URL_START = PIPE + PIPE; // '||'
const ADBLOCK_URL_START_REGEX = '^(http|https|ws|wss)://([a-z0-9-_.]+\\.)?';
const ADBLOCK_URL_SEPARATOR = CARET; // '^'
const ADBLOCK_URL_SEPARATOR_REGEX = '([^ a-zA-Z0-9.%_-]|$)';
const ADBLOCK_WILDCARD = ASTERISK; // '*'
const ADBLOCK_WILDCARD_REGEX = REGEX_ANY_CHARACTERS;
// Negation wrapper for RegExp patterns
const REGEX_NEGATION_PREFIX = '^((?!';
const REGEX_NEGATION_SUFFIX = ').)*$';
/**
 * Special RegExp symbols
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#special-escape
 */
const SPECIAL_REGEX_SYMBOLS = new Set([
    ASTERISK,
    CARET,
    CLOSE_CURLY_BRACKET,
    CLOSE_PARENTHESIS,
    CLOSE_SQUARE_BRACKET,
    DOLLAR_SIGN,
    DOT,
    ESCAPE_CHARACTER,
    OPEN_CURLY_BRACKET,
    OPEN_PARENTHESIS,
    OPEN_SQUARE_BRACKET,
    PIPE,
    PLUS,
    QUESTION_MARK,
    SLASH,
]);
/**
 * Utility functions for working with RegExp patterns
 */
class RegExpUtils {
    /**
     * Checks whether a string possibly is a RegExp pattern.
     * Flags are not supported.
     *
     * Note: it does not perform a full validation of the pattern,
     * it just checks if the string starts and ends with a slash.
     *
     * @param pattern - Pattern to check
     * @returns `true` if the string is a RegExp pattern, `false` otherwise
     */
    static isRegexPattern(pattern) {
        const trimmedPattern = pattern.trim();
        // Avoid false positives
        return trimmedPattern.length > REGEX_MARKER.length * 2
            && trimmedPattern.startsWith(REGEX_MARKER)
            && trimmedPattern.endsWith(REGEX_MARKER)
            && trimmedPattern[REGEX_MARKER.length - 2] !== ESCAPE_CHARACTER;
    }
    /**
     * Negates a RegExp pattern. Technically, this method wraps the pattern in `^((?!` and `).)*$`.
     *
     * RegExp modifiers are not supported.
     *
     * @param pattern Pattern to negate (can be wrapped in slashes or not)
     * @returns Negated RegExp pattern
     */
    static negateRegexPattern(pattern) {
        let result = pattern.trim();
        let slashes = false;
        // Remove the leading and trailing slashes (/)
        if (RegExpUtils.isRegexPattern(result)) {
            result = result.substring(REGEX_MARKER.length, result.length - REGEX_MARKER.length);
            slashes = true;
        }
        // Only negate the pattern if it's not already negated
        if (!(result.startsWith(REGEX_NEGATION_PREFIX) && result.endsWith(REGEX_NEGATION_SUFFIX))) {
            // Remove leading caret (^)
            if (result.startsWith(REGEX_START)) {
                result = result.substring(REGEX_START.length);
            }
            // Remove trailing dollar sign ($)
            if (result.endsWith(REGEX_END)) {
                result = result.substring(0, result.length - REGEX_END.length);
            }
            // Wrap the pattern in the negation
            result = `${REGEX_NEGATION_PREFIX}${result}${REGEX_NEGATION_SUFFIX}`;
        }
        // Add the leading and trailing slashes back if they were there
        if (slashes) {
            result = `${REGEX_MARKER}${result}${REGEX_MARKER}`;
        }
        return result;
    }
    /**
     * Converts a basic adblock rule pattern to a RegExp pattern. Based on
     * https://github.com/AdguardTeam/tsurlfilter/blob/9b26e0b4a0e30b87690bc60f7cf377d112c3085c/packages/tsurlfilter/src/rules/simple-regex.ts#L219
     *
     * @param pattern Pattern to convert
     * @returns RegExp equivalent of the pattern
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules}
     */
    static patternToRegexp(pattern) {
        const trimmed = pattern.trim();
        // Return regex for any character sequence if the pattern is just |, ||, * or empty
        if (trimmed === ADBLOCK_URL_START
            || trimmed === PIPE
            || trimmed === ADBLOCK_WILDCARD
            || trimmed === EMPTY) {
            return REGEX_ANY_CHARACTERS;
        }
        // If the pattern is already a RegExp, just return it, but remove the leading and trailing slashes
        if (RegExpUtils.isRegexPattern(pattern)) {
            return pattern.substring(REGEX_MARKER.length, pattern.length - REGEX_MARKER.length);
        }
        let result = EMPTY;
        let offset = 0;
        let len = trimmed.length;
        // Handle leading pipes
        if (trimmed[0] === PIPE) {
            if (trimmed[1] === PIPE) {
                // Replace adblock url start (||) with its RegExp equivalent
                result += ADBLOCK_URL_START_REGEX;
                offset = ADBLOCK_URL_START.length;
            }
            else {
                // Replace single pipe (|) with the RegExp start symbol (^)
                result += REGEX_START;
                offset = REGEX_START.length;
            }
        }
        // Handle trailing pipes
        let trailingPipe = false;
        if (trimmed.endsWith(PIPE)) {
            trailingPipe = true;
            len -= PIPE.length;
        }
        // Handle the rest of the pattern, if any
        for (; offset < len; offset += 1) {
            if (trimmed[offset] === ADBLOCK_WILDCARD) {
                // Replace adblock wildcard (*) with its RegExp equivalent
                result += ADBLOCK_WILDCARD_REGEX;
            }
            else if (trimmed[offset] === ADBLOCK_URL_SEPARATOR) {
                // Replace adblock url separator (^) with its RegExp equivalent
                result += ADBLOCK_URL_SEPARATOR_REGEX;
            }
            else if (SPECIAL_REGEX_SYMBOLS.has(trimmed[offset])) {
                // Escape special RegExp symbols (we handled pipe (|) and asterisk (*) already)
                result += ESCAPE_CHARACTER + trimmed[offset];
            }
            else {
                // Just add any other character
                result += trimmed[offset];
            }
        }
        // Handle trailing pipes
        if (trailingPipe) {
            // Replace trailing pipe (|) with the RegExp end symbol ($)
            result += REGEX_END;
        }
        return result;
    }
}

/**
 * @file Custom clone functions for AST nodes, this is probably the most efficient way to clone AST nodes.
 * @todo Maybe move them to parser classes as 'clone' methods
 */
/**
 * Clones a scriptlet rule node.
 *
 * @param node Node to clone
 * @returns Cloned node
 */
function cloneScriptletRuleNode(node) {
    return {
        type: node.type,
        children: node.children.map((child) => (isNull(child) ? null : { ...child })),
    };
}
/**
 * Clones a domain list node.
 *
 * @param node Node to clone
 * @returns Cloned node
 */
function cloneDomainListNode(node) {
    return {
        type: node.type,
        separator: node.separator,
        children: node.children.map((domain) => ({ ...domain })),
    };
}
/**
 * Clones a modifier list node.
 *
 * @param node Node to clone
 * @returns Cloned node
 */
function cloneModifierListNode(node) {
    return {
        type: node.type,
        children: node.children.map((modifier) => {
            const res = {
                type: modifier.type,
                exception: modifier.exception,
                name: { ...modifier.name },
            };
            if (modifier.value) {
                res.value = { ...modifier.value };
            }
            return res;
        }),
    };
}

/**
 * @file HTML filtering rule converter
 */
/**
 * From the AdGuard docs:
 * Specifies the maximum length for content of HTML element. If this parameter is
 * set and the content length exceeds the value, a rule does not apply to the element.
 * If this parameter is not specified, the max-length is considered to be 8192 (8 KB).
 * When converting from other formats, we set the max-length to 262144 (256 KB).
 *
 * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#html-filtering-rules}
 */
const ADG_HTML_DEFAULT_MAX_LENGTH = 8192;
const ADG_HTML_CONVERSION_MAX_LENGTH = ADG_HTML_DEFAULT_MAX_LENGTH * 32;
const NOT_SPECIFIED = -1;
var PseudoClasses$1;
(function (PseudoClasses) {
    PseudoClasses["Contains"] = "contains";
    PseudoClasses["HasText"] = "has-text";
    PseudoClasses["MinTextLength"] = "min-text-length";
})(PseudoClasses$1 || (PseudoClasses$1 = {}));
var AttributeSelectors;
(function (AttributeSelectors) {
    AttributeSelectors["MaxLength"] = "max-length";
    AttributeSelectors["MinLength"] = "min-length";
    AttributeSelectors["TagContent"] = "tag-content";
    AttributeSelectors["Wildcard"] = "wildcard";
})(AttributeSelectors || (AttributeSelectors = {}));
const SUPPORTED_UBO_PSEUDO_CLASSES = new Set([
    PseudoClasses$1.Contains,
    PseudoClasses$1.HasText,
    PseudoClasses$1.MinTextLength,
]);
const ERROR_MESSAGES$2 = {
    ABP_NOT_SUPPORTED: 'Invalid rule, ABP does not support HTML filtering rules',
    TAG_SHOULD_BE_FIRST_CHILD: "Unexpected token '%s' with value '%s', tag selector should be the first child",
    EXPECTED_BUT_GOT_WITH_VALUE: "Expected '%s', but got '%s' with value '%s'",
    INVALID_ATTRIBUTE_NAME: "Attribute name should be an identifier, but got '%s' with value '%s'",
    // eslint-disable-next-line max-len
    INVALID_ATTRIBUTE_VALUE: `Expected '${getFormattedTokenName(TokenType$1.Ident)}' or '${getFormattedTokenName(TokenType$1.String)}' as attribute value, but got '%s' with value '%s`,
    INVALID_FLAG: "Unsupported attribute selector flag '%s'",
    INVALID_OPERATOR_FOR_ATTR: "Unsupported operator '%s' for '%s' attribute",
    VALUE_FOR_ATTR_SHOULD_BE_INT: "Value for '%s' attribute should be an integer, but got '%s'",
    INVALID_PSEUDO_CLASS: "Unsupported pseudo class '%s'",
    VALUE_FOR_PSEUDO_CLASS_SHOULD_BE_INT: "Value for '%s' pseudo class should be an integer, but got '%s'",
    // eslint-disable-next-line max-len
    REGEXP_NOT_SUPPORTED: "Cannot convert RegExp parameter '%s' from '%s' pseudo class, because converting RegExp patterns are not supported yet",
    ATTRIBUTE_SELECTOR_REQUIRES_VALUE: "Attribute selector '%s' requires a value",
    INVALID_ATTRIBUTE_SELECTOR_OPERATOR: "Unsupported attribute selector operator '%s'",
    VALUE_SHOULD_BE_SPECIFIED: 'Value should be specified if operator is specified',
    OPERATOR_SHOULD_BE_SPECIFIED: 'Operator should be specified if value is specified',
    UNEXPECTED_TOKEN_WITH_VALUE: "Unexpected token '%s' with value '%s'",
    FLAGS_NOT_SUPPORTED: 'Flags are not supported for attribute selectors',
};
/**
 * Convert `""` to `\"` within strings, because it does not compatible with the standard CSS syntax.
 *
 * @param selector CSS selector string
 * @returns Escaped CSS selector
 * @note In the legacy syntax, `""` is used to escape double quotes, but it cannot be used in the standard CSS syntax,
 * so we use conversion functions to handle this.
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#tag-content}
 */
function escapeDoubleQuotes(selector) {
    let withinString = false;
    const buffer = [];
    for (let i = 0; i < selector.length; i += 1) {
        if (!withinString && selector[i] === DOUBLE_QUOTE_MARKER) {
            withinString = true;
            buffer.push(selector[i]);
        }
        else if (withinString && selector[i] === DOUBLE_QUOTE_MARKER && selector[i + 1] === DOUBLE_QUOTE_MARKER) {
            buffer.push(ESCAPE_CHARACTER);
            buffer.push(DOUBLE_QUOTE_MARKER);
            i += 1;
        }
        else if (withinString && selector[i] === DOUBLE_QUOTE_MARKER && selector[i + 1] !== DOUBLE_QUOTE_MARKER) {
            buffer.push(DOUBLE_QUOTE_MARKER);
            withinString = false;
        }
        else {
            buffer.push(selector[i]);
        }
    }
    return buffer.join(EMPTY);
}
/**
 * Convert escaped double quotes `\"` to `""` within strings.
 *
 * @param selector CSS selector string
 * @returns Unescaped CSS selector
 * @note In the legacy syntax, `""` is used to escape double quotes, but it cannot be used in the standard CSS syntax,
 * so we use conversion functions to handle this.
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#tag-content}
 */
function unescapeDoubleQuotes(selector) {
    let withinString = false;
    const buffer = [];
    for (let i = 0; i < selector.length; i += 1) {
        if (selector[i] === DOUBLE_QUOTE_MARKER && selector[i - 1] !== ESCAPE_CHARACTER) {
            withinString = !withinString;
            buffer.push(selector[i]);
        }
        else if (withinString && selector[i] === ESCAPE_CHARACTER && selector[i + 1] === DOUBLE_QUOTE_MARKER) {
            buffer.push(DOUBLE_QUOTE_MARKER);
        }
        else {
            buffer.push(selector[i]);
        }
    }
    return buffer.join(EMPTY);
}
/**
 * Helper function to render an attribute selector
 *
 * @param attr Attribute name
 * @param op Operator (optional)
 * @param value Attribute value (optional)
 * @param flags Attribute flags (optional)
 * @returns Rendered attribute selector string
 */
function renderAttrSelector(attr, op, value, flags) {
    const result = [];
    result.push(OPEN_SQUARE_BRACKET);
    result.push(attr);
    if (op !== undefined) {
        if (value === undefined) {
            throw new Error(ERROR_MESSAGES$2.VALUE_SHOULD_BE_SPECIFIED);
        }
        result.push(op);
    }
    if (value !== undefined) {
        if (!op) {
            throw new Error(ERROR_MESSAGES$2.OPERATOR_SHOULD_BE_SPECIFIED);
        }
        result.push(DOUBLE_QUOTE_MARKER);
        result.push(value);
        result.push(DOUBLE_QUOTE_MARKER);
    }
    if (flags !== undefined) {
        result.push(SPACE);
        result.push(flags);
    }
    result.push(CLOSE_SQUARE_BRACKET);
    return result.join(EMPTY);
}
/**
 * HTML filtering rule converter class
 *
 * @todo Implement `convertToUbo` (ABP currently doesn't support HTML filtering rules)
 */
class HtmlRuleConverter extends RuleConverterBase {
    /**
     * Converts a HTML rule to AdGuard syntax, if possible. Also can be used to convert
     * AdGuard rules to AdGuard syntax to validate them.
     *
     * _Note:_ uBlock Origin supports multiple selectors within a single rule, but AdGuard doesn't,
     * so the following rule
     * ```
     * example.com##^div[attr1="value1"][attr2="value2"], script:has-text(value)
     * ```
     * will be converted to multiple AdGuard rules:
     * ```
     * example.com$$div[attr1="value1"][attr2="value2"][max-length="262144"]
     * example.com$$script[tag-content="value"][max-length="262144"]
     * ```
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToAdg(rule) {
        // Ignore AdGuard rules
        if (rule.syntax === AdblockSyntax.Adg) {
            return createNodeConversionResult([rule], false);
        }
        if (rule.syntax === AdblockSyntax.Abp) {
            throw new RuleConversionError(ERROR_MESSAGES$2.ABP_NOT_SUPPORTED);
        }
        const source = escapeDoubleQuotes(rule.body.value);
        const stream = new CssTokenStream(source);
        const convertedSelector = [];
        const convertedSelectorList = [];
        let minLen = NOT_SPECIFIED;
        let maxLen = NOT_SPECIFIED;
        // Skip leading whitespace
        stream.skipWhitespace();
        // Skip ^
        stream.expect(TokenType$1.Delim, { value: UBO_HTML_MASK });
        stream.advance();
        while (!stream.isEof()) {
            const token = stream.getOrFail();
            if (token.type === TokenType$1.Ident) {
                // Tag selector should be the first child, if present, but whitespace is allowed before it
                if (convertedSelector.length !== 0 && stream.lookbehindForNonWs() !== undefined) {
                    throw new RuleConversionError(sprintf(ERROR_MESSAGES$2.TAG_SHOULD_BE_FIRST_CHILD, getFormattedTokenName(token.type), source.slice(token.start, token.end)));
                }
                convertedSelector.push(source.slice(token.start, token.end));
                stream.advance();
            }
            else if (token.type === TokenType$1.OpenSquareBracket) {
                // Attribute selectors: https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors#syntax
                const { start } = token;
                let tempToken;
                // Advance opening square bracket
                stream.advance();
                // Skip optional whitespace after the opening square bracket
                stream.skipWhitespace();
                // Parse attribute name
                tempToken = stream.getOrFail();
                if (tempToken.type !== TokenType$1.Ident) {
                    throw new RuleConversionError(sprintf(ERROR_MESSAGES$2.INVALID_ATTRIBUTE_NAME, getFormattedTokenName(tempToken.type), source.slice(tempToken.start, tempToken.end)));
                }
                const attr = source.slice(tempToken.start, tempToken.end);
                stream.advance();
                // Skip optional whitespace after the attribute name
                stream.skipWhitespace();
                // Maybe attribute selector ends here, because value is not required, like in '[disabled]'
                tempToken = stream.getOrFail();
                // So check if the next non whitespace token is a closing square bracket
                if (tempToken.type === TokenType$1.CloseSquareBracket) {
                    const { end } = tempToken;
                    stream.advance();
                    // Special case for min-length and max-length attributes
                    if (attr === AttributeSelectors.MinLength || attr === AttributeSelectors.MaxLength) {
                        throw new RuleConversionError(sprintf(ERROR_MESSAGES$2.ATTRIBUTE_SELECTOR_REQUIRES_VALUE, attr));
                    }
                    convertedSelector.push(source.slice(start, end));
                    continue;
                }
                // Next token should be a valid attribute selector operator
                // Only '=' operator is supported
                stream.expect(TokenType$1.Delim, { value: EQUALS });
                // Advance the operator
                stream.advance();
                // Skip optional whitespace after the operator
                stream.skipWhitespace();
                // Parse attribute value
                tempToken = stream.getOrFail();
                // According to the spec, attribute value should be an identifier or a string
                if (tempToken.type !== TokenType$1.Ident && tempToken.type !== TokenType$1.String) {
                    throw new RuleConversionError(sprintf(ERROR_MESSAGES$2.INVALID_ATTRIBUTE_VALUE, getFormattedTokenName(tempToken.type), source.slice(tempToken.start, tempToken.end)));
                }
                const value = source.slice(tempToken.start, tempToken.end);
                // Advance the attribute value
                stream.advance();
                // Skip optional whitespace after the attribute value
                stream.skipWhitespace();
                // Attribute selector may have flags - but AdGuard HTML filtering does not support them
                tempToken = stream.getOrFail();
                if (tempToken.type === TokenType$1.Ident) {
                    throw new RuleConversionError(sprintf(ERROR_MESSAGES$2.FLAGS_NOT_SUPPORTED));
                }
                // Next token should be a closing square bracket
                stream.expect(TokenType$1.CloseSquareBracket);
                const { end } = stream.getOrFail();
                stream.advance();
                if (attr === AttributeSelectors.MinLength) {
                    // Min length attribute
                    const parsed = parseInt(value, 10);
                    if (Number.isNaN(parsed)) {
                        throw new RuleConversionError(sprintf(ERROR_MESSAGES$2.VALUE_FOR_ATTR_SHOULD_BE_INT, attr, value));
                    }
                    minLen = parsed;
                }
                else if (attr === AttributeSelectors.MaxLength) {
                    // Max length attribute
                    const parsed = parseInt(value, 10);
                    if (Number.isNaN(parsed)) {
                        throw new RuleConversionError(sprintf(ERROR_MESSAGES$2.VALUE_FOR_ATTR_SHOULD_BE_INT, attr, value));
                    }
                    maxLen = parsed;
                }
                else {
                    convertedSelector.push(source.slice(start, end));
                }
            }
            else if (token.type === TokenType$1.Colon) {
                let tempToken;
                // Pseudo classes: https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes#syntax
                stream.advance();
                // Next token should be a pseudo class name
                stream.expect(TokenType$1.Function);
                tempToken = stream.getOrFail();
                const fn = source.slice(tempToken.start, tempToken.end - 1); // do not include '('
                // Pseudo class should be supported
                if (!SUPPORTED_UBO_PSEUDO_CLASSES.has(fn)) {
                    throw new RuleConversionError(sprintf(ERROR_MESSAGES$2.INVALID_PSEUDO_CLASS, fn));
                }
                const paramStart = tempToken.end;
                // Find the closing paren
                stream.skipUntilBalanced();
                tempToken = stream.getOrFail();
                const paramEnd = tempToken.end;
                // Get the parameter
                const param = source.slice(paramStart, paramEnd - 1);
                if (fn === PseudoClasses$1.MinTextLength) {
                    // Min text length pseudo class
                    // Parameter should be parsed as an integer
                    const parsed = parseInt(param, 10);
                    if (Number.isNaN(parsed)) {
                        throw new RuleConversionError(sprintf(ERROR_MESSAGES$2.VALUE_FOR_PSEUDO_CLASS_SHOULD_BE_INT, fn, param));
                    }
                    minLen = parsed;
                }
                else if (fn === PseudoClasses$1.Contains || fn === PseudoClasses$1.HasText) {
                    // Contains and has-text pseudo classes
                    // Check if the argument is a RegExp
                    if (RegExpUtils.isRegexPattern(param)) {
                        // TODO: Add some support for RegExp patterns later
                        // Need to find a way to convert some RegExp patterns to glob patterns
                        throw new RuleConversionError(sprintf(ERROR_MESSAGES$2.REGEXP_NOT_SUPPORTED, param, fn));
                    }
                    // Escape unescaped double quotes in the parameter
                    const paramEscaped = StringUtils.escapeCharacter(param, DOUBLE_QUOTE_MARKER);
                    convertedSelector.push(renderAttrSelector(AttributeSelectors.TagContent, EQUALS, paramEscaped));
                }
                stream.advance();
            }
            else if (token.type === TokenType$1.Comma && token.balance === 0) {
                if (minLen !== NOT_SPECIFIED) {
                    convertedSelector.push(renderAttrSelector(AttributeSelectors.MinLength, EQUALS, minLen.toString()));
                }
                convertedSelector.push(renderAttrSelector(AttributeSelectors.MaxLength, EQUALS, maxLen !== NOT_SPECIFIED ? maxLen.toString() : ADG_HTML_CONVERSION_MAX_LENGTH.toString()));
                convertedSelectorList.push(convertedSelector.join(EMPTY));
                convertedSelector.length = 0;
                stream.advance();
            }
            else if (token.type === TokenType$1.Whitespace) {
                stream.advance();
            }
            else {
                throw new RuleConversionError(sprintf(ERROR_MESSAGES$2.UNEXPECTED_TOKEN_WITH_VALUE, getFormattedTokenName(token.type), source.slice(token.start, token.end)));
            }
        }
        if (convertedSelector.length !== 0) {
            if (minLen !== NOT_SPECIFIED) {
                convertedSelector.push(renderAttrSelector(AttributeSelectors.MinLength, EQUALS, minLen.toString()));
            }
            convertedSelector.push(renderAttrSelector(AttributeSelectors.MaxLength, EQUALS, maxLen !== NOT_SPECIFIED ? maxLen.toString() : ADG_HTML_CONVERSION_MAX_LENGTH.toString()));
            convertedSelectorList.push(convertedSelector.join(EMPTY));
        }
        return createNodeConversionResult(
        // Since AdGuard HTML filtering rules do not support multiple selectors, we need to split each selector
        // into a separate rule node.
        convertedSelectorList.map((selector) => ({
            category: RuleCategory.Cosmetic,
            type: CosmeticRuleType.HtmlFilteringRule,
            syntax: AdblockSyntax.Adg,
            exception: rule.exception,
            domains: cloneDomainListNode(rule.domains),
            // Convert the separator based on the exception status
            separator: {
                type: 'Value',
                value: rule.exception
                    ? CosmeticRuleSeparator.AdgHtmlFilteringException
                    : CosmeticRuleSeparator.AdgHtmlFiltering,
            },
            body: {
                type: 'Value',
                value: unescapeDoubleQuotes(selector),
            },
        })), true);
    }
}

/**
 * @file Utility functions for working with scriptlet nodes
 */
/**
 * Get name of the scriptlet from the scriptlet node
 *
 * @param scriptletNode Scriptlet node to get name of
 * @returns Name of the scriptlet
 * @throws If the scriptlet is empty
 */
function getScriptletName(scriptletNode) {
    if (scriptletNode.children.length === 0) {
        throw new Error('Empty scriptlet');
    }
    return scriptletNode.children[0]?.value ?? EMPTY;
}
/**
 * Transform the nth argument of the scriptlet node
 *
 * @param scriptletNode Scriptlet node to transform argument of
 * @param index Index of the argument to transform (index 0 is the scriptlet name)
 * @param transform Function to transform the argument
 */
function transformNthScriptletArgument(scriptletNode, index, transform) {
    const child = scriptletNode.children[index];
    if (!isUndefined(child)) {
        const transformed = transform(child?.value ?? null);
        if (isNull(transformed)) {
            // eslint-disable-next-line no-param-reassign
            scriptletNode.children[index] = null;
            return;
        }
        if (isNull(child)) {
            // eslint-disable-next-line no-param-reassign
            scriptletNode.children[index] = {
                type: 'Value',
                value: transformed,
            };
            return;
        }
        child.value = transformed;
    }
}
/**
 * Transform all arguments of the scriptlet node
 *
 * @param scriptletNode Scriptlet node to transform arguments of
 * @param transform Function to transform the arguments
 */
function transformAllScriptletArguments(scriptletNode, transform) {
    for (let i = 0; i < scriptletNode.children.length; i += 1) {
        transformNthScriptletArgument(scriptletNode, i, transform);
    }
}
/**
 * Set name of the scriptlet.
 * Modifies input `scriptletNode` if needed.
 *
 * @param scriptletNode Scriptlet node to set name of
 * @param name Name to set
 */
function setScriptletName(scriptletNode, name) {
    transformNthScriptletArgument(scriptletNode, 0, () => name);
}
/**
 * Set quote type of the scriptlet parameters
 *
 * @param scriptletNode Scriptlet node to set quote type of
 * @param quoteType Preferred quote type
 */
function setScriptletQuoteType(scriptletNode, quoteType) {
    // null is a special value that means "no value", but we can't change its quote type,
    // so we need to convert it to empty string
    transformAllScriptletArguments(scriptletNode, (value) => QuoteUtils.setStringQuoteType(value ?? EMPTY, quoteType));
}

/**
 * @file Resource type schema.
 */
/**
 * Resource type.
 *
 * @see {@link https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-ResourceType}
 */
var ResourceType;
(function (ResourceType) {
    ResourceType["MainFrame"] = "main_frame";
    ResourceType["SubFrame"] = "sub_frame";
    ResourceType["Stylesheet"] = "stylesheet";
    ResourceType["Script"] = "script";
    ResourceType["Image"] = "image";
    ResourceType["Font"] = "font";
    ResourceType["Object"] = "object";
    ResourceType["XmlHttpRequest"] = "xmlhttprequest";
    ResourceType["Ping"] = "ping";
    ResourceType["Media"] = "media";
    ResourceType["WebSocket"] = "websocket";
    ResourceType["Other"] = "other";
})(ResourceType || (ResourceType = {}));
/**
 * Resource type schema.
 */
const resourceTypeSchema = zod.nativeEnum(ResourceType);

/**
 * Map of resource types to their corresponding adblock modifier names.
 *
 * @note Record type is used to ensure that all resource types are present in the map.
 */
const RESOURCE_TYPE_MODIFIER_MAP = Object.freeze({
    [ResourceType.MainFrame]: 'document',
    [ResourceType.SubFrame]: 'subdocument',
    [ResourceType.Stylesheet]: 'stylesheet',
    [ResourceType.Script]: 'script',
    [ResourceType.Image]: 'image',
    [ResourceType.Font]: 'font',
    [ResourceType.Object]: 'object',
    [ResourceType.XmlHttpRequest]: 'xmlhttprequest',
    [ResourceType.Ping]: 'ping',
    [ResourceType.Media]: 'media',
    [ResourceType.WebSocket]: 'websocket',
    [ResourceType.Other]: 'other',
});
/**
 * Gets the adblock modifier name for the given resource type.
 *
 * @param resourceType Resource type to get the modifier name for.
 * @param platform Platform to get the modifier for.
 *
 * @returns A string containing the adblock modifier name for the given resource type
 * or `null` if the modifier could not be found.
 */
const getResourceTypeModifier = (resourceType, platform) => {
    const modifierName = RESOURCE_TYPE_MODIFIER_MAP[resourceType];
    if (!modifierName) {
        return null;
    }
    const modifierData = modifiersCompatibilityTable.getFirst(modifierName, platform);
    if (isNull(modifierData)) {
        return null;
    }
    return modifierData.name;
};
/**
 * Checks if the given resource type is valid.
 *
 * @param resourceType Resource type to check.
 *
 * @returns `true` if the resource type is valid, `false` otherwise.
 */
const isValidResourceType = (resourceType) => {
    return Object.values(ResourceType).includes(resourceType);
};

/**
 * @file Compatibility tables for redirects.
 */
/**
 * Prefix for resource redirection names.
 */
const ABP_RESOURCE_PREFIX = 'abp-resource:';
const ABP_RESOURCE_PREFIX_LENGTH = ABP_RESOURCE_PREFIX.length;
/**
 * Normalizes the redirect name.
 *
 * @param name Redirect name to normalize.
 *
 * @returns Normalized redirect name.
 *
 * @example
 * redirectNameNormalizer('abp-resource:my-resource') // => 'my-resource'
 * redirectNameNormalizer('noop.js:99') // => 'noop.js'
 */
const redirectNameNormalizer = (name) => {
    // Remove ABP resource prefix, if present
    if (name.startsWith(ABP_RESOURCE_PREFIX)) {
        return name.slice(ABP_RESOURCE_PREFIX_LENGTH);
    }
    // Remove :[integer] priority suffix from the name, if present
    // See:
    // - https://github.com/AdguardTeam/tsurlfilter/issues/59
    // - https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#redirect
    const colonIndex = name.lastIndexOf(COLON);
    if (colonIndex !== -1 && /^\d+$/.test(name.slice(colonIndex + 1))) {
        return name.slice(0, colonIndex);
    }
    return name;
};
/**
 * Compatibility table for redirects.
 */
class RedirectsCompatibilityTable extends CompatibilityTableBase {
    /**
     * Creates a new instance of the compatibility table for redirects.
     *
     * @param data Compatibility table data.
     */
    constructor(data) {
        super(data, redirectNameNormalizer);
    }
    /**
     * Gets the resource type adblock modifiers for the redirect for the given platform
     * based on the `resourceTypes` field.
     *
     * @param redirect Redirect name or redirect data.
     * @param platform Platform to get the modifiers for.
     *
     * @returns Set of resource type modifiers or an empty set if the redirect is not found or has no resource types.
     */
    getResourceTypeModifiers(redirect, platform) {
        let redirectData = null;
        if (isString(redirect)) {
            redirectData = this.getFirst(redirect, platform);
        }
        else {
            redirectData = redirect;
        }
        const modifierNames = new Set();
        if (isNull(redirectData) || isUndefined(redirectData.resourceTypes)) {
            return modifierNames;
        }
        for (const resourceType of redirectData.resourceTypes) {
            const modifierName = getResourceTypeModifier(resourceType, platform);
            if (isNull(modifierName)) {
                continue;
            }
            modifierNames.add(modifierName);
        }
        return modifierNames;
    }
}
/**
 * Deep freeze the compatibility table data to avoid accidental modifications.
 */
deepFreeze(redirectsCompatibilityTableData);
/**
 * Compatibility table instance for redirects.
 */
const redirectsCompatibilityTable = new RedirectsCompatibilityTable(redirectsCompatibilityTableData);

/**
 * @file Compatibility tables for scriptlets.
 */
/**
 * Compatibility table for scriptlets.
 */
class ScriptletsCompatibilityTable extends CompatibilityTableBase {
}
/**
 * Deep freeze the compatibility table data to avoid accidental modifications.
 */
deepFreeze(scriptletsCompatibilityTableData);
/**
 * Compatibility table instance for scriptlets.
 */
const scriptletsCompatibilityTable = new ScriptletsCompatibilityTable(scriptletsCompatibilityTableData);

/* eslint-disable no-bitwise */
/**
 * @file Platform schema.
 */
/**
 * Platform separator, e.g. 'adg_os_any|adg_safari_any' means any AdGuard OS platform and
 * any AdGuard Safari content blocker platform.
 */
const PLATFORM_SEPARATOR = '|';
/**
 * Platform negation character, e.g. 'adg_any|~adg_safari_any' means any AdGuard product except
 * Safari content blockers.
 */
const PLATFORM_NEGATION = '~';
/**
 * Parses a raw platform string into a platform bitmask.
 *
 * @param rawPlatforms Raw platform string, e.g. 'adg_safari_any|adg_os_any'.
 *
 * @returns Platform bitmask.
 */
const parseRawPlatforms = (rawPlatforms) => {
    // e.g. 'adg_safari_any|adg_os_any'
    const rawPlatformList = rawPlatforms
        .split(PLATFORM_SEPARATOR)
        .map((rawPlatform) => rawPlatform.trim());
    let result = 0;
    for (let rawPlatform of rawPlatformList) {
        // negation, e.g. 'adg_any|~adg_safari_any' means any AdGuard product except Safari content blockers
        let negated = false;
        if (rawPlatform.startsWith(PLATFORM_NEGATION)) {
            negated = true;
            rawPlatform = rawPlatform.slice(1).trim();
        }
        const platform = SPECIFIC_PLATFORM_MAP.get(rawPlatform) ?? GENERIC_PLATFORM_MAP.get(rawPlatform);
        if (isUndefined(platform)) {
            throw new Error(`Unknown platform: ${rawPlatform}`);
        }
        if (negated) {
            result &= ~platform;
        }
        else {
            result |= platform;
        }
    }
    if (result === 0) {
        throw new Error('No platforms specified');
    }
    return result;
};
/**
 * Platform schema.
 */
zod
    .string()
    .min(1)
    .transform((value) => parseRawPlatforms(value));

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var mapObj$1 = {exports: {}};

const isObject$1 = value => typeof value === 'object' && value !== null;
const mapObjectSkip = Symbol('skip');

// Customized for this use-case
const isObjectCustom = value =>
	isObject$1(value) &&
	!(value instanceof RegExp) &&
	!(value instanceof Error) &&
	!(value instanceof Date);

const mapObject = (object, mapper, options, isSeen = new WeakMap()) => {
	options = {
		deep: false,
		target: {},
		...options
	};

	if (isSeen.has(object)) {
		return isSeen.get(object);
	}

	isSeen.set(object, options.target);

	const {target} = options;
	delete options.target;

	const mapArray = array => array.map(element => isObjectCustom(element) ? mapObject(element, mapper, options, isSeen) : element);
	if (Array.isArray(object)) {
		return mapArray(object);
	}

	for (const [key, value] of Object.entries(object)) {
		const mapResult = mapper(key, value, object);

		if (mapResult === mapObjectSkip) {
			continue;
		}

		let [newKey, newValue, {shouldRecurse = true} = {}] = mapResult;

		// Drop `__proto__` keys.
		if (newKey === '__proto__') {
			continue;
		}

		if (options.deep && shouldRecurse && isObjectCustom(newValue)) {
			newValue = Array.isArray(newValue) ?
				mapArray(newValue) :
				mapObject(newValue, mapper, options, isSeen);
		}

		target[newKey] = newValue;
	}

	return target;
};

mapObj$1.exports = (object, mapper, options) => {
	if (!isObject$1(object)) {
		throw new TypeError(`Expected an object, got \`${object}\` (${typeof object})`);
	}

	return mapObject(object, mapper, options);
};

mapObj$1.exports.mapObjectSkip = mapObjectSkip;

var mapObjExports = mapObj$1.exports;

var camelcase = {exports: {}};

const UPPERCASE = /[\p{Lu}]/u;
const LOWERCASE = /[\p{Ll}]/u;
const LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
const IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
const SEPARATORS = /[_.\- ]+/;

const LEADING_SEPARATORS = new RegExp('^' + SEPARATORS.source);
const SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, 'gu');
const NUMBERS_AND_IDENTIFIER = new RegExp('\\d+' + IDENTIFIER.source, 'gu');

const preserveCamelCase = (string, toLowerCase, toUpperCase) => {
	let isLastCharLower = false;
	let isLastCharUpper = false;
	let isLastLastCharUpper = false;

	for (let i = 0; i < string.length; i++) {
		const character = string[i];

		if (isLastCharLower && UPPERCASE.test(character)) {
			string = string.slice(0, i) + '-' + string.slice(i);
			isLastCharLower = false;
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = true;
			i++;
		} else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
			string = string.slice(0, i - 1) + '-' + string.slice(i - 1);
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = false;
			isLastCharLower = true;
		} else {
			isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
		}
	}

	return string;
};

const preserveConsecutiveUppercase = (input, toLowerCase) => {
	LEADING_CAPITAL.lastIndex = 0;

	return input.replace(LEADING_CAPITAL, m1 => toLowerCase(m1));
};

const postProcess = (input, toUpperCase) => {
	SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
	NUMBERS_AND_IDENTIFIER.lastIndex = 0;

	return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier))
		.replace(NUMBERS_AND_IDENTIFIER, m => toUpperCase(m));
};

const camelCase$1 = (input, options) => {
	if (!(typeof input === 'string' || Array.isArray(input))) {
		throw new TypeError('Expected the input to be `string | string[]`');
	}

	options = {
		pascalCase: false,
		preserveConsecutiveUppercase: false,
		...options
	};

	if (Array.isArray(input)) {
		input = input.map(x => x.trim())
			.filter(x => x.length)
			.join('-');
	} else {
		input = input.trim();
	}

	if (input.length === 0) {
		return '';
	}

	const toLowerCase = options.locale === false ?
		string => string.toLowerCase() :
		string => string.toLocaleLowerCase(options.locale);
	const toUpperCase = options.locale === false ?
		string => string.toUpperCase() :
		string => string.toLocaleUpperCase(options.locale);

	if (input.length === 1) {
		return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
	}

	const hasUpperCase = input !== toLowerCase(input);

	if (hasUpperCase) {
		input = preserveCamelCase(input, toLowerCase, toUpperCase);
	}

	input = input.replace(LEADING_SEPARATORS, '');

	if (options.preserveConsecutiveUppercase) {
		input = preserveConsecutiveUppercase(input, toLowerCase);
	} else {
		input = toLowerCase(input);
	}

	if (options.pascalCase) {
		input = toUpperCase(input.charAt(0)) + input.slice(1);
	}

	return postProcess(input, toUpperCase);
};

camelcase.exports = camelCase$1;
// TODO: Remove this for the next major release
camelcase.exports.default = camelCase$1;

var camelcaseExports = camelcase.exports;

class QuickLRU {
	constructor(options = {}) {
		if (!(options.maxSize && options.maxSize > 0)) {
			throw new TypeError('`maxSize` must be a number greater than 0');
		}

		this.maxSize = options.maxSize;
		this.onEviction = options.onEviction;
		this.cache = new Map();
		this.oldCache = new Map();
		this._size = 0;
	}

	_set(key, value) {
		this.cache.set(key, value);
		this._size++;

		if (this._size >= this.maxSize) {
			this._size = 0;

			if (typeof this.onEviction === 'function') {
				for (const [key, value] of this.oldCache.entries()) {
					this.onEviction(key, value);
				}
			}

			this.oldCache = this.cache;
			this.cache = new Map();
		}
	}

	get(key) {
		if (this.cache.has(key)) {
			return this.cache.get(key);
		}

		if (this.oldCache.has(key)) {
			const value = this.oldCache.get(key);
			this.oldCache.delete(key);
			this._set(key, value);
			return value;
		}
	}

	set(key, value) {
		if (this.cache.has(key)) {
			this.cache.set(key, value);
		} else {
			this._set(key, value);
		}

		return this;
	}

	has(key) {
		return this.cache.has(key) || this.oldCache.has(key);
	}

	peek(key) {
		if (this.cache.has(key)) {
			return this.cache.get(key);
		}

		if (this.oldCache.has(key)) {
			return this.oldCache.get(key);
		}
	}

	delete(key) {
		const deleted = this.cache.delete(key);
		if (deleted) {
			this._size--;
		}

		return this.oldCache.delete(key) || deleted;
	}

	clear() {
		this.cache.clear();
		this.oldCache.clear();
		this._size = 0;
	}

	* keys() {
		for (const [key] of this) {
			yield key;
		}
	}

	* values() {
		for (const [, value] of this) {
			yield value;
		}
	}

	* [Symbol.iterator]() {
		for (const item of this.cache) {
			yield item;
		}

		for (const item of this.oldCache) {
			const [key] = item;
			if (!this.cache.has(key)) {
				yield item;
			}
		}
	}

	get size() {
		let oldCacheSize = 0;
		for (const key of this.oldCache.keys()) {
			if (!this.cache.has(key)) {
				oldCacheSize++;
			}
		}

		return Math.min(this._size + oldCacheSize, this.maxSize);
	}
}

var quickLru = QuickLRU;

const mapObj = mapObjExports;
const camelCase = camelcaseExports;
const QuickLru = quickLru;

const has = (array, key) => array.some(x => {
	if (typeof x === 'string') {
		return x === key;
	}

	x.lastIndex = 0;
	return x.test(key);
});

const cache = new QuickLru({maxSize: 100000});

// Reproduces behavior from `map-obj`
const isObject = value =>
	typeof value === 'object' &&
	value !== null &&
	!(value instanceof RegExp) &&
	!(value instanceof Error) &&
	!(value instanceof Date);

const camelCaseConvert = (input, options) => {
	if (!isObject(input)) {
		return input;
	}

	options = {
		deep: false,
		pascalCase: false,
		...options
	};

	const {exclude, pascalCase, stopPaths, deep} = options;

	const stopPathsSet = new Set(stopPaths);

	const makeMapper = parentPath => (key, value) => {
		if (deep && isObject(value)) {
			const path = parentPath === undefined ? key : `${parentPath}.${key}`;

			if (!stopPathsSet.has(path)) {
				value = mapObj(value, makeMapper(path));
			}
		}

		if (!(exclude && has(exclude, key))) {
			const cacheKey = pascalCase ? `${key}_` : key;

			if (cache.has(cacheKey)) {
				key = cache.get(cacheKey);
			} else {
				const returnValue = camelCase(key, {pascalCase, locale: false});

				if (key.length < 100) { // Prevent abuse
					cache.set(cacheKey, returnValue);
				}

				key = returnValue;
			}
		}

		return [key, value];
	};

	return mapObj(input, makeMapper(undefined));
};

var camelcaseKeys = (input, options) => {
	if (Array.isArray(input)) {
		return Object.keys(input).map(key => camelCaseConvert(input[key], options));
	}

	return camelCaseConvert(input, options);
};

var camelCaseKeys = /*@__PURE__*/getDefaultExportFromCjs(camelcaseKeys);

/**
 * @file Zod camelCase utility.
 */
// eslint-disable-next-line import/no-extraneous-dependencies
/**
 * Transforms Zod schema to camelCase.
 *
 * @param zod Zod schema.
 *
 * @returns Zod schema with camelCase properties.
 *
 * @see {@link https://github.com/colinhacks/zod/issues/486#issuecomment-1501097361}
 */
const zodToCamelCase = (zod) => {
    return zod.transform((val) => camelCaseKeys(val));
};

/**
 * @file Base compatibility data schema, which is commonly used in compatibility tables.
 */
/**
 * Zod schema for boolean values. Accepts both boolean and string values.
 */
const booleanSchema = zod.union([
    zod.string().transform((val) => val.trim().toLowerCase() === 'true'),
    zod.boolean(),
]);
/**
 * Zod schema for non-empty string values.
 */
const nonEmptyStringSchema = zod
    .string()
    .transform((val) => val.trim())
    .pipe(zod.string().min(1));
/**
 * Zod schema for base compatibility data.
 * Here we use snake_case properties because the compatibility data is stored in YAML files.
 */
const baseCompatibilityDataSchema = zod.object({
    /**
     * Name of the actual entity.
     */
    name: nonEmptyStringSchema,
    /**
     * List of aliases for the entity (if any).
     */
    aliases: zod.array(nonEmptyStringSchema).nullable().default(null),
    /**
     * Short description of the actual entity.
     * If not specified or it's value is `null`, then the description is not available.
     */
    description: nonEmptyStringSchema.nullable().default(null),
    /**
     * Link to the documentation. If not specified or it's value is `null`, then the documentation is not available.
     */
    docs: nonEmptyStringSchema.nullable().default(null),
    /**
     * The version of the adblocker in which the entity was added.
     * For AdGuard resources, the version of the library is specified.
     */
    version_added: nonEmptyStringSchema.nullable().default(null),
    /**
     * The version of the adblocker when the entity was removed.
     */
    version_removed: nonEmptyStringSchema.nullable().default(null),
    /**
     * Describes whether the entity is deprecated.
     */
    deprecated: booleanSchema.default(false),
    /**
     * Message that describes why the entity is deprecated.
     * If not specified or it's value is `null`, then the message is not available.
     * It's value is omitted if the entity is not marked as deprecated.
     */
    deprecation_message: nonEmptyStringSchema.nullable().default(null),
    /**
     * Describes whether the entity is removed; for *already removed* features.
     */
    removed: booleanSchema.default(false),
    /**
     * Message that describes why the entity is removed.
     * If not specified or it's value is `null`, then the message is not available.
     * It's value is omitted if the entity is not marked as deprecated.
     */
    removal_message: nonEmptyStringSchema.nullable().default(null),
});
/**
 * Zod schema for base compatibility data with camelCase properties.
 */
zodToCamelCase(baseCompatibilityDataSchema);
/**
 * Refinement logic for base compatibility data.
 *
 * @param data Base compatibility data.
 * @param ctx Refinement context.
 */
const baseRefineLogic = (data, ctx) => {
    if (data.deprecated && !data.deprecation_message) {
        ctx.addIssue({
            code: zod.ZodIssueCode.custom,
            message: 'deprecation_message is required for deprecated modifiers',
        });
    }
    if (!data.deprecated && data.deprecation_message) {
        ctx.addIssue({
            code: zod.ZodIssueCode.custom,
            message: 'deprecation_message is only allowed for deprecated modifiers',
        });
    }
    if (data.aliases && data.aliases.length !== new Set(data.aliases).size) {
        ctx.addIssue({
            code: zod.ZodIssueCode.custom,
            message: 'Aliases must be unique',
        });
    }
};

/**
 * Checks if error has message.
 *
 * @param error Error object.
 * @returns If param is error.
 */
function isErrorWithMessage(error) {
    return (typeof error === 'object'
        && error !== null
        && 'message' in error
        && typeof error.message === 'string');
}
/**
 * Converts error to the error with message.
 *
 * @param maybeError Possible error.
 * @returns Error with message.
 */
function toErrorWithMessage(maybeError) {
    if (isErrorWithMessage(maybeError)) {
        return maybeError;
    }
    try {
        return new Error(JSON.stringify(maybeError));
    }
    catch {
        // fallback in case there's an error stringifying the maybeError
        // like with circular references for example.
        return new Error(String(maybeError));
    }
}
/**
 * Converts error object to error with message. This method might be helpful to handle thrown errors.
 *
 * @param error Error object.
 *
 * @returns Message of the error.
 */
function getErrorMessage(error) {
    return toErrorWithMessage(error).message;
}

/**
 * @file Schema for modifier data.
 */
/**
 * Known validators that don't need to be validated as regex.
 */
const KNOWN_VALIDATORS = new Set([
    'domain',
    'pipe_separated_domains',
    'regexp',
    'url',
]);
/**
 * Zod schema for modifier data.
 */
zodToCamelCase(baseCompatibilityDataSchema.extend({
    /**
     * List of modifiers that are incompatible with the actual one.
     */
    conflicts: zod.array(nonEmptyStringSchema).nullable().default(null),
    /**
     * The actual modifier is incompatible with all other modifiers, except the ones listed in `conflicts`.
     */
    inverse_conflicts: booleanSchema.default(false),
    /**
     * Describes whether the actual modifier supports value assignment. For example, `$domain` is assignable,
     * so it can be used like this: `$domain=domain.com\|~subdomain.domain.com`, where `=` is the assignment operator
     * and `domain.com\|~subdomain.domain.com` is the value.
     */
    assignable: booleanSchema.default(false),
    /**
     * Describes whether the actual modifier can be negated. For example, `$third-party` is negatable,
     * so it can be used like this: `$~third-party`.
     */
    negatable: booleanSchema.default(true),
    /**
     * The actual modifier can only be used in blocking rules, it cannot be used in exceptions.
     * If it's value is `true`, then the modifier can be used only in blocking rules.
     * `exception_only` and `block_only` cannot be used together (they are mutually exclusive).
     */
    block_only: booleanSchema.default(false),
    /**
     * The actual modifier can only be used in exceptions, it cannot be used in blocking rules.
     * If it's value is `true`, then the modifier can be used only in exceptions.
     * `exception_only` and `block_only` cannot be used together (they are mutually exclusive).
     */
    exception_only: booleanSchema.default(false),
    /**
     * Describes whether the *assignable* modifier value is required.
     * For example, `$cookie` is assignable but it can be used without a value in exception rules:
     * `@@\|\|example.com^$cookie`.
     * If `false`, the `value_format` is required, e.g. the value of `$app` should always be specified
     */
    value_optional: booleanSchema.default(false),
    /**
     * Describes the format of the value for the *assignable* modifier.
     * Its value can be a regex pattern or a known validator name (e.g. `domain`, `pipe_separated_domains`, etc.).
     */
    value_format: nonEmptyStringSchema.nullable().default(null),
}).superRefine((data, ctx) => {
    // TODO: find something better, for now we can't add refine logic to the base schema:
    // https://github.com/colinhacks/zod/issues/454#issuecomment-848370721
    baseRefineLogic(data, ctx);
    if (data.block_only && data.exception_only) {
        ctx.addIssue({
            code: zod.ZodIssueCode.custom,
            message: 'block_only and exception_only are mutually exclusive',
        });
    }
    if (data.assignable && !data.value_format) {
        ctx.addIssue({
            code: zod.ZodIssueCode.custom,
            message: 'value_format is required for assignable modifiers',
        });
    }
    if (data.value_format) {
        const valueFormat = data.value_format.trim();
        // if it is a known validator, we don't need to validate it further
        if (KNOWN_VALIDATORS.has(valueFormat)) {
            return;
        }
        // otherwise, we need to validate it as a regex
        try {
            XRegExp(valueFormat);
        }
        catch (error) {
            ctx.addIssue({
                code: zod.ZodIssueCode.custom,
                message: getErrorMessage(error),
            });
        }
    }
}));

/**
 * @file Schema for redirect data.
 */
/**
 * Zod schema for redirect data.
 */
zodToCamelCase(baseCompatibilityDataSchema.extend({
    /**
     * Whether the redirect is blocking.
     */
    is_blocking: booleanSchema.default(false),
    /**
     * Resource type(s) belonging to the redirect.
     *
     * @see {@link https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-ResourceType}
     */
    resource_types: zod.array(resourceTypeSchema).default([]),
}).superRefine(baseRefineLogic));

/**
 * @file Schema for scriptlet data.
 */
/**
 * Zod schema for scriptlet parameter data.
 */
const scriptletParameterSchema = zod.object({
    /**
     * Name of the actual parameter.
     */
    name: nonEmptyStringSchema,
    /**
     * Describes whether the parameter is required. Empty parameters are not allowed.
     */
    required: booleanSchema,
    /**
     * Short description of the parameter.
     * If not specified or it's value is `null`,then the description is not available.
     */
    description: nonEmptyStringSchema.nullable().default(null),
    /**
     * Regular expression that matches the value of the parameter.
     * If it's value is `null`, then the parameter value is not checked.
     */
    pattern: nonEmptyStringSchema.nullable().default(null),
    /**
     * Default value of the parameter (if any).
     */
    default: nonEmptyStringSchema.nullable().default(null),
    /**
     * Describes whether the parameter is used only for debugging purposes.
     */
    debug: booleanSchema.default(false),
});
/**
 * Zod schema for scriptlet parameters.
 */
const scriptletParametersSchema = zod.array(scriptletParameterSchema);
/**
 * Zod schema for scriptlet data.
 */
zodToCamelCase(baseCompatibilityDataSchema.extend({
    /**
     * List of parameters that the scriptlet accepts.
     * **Every** parameter should be listed here, because we check that the scriptlet is used correctly
     * (e.g. that the number of parameters is correct).
     */
    parameters: scriptletParametersSchema.optional(),
}).superRefine((data, ctx) => {
    // TODO: find something better, for now we can't add refine logic to the base schema:
    // https://github.com/colinhacks/zod/issues/454#issuecomment-848370721
    baseRefineLogic(data, ctx);
    // we don't allow required parameters after optional ones
    if (!data.parameters) {
        return;
    }
    let optionalFound = false;
    for (const parameter of data.parameters) {
        if (optionalFound && parameter.required) {
            ctx.addIssue({
                code: zod.ZodIssueCode.custom,
                message: 'Required parameters must be before optional ones',
            });
        }
        if (!parameter.required) {
            optionalFound = true;
        }
    }
}));

/**
 * @file Scriptlet injection rule converter
 */
const ABP_SCRIPTLET_PREFIX = 'abp-';
const UBO_SCRIPTLET_PREFIX = 'ubo-';
const UBO_SCRIPTLET_PREFIX_LENGTH = UBO_SCRIPTLET_PREFIX.length;
const UBO_SCRIPTLET_JS_SUFFIX = '.js';
const UBO_SCRIPTLET_JS_SUFFIX_LENGTH = UBO_SCRIPTLET_JS_SUFFIX.length;
const COMMA_SEPARATOR = ',';
const ADG_SET_CONSTANT_NAME = 'set-constant';
const ADG_SET_CONSTANT_EMPTY_STRING = '';
const ADG_SET_CONSTANT_EMPTY_ARRAY = 'emptyArr';
const ADG_SET_CONSTANT_EMPTY_OBJECT = 'emptyObj';
const UBO_SET_CONSTANT_EMPTY_STRING = '\'\'';
const UBO_SET_CONSTANT_EMPTY_ARRAY = '[]';
const UBO_SET_CONSTANT_EMPTY_OBJECT = '{}';
const ADG_PREVENT_FETCH_NAME = 'prevent-fetch';
const ADG_PREVENT_FETCH_EMPTY_STRING = '';
const ADG_PREVENT_FETCH_WILDCARD = '*';
const UBO_NO_FETCH_IF_WILDCARD = '/^/';
const UBO_REMOVE_CLASS_NAME = 'remove-class.js';
const UBO_REMOVE_ATTR_NAME = 'remove-attr.js';
const setConstantAdgToUboMap = {
    [ADG_SET_CONSTANT_EMPTY_STRING]: UBO_SET_CONSTANT_EMPTY_STRING,
    [ADG_SET_CONSTANT_EMPTY_ARRAY]: UBO_SET_CONSTANT_EMPTY_ARRAY,
    [ADG_SET_CONSTANT_EMPTY_OBJECT]: UBO_SET_CONSTANT_EMPTY_OBJECT,
};
const REMOVE_ATTR_CLASS_APPLYING = new Set([
    'asap',
    'stay',
    'complete',
]);
/**
 * Scriptlet injection rule converter class
 *
 * @todo Implement `convertToUbo` and `convertToAbp`
 */
class ScriptletRuleConverter extends RuleConverterBase {
    /**
     * Converts a scriptlet injection rule to AdGuard format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToAdg(rule) {
        // Ignore AdGuard rules
        if (rule.syntax === AdblockSyntax.Adg) {
            return createNodeConversionResult([rule], false);
        }
        const separator = rule.separator.value;
        let convertedSeparator = separator;
        convertedSeparator = rule.exception
            ? CosmeticRuleSeparator.AdgJsInjectionException
            : CosmeticRuleSeparator.AdgJsInjection;
        const convertedScriptlets = [];
        for (const scriptlet of rule.body.children) {
            // Clone the node to avoid any side effects
            const scriptletClone = cloneScriptletRuleNode(scriptlet);
            // Remove possible quotes just to make it easier to work with the scriptlet name
            const scriptletName = QuoteUtils.setStringQuoteType(getScriptletName(scriptletClone), QuoteType.None);
            // Add prefix if it's not already there
            let prefix;
            // In uBO / ABP syntax, if a parameter contains the separator character, it should be escaped,
            // but during the conversion, we need to unescape them, because AdGuard syntax uses quotes to
            // distinguish between parameters.
            let charToUnescape;
            switch (rule.syntax) {
                case AdblockSyntax.Abp:
                    prefix = ABP_SCRIPTLET_PREFIX;
                    charToUnescape = SPACE;
                    break;
                case AdblockSyntax.Ubo:
                    prefix = UBO_SCRIPTLET_PREFIX;
                    charToUnescape = COMMA_SEPARATOR;
                    break;
                default:
                    prefix = EMPTY;
            }
            if (!scriptletName.startsWith(prefix)) {
                setScriptletName(scriptletClone, `${prefix}${scriptletName}`);
            }
            if (!isUndefined(charToUnescape)) {
                transformAllScriptletArguments(scriptletClone, (value) => {
                    if (!isNull(value)) {
                        return QuoteUtils.unescapeSingleEscapedOccurrences(value, charToUnescape);
                    }
                    return value;
                });
            }
            if (rule.syntax === AdblockSyntax.Ubo) {
                const scriptletData = scriptletsCompatibilityTable.getFirst(scriptletName, GenericPlatform.UboAny);
                // Some scriptlets have special values that need to be converted
                if (scriptletData
                    && (scriptletData.name === UBO_REMOVE_CLASS_NAME
                        || scriptletData.name === UBO_REMOVE_ATTR_NAME)
                    && scriptletClone.children.length > 2) {
                    const selectors = [];
                    let applying = null;
                    let lastArg = scriptletClone.children.pop();
                    // The very last argument might be the 'applying' parameter
                    if (lastArg) {
                        if (REMOVE_ATTR_CLASS_APPLYING.has(lastArg.value)) {
                            applying = lastArg.value;
                        }
                        else {
                            selectors.push(lastArg.value);
                        }
                    }
                    while (scriptletClone.children.length > 2) {
                        lastArg = scriptletClone.children.pop();
                        if (lastArg) {
                            selectors.push(lastArg.value.trim());
                        }
                    }
                    // Set last arg to be the combined selectors (in reverse order, because we popped them)
                    if (selectors.length > 0) {
                        scriptletClone.children.push({
                            type: 'Value',
                            value: selectors.reverse().join(', '),
                        });
                    }
                    // Push back the 'applying' parameter if it was found previously
                    if (!isNull(applying)) {
                        // If we don't have any selectors,
                        // we need to add an empty parameter before the 'applying' one
                        if (selectors.length === 0) {
                            scriptletClone.children.push({
                                type: 'Value',
                                value: EMPTY,
                            });
                        }
                        scriptletClone.children.push({
                            type: 'Value',
                            value: applying,
                        });
                    }
                }
            }
            // ADG scriptlet parameters should be quoted, and single quoted are preferred
            setScriptletQuoteType(scriptletClone, QuoteType.Single);
            convertedScriptlets.push(scriptletClone);
        }
        if (rule.body.children.length === 0) {
            const convertedScriptletNode = {
                category: rule.category,
                type: rule.type,
                syntax: AdblockSyntax.Adg,
                exception: rule.exception,
                domains: cloneDomainListNode(rule.domains),
                separator: {
                    type: 'Value',
                    value: convertedSeparator,
                },
                body: {
                    type: rule.body.type,
                    children: [],
                },
            };
            if (rule.modifiers) {
                convertedScriptletNode.modifiers = cloneModifierListNode(rule.modifiers);
            }
            return createNodeConversionResult([convertedScriptletNode], true);
        }
        return createNodeConversionResult(convertedScriptlets.map((scriptlet) => {
            const res = {
                category: rule.category,
                type: rule.type,
                syntax: AdblockSyntax.Adg,
                exception: rule.exception,
                domains: cloneDomainListNode(rule.domains),
                separator: {
                    type: 'Value',
                    value: convertedSeparator,
                },
                body: {
                    type: rule.body.type,
                    children: [scriptlet],
                },
            };
            if (rule.modifiers) {
                res.modifiers = cloneModifierListNode(rule.modifiers);
            }
            return res;
        }), true);
    }
    /**
     * Converts a scriptlet injection rule to uBlock format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToUbo(rule) {
        // Ignore uBlock rules
        if (rule.syntax === AdblockSyntax.Ubo) {
            return createNodeConversionResult([rule], false);
        }
        const separator = rule.separator.value;
        let convertedSeparator = separator;
        convertedSeparator = rule.exception
            ? CosmeticRuleSeparator.ElementHidingException
            : CosmeticRuleSeparator.ElementHiding;
        const convertedScriptlets = [];
        for (const scriptlet of rule.body.children) {
            // Clone the node to avoid any side effects
            const scriptletClone = cloneScriptletRuleNode(scriptlet);
            // Remove possible quotes just to make it easier to work with the scriptlet name
            const scriptletName = QuoteUtils.setStringQuoteType(getScriptletName(scriptletClone), QuoteType.None);
            let uboScriptletName;
            if (rule.syntax === AdblockSyntax.Adg && scriptletName.startsWith(UBO_SCRIPTLET_PREFIX)) {
                // Special case: AdGuard syntax 'preserves' the original scriptlet name,
                // so we need to convert it back by removing the uBO prefix
                uboScriptletName = scriptletName.slice(UBO_SCRIPTLET_PREFIX_LENGTH);
            }
            else {
                // Otherwise, try to find the corresponding uBO scriptlet name, or use the original one if not found
                const uboScriptlet = scriptletsCompatibilityTable.getFirst(scriptletName, GenericPlatform.UboAny);
                uboScriptletName = uboScriptlet?.name ?? scriptletName;
            }
            // Remove the '.js' suffix if it's there - its presence is not mandatory
            if (uboScriptletName.endsWith(UBO_SCRIPTLET_JS_SUFFIX)) {
                uboScriptletName = uboScriptletName.slice(0, -UBO_SCRIPTLET_JS_SUFFIX_LENGTH);
            }
            setScriptletName(scriptletClone, uboScriptletName);
            setScriptletQuoteType(scriptletClone, QuoteType.None);
            // Escape unescaped commas in parameters, because uBlock Origin uses them as separators.
            // For example, the following AdGuard rule:
            //
            // example.com#%#//scriptlet('spoof-css', '.adsbygoogle, #ads', 'visibility', 'visible')
            //
            //      â†“â†“ should be converted to â†“â†“
            //
            // example.com##+js(spoof-css.js, .adsbygoogle\, #ads, visibility, visible)
            //                  ------------  -------------------  ----------  -------
            //                    arg 0              arg 1           arg 2      arg 3
            //
            // and we need to escape the comma in the second argument to prevent it from being treated
            // as two separate arguments.
            transformAllScriptletArguments(scriptletClone, (value) => {
                if (!isNull(value)) {
                    return QuoteUtils.escapeUnescapedOccurrences(value, COMMA_SEPARATOR);
                }
                return value;
            });
            // Unescape spaces in parameters, because uBlock Origin doesn't treat them as separators.
            if (rule.syntax === AdblockSyntax.Abp) {
                transformAllScriptletArguments(scriptletClone, (value) => {
                    if (!isNull(value)) {
                        return QuoteUtils.unescapeSingleEscapedOccurrences(value, SPACE);
                    }
                    return value;
                });
            }
            // Some scriptlets have special values that need to be converted
            switch (scriptletName) {
                case ADG_SET_CONSTANT_NAME:
                    transformNthScriptletArgument(scriptletClone, 2, (value) => {
                        if (!isNull(value)) {
                            return setConstantAdgToUboMap[value] ?? value;
                        }
                        return value;
                    });
                    break;
                case ADG_PREVENT_FETCH_NAME:
                    transformNthScriptletArgument(scriptletClone, 1, (value) => {
                        if (value === ADG_PREVENT_FETCH_EMPTY_STRING || value === ADG_PREVENT_FETCH_WILDCARD) {
                            return UBO_NO_FETCH_IF_WILDCARD;
                        }
                        return value;
                    });
                    break;
            }
            convertedScriptlets.push(scriptletClone);
        }
        // TODO: Refactor redundant code
        if (rule.body.children.length === 0) {
            const convertedScriptletNode = {
                category: rule.category,
                type: rule.type,
                syntax: AdblockSyntax.Ubo,
                exception: rule.exception,
                domains: cloneDomainListNode(rule.domains),
                separator: {
                    type: 'Value',
                    value: convertedSeparator,
                },
                body: {
                    type: rule.body.type,
                    children: [],
                },
            };
            if (rule.modifiers) {
                convertedScriptletNode.modifiers = cloneModifierListNode(rule.modifiers);
            }
            return createNodeConversionResult([convertedScriptletNode], true);
        }
        return createNodeConversionResult(convertedScriptlets.map((scriptlet) => {
            const res = {
                category: rule.category,
                type: rule.type,
                syntax: AdblockSyntax.Ubo,
                exception: rule.exception,
                domains: cloneDomainListNode(rule.domains),
                separator: {
                    type: 'Value',
                    value: convertedSeparator,
                },
                body: {
                    type: rule.body.type,
                    children: [scriptlet],
                },
            };
            if (rule.modifiers) {
                res.modifiers = cloneModifierListNode(rule.modifiers);
            }
            return res;
        }), true);
    }
}

/**
 * @file Utility functions for working with modifier nodes
 */
/**
 * Creates a modifier node
 *
 * @param name Name of the modifier
 * @param value Value of the modifier
 * @param exception Whether the modifier is an exception
 * @returns Modifier node
 */
function createModifierNode(name, value = undefined, exception = false) {
    const result = {
        type: 'Modifier',
        exception,
        name: {
            type: 'Value',
            value: name,
        },
    };
    if (!isUndefined(value)) {
        result.value = {
            type: 'Value',
            value,
        };
    }
    return result;
}
/**
 * Creates a modifier list node
 *
 * @param modifiers Modifiers to put in the list (optional, defaults to an empty list)
 * @returns Modifier list node
 */
function createModifierListNode(modifiers = []) {
    const result = {
        type: 'ModifierList',
        // We need to clone the modifiers to avoid side effects
        children: modifiers.length ? clone(modifiers) : [],
    };
    return result;
}

/**
 * A very simple map extension that allows to store multiple values for the same key
 * by storing them in an array.
 *
 * @todo Add more methods if needed
 */
class MultiValueMap extends Map {
    /**
     * Adds a value to the map. If the key already exists, the value will be appended to the existing array,
     * otherwise a new array will be created for the key.
     *
     * @param key Key to add
     * @param values Value(s) to add
     */
    add(key, ...values) {
        let currentValues = super.get(key);
        if (isUndefined(currentValues)) {
            currentValues = [];
            super.set(key, values);
        }
        currentValues.push(...values);
    }
}

/**
 * @file Cosmetic rule modifier converter from uBO to ADG
 */
const UBO_MATCHES_PATH_OPERATOR = 'matches-path';
const ADG_PATH_MODIFIER = 'path';
/**
 * Special characters in modifier regexps that should be escaped
 */
const SPECIAL_MODIFIER_REGEX_CHARS = new Set([
    OPEN_SQUARE_BRACKET,
    CLOSE_SQUARE_BRACKET,
    COMMA,
    ESCAPE_CHARACTER,
]);
/**
 * Helper class for converting cosmetic rule modifiers from uBO to ADG
 */
class AdgCosmeticRuleModifierConverter {
    /**
     * Converts a uBO cosmetic rule modifier list to ADG, if possible.
     *
     * @param modifierList Cosmetic rule modifier list node to convert
     * @returns An object which follows the {@link ConversionResult} interface. Its `result` property contains
     * the converted node, and its `isConverted` flag indicates whether the original node was converted.
     * If the node was not converted, the result will contain the original node with the same object reference
     * @throws If the modifier list cannot be converted
     * @see {@link https://github.com/gorhill/uBlock/wiki/Procedural-cosmetic-filters#cosmetic-filter-operators}
     */
    static convertFromUbo(modifierList) {
        const conversionMap = new MultiValueMap();
        modifierList.children.forEach((modifier, index) => {
            // :matches-path
            if (modifier.name.value === UBO_MATCHES_PATH_OPERATOR) {
                if (!modifier.value) {
                    throw new RuleConversionError(`'${UBO_MATCHES_PATH_OPERATOR}' operator requires a value`);
                }
                const value = RegExpUtils.isRegexPattern(modifier.value.value)
                    ? StringUtils.escapeCharacters(modifier.value.value, SPECIAL_MODIFIER_REGEX_CHARS)
                    : modifier.value.value;
                // Convert uBO's `:matches-path(...)` operator to ADG's `$path=...` modifier
                conversionMap.add(index, createModifierNode(ADG_PATH_MODIFIER, 
                // We should negate the regexp if the modifier is an exception
                modifier.exception
                    // eslint-disable-next-line max-len
                    ? `${REGEX_MARKER}${RegExpUtils.negateRegexPattern(RegExpUtils.patternToRegexp(value))}${REGEX_MARKER}`
                    : value));
            }
        });
        // Check if we have any converted modifiers
        if (conversionMap.size) {
            const modifierListClone = clone(modifierList);
            // Replace the original modifiers with the converted ones
            modifierListClone.children = modifierListClone.children.map((modifier, index) => {
                const convertedModifier = conversionMap.get(index);
                return convertedModifier ?? modifier;
            }).flat();
            return createConversionResult(modifierListClone, true);
        }
        // Otherwise, just return the original modifier list
        return createConversionResult(modifierList, false);
    }
}

const ERROR_MESSAGES$1 = {
    // eslint-disable-next-line max-len
    INVALID_ATTRIBUTE_VALUE: `Expected '${getFormattedTokenName(TokenType$1.Ident)}' or '${getFormattedTokenName(TokenType$1.String)}' as attribute value, but got '%s' with value '%s`,
};
var PseudoClasses;
(function (PseudoClasses) {
    PseudoClasses["AbpContains"] = "-abp-contains";
    PseudoClasses["AbpHas"] = "-abp-has";
    PseudoClasses["Contains"] = "contains";
    PseudoClasses["Has"] = "has";
    PseudoClasses["HasText"] = "has-text";
    PseudoClasses["MatchesCss"] = "matches-css";
    PseudoClasses["MatchesCssAfter"] = "matches-css-after";
    PseudoClasses["MatchesCssBefore"] = "matches-css-before";
    PseudoClasses["Not"] = "not";
})(PseudoClasses || (PseudoClasses = {}));
var PseudoElements;
(function (PseudoElements) {
    PseudoElements["After"] = "after";
    PseudoElements["Before"] = "before";
})(PseudoElements || (PseudoElements = {}));
const PSEUDO_ELEMENT_NAMES = new Set([
    PseudoElements.After,
    PseudoElements.Before,
]);
/**
 * CSS selector converter
 *
 * @todo Implement `convertToUbo` and `convertToAbp`
 */
class CssSelectorConverter extends ConverterBase {
    /**
     * Converts Extended CSS elements to AdGuard-compatible ones
     *
     * @param selectorList Selector list to convert
     * @returns An object which follows the {@link ConversionResult} interface. Its `result` property contains
     * the converted node, and its `isConverted` flag indicates whether the original node was converted.
     * If the node was not converted, the result will contain the original node with the same object reference
     * @throws If the rule is invalid or incompatible
     */
    static convertToAdg(selectorList) {
        const stream = selectorList instanceof CssTokenStream
            ? selectorList
            : new CssTokenStream(selectorList);
        const converted = [];
        const convertAndPushPseudo = (pseudo) => {
            switch (pseudo) {
                case PseudoClasses.AbpContains:
                case PseudoClasses.HasText:
                    converted.push(PseudoClasses.Contains);
                    converted.push(OPEN_PARENTHESIS);
                    break;
                case PseudoClasses.AbpHas:
                    converted.push(PseudoClasses.Has);
                    converted.push(OPEN_PARENTHESIS);
                    break;
                // a bit special case:
                // - `:matches-css-before(...)` â†’ `:matches-css(before, ...)`
                // - `:matches-css-after(...)`  â†’ `:matches-css(after, ...)`
                case PseudoClasses.MatchesCssBefore:
                case PseudoClasses.MatchesCssAfter:
                    converted.push(PseudoClasses.MatchesCss);
                    converted.push(OPEN_PARENTHESIS);
                    converted.push(pseudo.substring(PseudoClasses.MatchesCss.length + 1));
                    converted.push(COMMA);
                    break;
                default:
                    converted.push(pseudo);
                    converted.push(OPEN_PARENTHESIS);
                    break;
            }
        };
        while (!stream.isEof()) {
            const token = stream.getOrFail();
            if (token.type === TokenType$1.Colon) {
                // Advance colon
                stream.advance();
                converted.push(COLON);
                const tempToken = stream.getOrFail();
                // Double colon is a pseudo-element
                if (tempToken.type === TokenType$1.Colon) {
                    stream.advance();
                    converted.push(COLON);
                    continue;
                }
                if (tempToken.type === TokenType$1.Ident) {
                    const name = stream.source.slice(tempToken.start, tempToken.end);
                    if (PSEUDO_ELEMENT_NAMES.has(name)) {
                        // Add an extra colon to the name
                        converted.push(COLON);
                        converted.push(name);
                    }
                    else {
                        // Add the name as is
                        converted.push(name);
                    }
                    // Advance the names
                    stream.advance();
                }
                else if (tempToken.type === TokenType$1.Function) {
                    const name = stream.source.slice(tempToken.start, tempToken.end - 1); // omit the last parenthesis
                    // :-abp-contains(...) â†’ :contains(...)
                    // :has-text(...)      â†’ :contains(...)
                    // :-abp-has(...)      â†’ :has(...)
                    convertAndPushPseudo(name);
                    // Advance the function name
                    stream.advance();
                }
            }
            else if (token.type === TokenType$1.OpenSquareBracket) {
                let tempToken;
                const { start } = token;
                stream.advance();
                // Converts legacy Extended CSS selectors to the modern Extended CSS syntax.
                // For example:
                // - `[-ext-has=...]`                  â†’ `:has(...)`
                // - `[-ext-contains=...]`             â†’ `:contains(...)`
                // - `[-ext-matches-css-before=...]`   â†’ `:matches-css(before, ...)`
                stream.skipWhitespace();
                stream.expect(TokenType$1.Ident);
                tempToken = stream.getOrFail();
                let attr = stream.source.slice(tempToken.start, tempToken.end);
                // Skip if the attribute name is not a legacy Extended CSS one
                if (!(attr.startsWith(LEGACY_EXT_CSS_ATTRIBUTE_PREFIX) || attr.startsWith(ABP_EXT_CSS_PREFIX))) {
                    converted.push(stream.source.slice(start, tempToken.end));
                    stream.advance();
                    continue;
                }
                if (attr.startsWith(LEGACY_EXT_CSS_ATTRIBUTE_PREFIX)) {
                    attr = attr.slice(LEGACY_EXT_CSS_ATTRIBUTE_PREFIX.length);
                }
                stream.advance();
                stream.skipWhitespace();
                // Next token should be an equality operator (=), because Extended CSS attribute selectors
                // do not support other operators
                stream.expect(TokenType$1.Delim, { value: EQUALS });
                stream.advance();
                // Skip optional whitespace after the operator
                stream.skipWhitespace();
                // Parse attribute value
                tempToken = stream.getOrFail();
                // According to the spec, attribute value should be an identifier or a string
                if (tempToken.type !== TokenType$1.Ident && tempToken.type !== TokenType$1.String) {
                    throw new Error(sprintf(ERROR_MESSAGES$1.INVALID_ATTRIBUTE_VALUE, getFormattedTokenName(tempToken.type), stream.source.slice(tempToken.start, tempToken.end)));
                }
                const value = stream.source.slice(tempToken.start, tempToken.end);
                // Advance the attribute value
                stream.advance();
                // Skip optional whitespace after the attribute value
                stream.skipWhitespace();
                // Next character should be a closing square bracket
                // We don't allow flags for Extended CSS attribute selectors
                stream.expect(TokenType$1.CloseSquareBracket);
                stream.advance();
                converted.push(COLON);
                convertAndPushPseudo(attr);
                let processedValue = value.slice(1, -1); // omit the quotes
                if (attr === PseudoClasses.Has) {
                    // TODO: Optimize this to avoid double tokenization
                    processedValue = CssSelectorConverter.convertToAdg(processedValue).result;
                }
                converted.push(processedValue);
                converted.push(CLOSE_PARENTHESIS);
            }
            else {
                converted.push(stream.source.slice(token.start, token.end));
                // Advance the token
                stream.advance();
            }
        }
        const convertedSelectorList = converted.join(EMPTY);
        return createConversionResult(convertedSelectorList, stream.source !== convertedSelectorList);
    }
}

/**
 * @file CSS injection rule converter
 */
/**
 * CSS injection rule converter class
 *
 * @todo Implement `convertToUbo` and `convertToAbp`
 */
class CssInjectionRuleConverter extends RuleConverterBase {
    /**
     * Converts a CSS injection rule to AdGuard format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToAdg(rule) {
        const separator = rule.separator.value;
        let convertedSeparator = separator;
        const stream = new CssTokenStream(rule.body.selectorList.value);
        const convertedSelectorList = CssSelectorConverter.convertToAdg(stream);
        // Change the separator if the rule contains ExtendedCSS elements,
        // but do not force non-extended CSS separator if the rule does not contain any ExtendedCSS selectors,
        // because sometimes we use it to force executing ExtendedCSS library.
        if (stream.hasAnySelectorExtendedCssNodeStrict() || rule.body.remove) {
            convertedSeparator = rule.exception
                ? CosmeticRuleSeparator.AdgExtendedCssInjectionException
                : CosmeticRuleSeparator.AdgExtendedCssInjection;
        }
        else if (rule.syntax !== AdblockSyntax.Adg) {
            // If the original rule syntax is not AdGuard, use the default separator
            // e.g. if the input rule is from uBO, we need to convert ## to #$#.
            convertedSeparator = rule.exception
                ? CosmeticRuleSeparator.AdgCssInjectionException
                : CosmeticRuleSeparator.AdgCssInjection;
        }
        // Check if the rule needs to be converted
        if (!(rule.syntax === AdblockSyntax.Common || rule.syntax === AdblockSyntax.Adg)
            || separator !== convertedSeparator
            || convertedSelectorList.isConverted) {
            // TODO: Replace with custom clone method
            const ruleClone = clone(rule);
            ruleClone.syntax = AdblockSyntax.Adg;
            ruleClone.separator.value = convertedSeparator;
            ruleClone.body.selectorList.value = convertedSelectorList.result;
            return createNodeConversionResult([ruleClone], true);
        }
        // Otherwise, return the original rule
        return createNodeConversionResult([rule], false);
    }
}

/**
 * @file Element hiding rule converter
 */
/**
 * Element hiding rule converter class
 *
 * @todo Implement `convertToUbo` and `convertToAbp`
 */
class ElementHidingRuleConverter extends RuleConverterBase {
    /**
     * Converts an element hiding rule to AdGuard format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToAdg(rule) {
        const separator = rule.separator.value;
        let convertedSeparator = separator;
        const stream = new CssTokenStream(rule.body.selectorList.value);
        const convertedSelectorList = CssSelectorConverter.convertToAdg(stream);
        // Change the separator if the rule contains ExtendedCSS elements,
        // but do not force non-extended CSS separator if the rule does not contain any ExtendedCSS selectors,
        // because sometimes we use it to force executing ExtendedCSS library.
        if (stream.hasAnySelectorExtendedCssNodeStrict()) {
            convertedSeparator = rule.exception
                ? CosmeticRuleSeparator.ExtendedElementHidingException
                : CosmeticRuleSeparator.ExtendedElementHiding;
        }
        // Check if the rule needs to be converted
        if (!(rule.syntax === AdblockSyntax.Common || rule.syntax === AdblockSyntax.Adg)
            || separator !== convertedSeparator
            || convertedSelectorList.isConverted) {
            // TODO: Replace with custom clone method
            const ruleClone = clone(rule);
            ruleClone.syntax = AdblockSyntax.Adg;
            ruleClone.separator.value = convertedSeparator;
            ruleClone.body.selectorList.value = convertedSelectorList.result;
            return createNodeConversionResult([ruleClone], true);
        }
        // Otherwise, return the original rule
        return createNodeConversionResult([rule], false);
    }
}

/**
 * @file Utility functions for working with network rule nodes
 */
/**
 * Creates a network rule node
 *
 * @param pattern Rule pattern
 * @param modifiers Rule modifiers (optional, default: undefined)
 * @param exception Exception rule flag (optional, default: false)
 * @param syntax Adblock syntax (optional, default: Common)
 * @returns Network rule node
 */
function createNetworkRuleNode(pattern, modifiers = undefined, exception = false, syntax = AdblockSyntax.Common) {
    const result = {
        category: RuleCategory.Network,
        type: NetworkRuleType.NetworkRule,
        syntax,
        exception,
        pattern: {
            type: 'Value',
            value: pattern,
        },
    };
    if (!isUndefined(modifiers)) {
        result.modifiers = clone(modifiers);
    }
    return result;
}

/**
 * @file Converter for request header removal rules
 */
const UBO_RESPONSEHEADER_FN = 'responseheader';
const ADG_REMOVEHEADER_MODIFIER = 'removeheader';
const ERROR_MESSAGES = {
    EMPTY_PARAMETER: `Empty parameter for '${UBO_RESPONSEHEADER_FN}' function`,
    EXPECTED_END_OF_RULE: "Expected end of rule, but got '%s'",
    MULTIPLE_DOMAINS_NOT_SUPPORTED: 'Multiple domains are not supported yet',
};
/**
 * Converter for request header removal rules
 *
 * @todo Implement `convertToUbo` (ABP currently doesn't support header removal rules)
 */
class HeaderRemovalRuleConverter extends RuleConverterBase {
    /**
     * Converts a header removal rule to AdGuard syntax, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     * @example
     * If the input rule is:
     * ```adblock
     * example.com##^responseheader(header-name)
     * ```
     * The output will be:
     * ```adblock
     * ||example.com^$removeheader=header-name
     * ```
     */
    static convertToAdg(rule) {
        // TODO: Add support for ABP syntax once it starts supporting header removal rules
        // Leave the rule as is if it's not a header removal rule
        if (rule.category !== RuleCategory.Cosmetic || rule.type !== CosmeticRuleType.HtmlFilteringRule) {
            return createNodeConversionResult([rule], false);
        }
        const stream = new CssTokenStream(rule.body.value);
        let token;
        // Skip leading whitespace
        stream.skipWhitespace();
        // Next token should be the `^` followed by a `responseheader` function
        token = stream.get();
        if (!token || token.type !== TokenType$1.Delim || rule.body.value[token.start] !== UBO_HTML_MASK) {
            return createNodeConversionResult([rule], false);
        }
        stream.advance();
        token = stream.get();
        if (!token) {
            return createNodeConversionResult([rule], false);
        }
        const functionName = rule.body.value.slice(token.start, token.end - 1);
        if (functionName !== UBO_RESPONSEHEADER_FN) {
            return createNodeConversionResult([rule], false);
        }
        // Parse the parameter
        const paramStart = token.end;
        stream.skipUntilBalanced();
        const paramEnd = stream.getOrFail().end;
        const param = rule.body.value.slice(paramStart, paramEnd - 1).trim();
        // Do not allow empty parameter
        if (param.length === 0) {
            throw new RuleConversionError(ERROR_MESSAGES.EMPTY_PARAMETER);
        }
        stream.expect(TokenType$1.CloseParenthesis);
        stream.advance();
        // Skip trailing whitespace after the function call
        stream.skipWhitespace();
        // Expect the end of the rule - so nothing should be left in the stream
        if (!stream.isEof()) {
            token = stream.getOrFail();
            throw new RuleConversionError(sprintf(ERROR_MESSAGES.EXPECTED_END_OF_RULE, getFormattedTokenName(token.type)));
        }
        // Prepare network rule pattern
        const pattern = [];
        if (rule.domains.children.length === 1) {
            // If the rule has only one domain, we can use a simple network rule pattern:
            // ||single-domain-from-the-rule^
            pattern.push(ADBLOCK_URL_START, rule.domains.children[0].value, ADBLOCK_URL_SEPARATOR);
        }
        else if (rule.domains.children.length > 1) {
            // TODO: Add support for multiple domains, for example:
            // example.com,example.org,example.net##^responseheader(header-name)
            // We should consider allowing $domain with $removeheader modifier,
            // for example:
            // $removeheader=header-name,domain=example.com|example.org|example.net
            throw new RuleConversionError(ERROR_MESSAGES.MULTIPLE_DOMAINS_NOT_SUPPORTED);
        }
        // Prepare network rule modifiers
        const modifiers = createModifierListNode();
        modifiers.children.push(createModifierNode(ADG_REMOVEHEADER_MODIFIER, param));
        // Construct the network rule
        return createNodeConversionResult([
            createNetworkRuleNode(pattern.join(EMPTY), modifiers, 
            // Copy the exception flag
            rule.exception, AdblockSyntax.Adg),
        ], true);
    }
}

/**
 * @file Cosmetic rule converter
 */
/**
 * Cosmetic rule converter class (also known as "non-basic rule converter")
 *
 * @todo Implement `convertToUbo` and `convertToAbp`
 */
class CosmeticRuleConverter extends RuleConverterBase {
    /**
     * Converts a cosmetic rule to AdGuard syntax, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToAdg(rule) {
        let subconverterResult;
        // Convert cosmetic rule based on its type
        switch (rule.type) {
            case CosmeticRuleType.ElementHidingRule:
                subconverterResult = ElementHidingRuleConverter.convertToAdg(rule);
                break;
            case CosmeticRuleType.ScriptletInjectionRule:
                subconverterResult = ScriptletRuleConverter.convertToAdg(rule);
                break;
            case CosmeticRuleType.CssInjectionRule:
                subconverterResult = CssInjectionRuleConverter.convertToAdg(rule);
                break;
            case CosmeticRuleType.HtmlFilteringRule:
                // Handle special case: uBO response header filtering rule
                // TODO: Optimize double CSS tokenization here
                subconverterResult = HeaderRemovalRuleConverter.convertToAdg(rule);
                if (subconverterResult.isConverted) {
                    break;
                }
                subconverterResult = HtmlRuleConverter.convertToAdg(rule);
                break;
            // Note: Currently, only ADG supports JS injection rules, so we don't need to convert them
            case CosmeticRuleType.JsInjectionRule:
                subconverterResult = createNodeConversionResult([rule], false);
                break;
            default:
                throw new RuleConversionError('Unsupported cosmetic rule type');
        }
        let convertedModifiers;
        // Convert cosmetic rule modifiers, if any
        if (rule.modifiers) {
            if (rule.syntax === AdblockSyntax.Ubo) {
                // uBO doesn't support this rule:
                // example.com##+js(set-constant.js, foo, bar):matches-path(/baz)
                if (rule.type === CosmeticRuleType.ScriptletInjectionRule) {
                    throw new RuleConversionError('uBO scriptlet injection rules don\'t support cosmetic rule modifiers');
                }
                convertedModifiers = AdgCosmeticRuleModifierConverter.convertFromUbo(rule.modifiers);
            }
            else if (rule.syntax === AdblockSyntax.Abp) {
                // TODO: Implement once ABP starts supporting cosmetic rule modifiers
                throw new RuleConversionError('ABP don\'t support cosmetic rule modifiers');
            }
        }
        if ((subconverterResult.result.length > 1 || subconverterResult.isConverted)
            || (convertedModifiers && convertedModifiers.isConverted)) {
            // Add modifier list to the subconverter result rules
            subconverterResult.result.forEach((subconverterRule) => {
                if (convertedModifiers && subconverterRule.category === RuleCategory.Cosmetic) {
                    // eslint-disable-next-line no-param-reassign
                    subconverterRule.modifiers = convertedModifiers.result;
                }
            });
            return subconverterResult;
        }
        return createNodeConversionResult([rule], false);
    }
    /**
     * Converts a cosmetic rule to uBlock Origin syntax, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    // TODO: Add support for other cosmetic rule types
    static convertToUbo(rule) {
        // Convert cosmetic rule based on its type
        if (rule.type === CosmeticRuleType.ScriptletInjectionRule) {
            if (rule.syntax === AdblockSyntax.Adg && rule.modifiers?.children.length) {
                // e.g. example.com##+js(set-constant.js, foo, bar):matches-path(/baz)
                throw new RuleConversionError('uBO scriptlet injection rules do not support cosmetic rule modifiers');
            }
            return ScriptletRuleConverter.convertToUbo(rule);
        }
        return createNodeConversionResult([rule], false);
    }
}

/**
 * @file Network rule modifier list converter.
 */
/**
 * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#csp-modifier}
 */
const CSP_MODIFIER = 'csp';
const CSP_SEPARATOR = SEMICOLON + SPACE;
/**
 * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#csp-modifier}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy}
 */
const COMMON_CSP_PARAMS = '\'self\' \'unsafe-eval\' http: https: data: blob: mediastream: filesystem:';
/**
 * @see {@link https://help.adblockplus.org/hc/en-us/articles/360062733293#rewrite}
 */
const ABP_REWRITE_MODIFIER = 'rewrite';
/**
 * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#redirect-modifier}
 */
const REDIRECT_MODIFIER = 'redirect';
/**
 * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#redirect-rule-modifier}
 */
const REDIRECT_RULE_MODIFIER = 'redirect-rule';
/**
 * @see {@link https://github.com/gorhill/uBlock/wiki/Resources-Library#empty-redirect-resources}
 */
const UBO_NOOP_TEXT_RESOURCE = 'noop.txt';
/**
 * Redirect-related modifiers.
 */
const REDIRECT_MODIFIERS = new Set([
    ABP_REWRITE_MODIFIER,
    REDIRECT_MODIFIER,
    REDIRECT_RULE_MODIFIER,
]);
/**
 * Conversion map for ADG network rule modifiers.
 */
const ADG_CONVERSION_MAP = new Map([
    ['1p', [{ name: () => 'third-party', exception: (actual) => !actual }]],
    ['3p', [{ name: () => 'third-party' }]],
    ['css', [{ name: () => 'stylesheet' }]],
    ['doc', [{ name: () => 'document' }]],
    ['ehide', [{ name: () => 'elemhide' }]],
    ['empty', [{ name: () => 'redirect', value: () => 'nooptext' }]],
    ['first-party', [{ name: () => 'third-party', exception: (actual) => !actual }]],
    ['frame', [{ name: () => 'subdocument' }]],
    ['ghide', [{ name: () => 'generichide' }]],
    ['inline-font', [{ name: () => CSP_MODIFIER, value: () => `font-src ${COMMON_CSP_PARAMS}` }]],
    ['inline-script', [{ name: () => CSP_MODIFIER, value: () => `script-src ${COMMON_CSP_PARAMS}` }]],
    ['mp4', [{ name: () => 'redirect', value: () => 'noopmp4-1s' }, { name: () => 'media', value: () => undefined }]],
    ['queryprune', [{ name: () => 'removeparam' }]],
    ['shide', [{ name: () => 'specifichide' }]],
    ['xhr', [{ name: () => 'xmlhttprequest' }]],
]);
/**
 * Helper class for converting network rule modifier lists.
 *
 * @todo Implement `convertToUbo` and `convertToAbp`
 */
class NetworkRuleModifierListConverter extends ConverterBase {
    /**
     * Converts a network rule modifier list to AdGuard format, if possible.
     *
     * @param modifierList Network rule modifier list node to convert
     * @param isException If `true`, the rule is an exception rule
     * @returns An object which follows the {@link ConversionResult} interface. Its `result` property contains
     * the converted node, and its `isConverted` flag indicates whether the original node was converted.
     * If the node was not converted, the result will contain the original node with the same object reference
     * @throws If the conversion is not possible
     */
    static convertToAdg(modifierList, isException = false) {
        const conversionMap = new MultiValueMap();
        // Special case: $csp modifier
        let cspCount = 0;
        modifierList.children.forEach((modifierNode, index) => {
            const modifierConversions = ADG_CONVERSION_MAP.get(modifierNode.name.value);
            if (modifierConversions) {
                for (const modifierConversion of modifierConversions) {
                    const name = modifierConversion.name(modifierNode.name.value);
                    const exception = modifierConversion.exception
                        // If the exception value is undefined in the original modifier, it
                        // means that the modifier isn't negated
                        ? modifierConversion.exception(modifierNode.exception || false)
                        : modifierNode.exception;
                    const value = modifierConversion.value
                        ? modifierConversion.value(modifierNode.value?.value)
                        : modifierNode.value?.value;
                    // Check if the name or the value is different from the original modifier
                    // If so, add the converted modifier to the list
                    if (name !== modifierNode.name.value || value !== modifierNode.value?.value) {
                        conversionMap.add(index, createModifierNode(name, value, exception));
                    }
                    // Special case: $csp modifier
                    if (name === CSP_MODIFIER) {
                        cspCount += 1;
                    }
                }
                return;
            }
            // Handle special case: resource redirection modifiers
            if (REDIRECT_MODIFIERS.has(modifierNode.name.value)) {
                // Redirect modifiers can't be negated
                if (modifierNode.exception === true) {
                    throw new RuleConversionError(`Modifier '${modifierNode.name.value}' cannot be negated`);
                }
                // Convert the redirect resource name to ADG format
                const redirectResource = modifierNode.value?.value;
                // Special case: for exception rules, $redirect without value is allowed,
                // and in this case it means an exception for all redirects
                if (!redirectResource && !isException) {
                    throw new RuleConversionError(`No redirect resource specified for '${modifierNode.name.value}' modifier`);
                }
                // Leave $redirect and $redirect-rule modifiers as is, but convert $rewrite to $redirect
                const modifierName = modifierNode.name.value === ABP_REWRITE_MODIFIER
                    ? REDIRECT_MODIFIER
                    : modifierNode.name.value;
                const convertedRedirectResource = redirectResource
                    ? redirectsCompatibilityTable.getFirst(redirectResource, GenericPlatform.AdgAny)?.name
                    : undefined;
                // Check if the modifier name or the redirect resource name is different from the original modifier.
                // If so, add the converted modifier to the list
                if (modifierName !== modifierNode.name.value
                    || (convertedRedirectResource !== undefined && convertedRedirectResource !== redirectResource)) {
                    conversionMap.add(index, createModifierNode(modifierName, 
                    // If the redirect resource name is unknown, fall back to the original one
                    // Later, the validator will throw an error if the resource name is invalid
                    convertedRedirectResource || redirectResource, modifierNode.exception));
                }
            }
        });
        // Prepare the result if there are any converted modifiers or $csp modifiers
        if (conversionMap.size || cspCount) {
            const modifierListClone = cloneModifierListNode(modifierList);
            // Replace the original modifiers with the converted ones
            // One modifier may be replaced with multiple modifiers, so we need to flatten the array
            modifierListClone.children = modifierListClone.children.map((modifierNode, index) => {
                const conversionRecord = conversionMap.get(index);
                if (conversionRecord) {
                    return conversionRecord;
                }
                return modifierNode;
            }).flat();
            // Special case: $csp modifier: merge multiple $csp modifiers into one
            // and put it at the end of the modifier list
            if (cspCount) {
                const cspValues = [];
                modifierListClone.children = modifierListClone.children.filter((modifierNode) => {
                    if (modifierNode.name.value === CSP_MODIFIER) {
                        if (!modifierNode.value?.value) {
                            throw new RuleConversionError('$csp modifier value is missing');
                        }
                        cspValues.push(modifierNode.value?.value);
                        return false;
                    }
                    return true;
                });
                modifierListClone.children.push(createModifierNode(CSP_MODIFIER, cspValues.join(CSP_SEPARATOR)));
            }
            // Before returning the result, remove duplicated modifiers
            modifierListClone.children = modifierListClone.children.filter((modifierNode, index, self) => self.findIndex((m) => m.name.value === modifierNode.name.value
                && m.exception === modifierNode.exception
                && m.value?.value === modifierNode.value?.value) === index);
            return createConversionResult(modifierListClone, true);
        }
        return createConversionResult(modifierList, false);
    }
    /**
     * Converts a network rule modifier list to uBlock format, if possible.
     *
     * @param modifierList Network rule modifier list node to convert
     * @param isException If `true`, the rule is an exception rule
     * @returns An object which follows the {@link ConversionResult} interface. Its `result` property contains
     * the converted node, and its `isConverted` flag indicates whether the original node was converted.
     * If the node was not converted, the result will contain the original node with the same object reference
     * @throws If the conversion is not possible
     */
    // TODO: Optimize
    static convertToUbo(modifierList, isException = false) {
        const conversionMap = new MultiValueMap();
        const resourceTypeModifiersToAdd = new Set();
        modifierList.children.forEach((modifierNode, index) => {
            const originalModifierName = modifierNode.name.value;
            const modifierData = modifiersCompatibilityTable.getFirst(originalModifierName, GenericPlatform.UboAny);
            // Handle special case: resource redirection modifiers
            if (REDIRECT_MODIFIERS.has(originalModifierName)) {
                // Redirect modifiers cannot be negated
                if (modifierNode.exception === true) {
                    throw new RuleConversionError(`Modifier '${modifierNode.name.value}' cannot be negated`);
                }
                // Convert the redirect resource name to uBO format
                const redirectResourceName = modifierNode.value?.value;
                // Special case: for exception rules, $redirect without value is allowed,
                // and in this case it means an exception for all redirects
                if (!redirectResourceName && !isException) {
                    throw new RuleConversionError(`No redirect resource specified for '${modifierNode.name.value}' modifier`);
                }
                if (!redirectResourceName) {
                    // Jump to the next modifier if the redirect resource is not specified
                    return;
                }
                // Leave $redirect and $redirect-rule modifiers as is, but convert $rewrite to $redirect
                const modifierName = modifierNode.name.value === ABP_REWRITE_MODIFIER
                    ? REDIRECT_MODIFIER
                    : modifierNode.name.value;
                const convertedRedirectResourceData = redirectsCompatibilityTable.getFirst(redirectResourceName, GenericPlatform.UboAny);
                const convertedRedirectResourceName = convertedRedirectResourceData?.name ?? redirectResourceName;
                // uBlock requires the $redirect modifier to have a resource type
                // https://github.com/AdguardTeam/Scriptlets/issues/101
                if (convertedRedirectResourceData?.resourceTypes?.length) {
                    // Convert the resource types to uBO modifiers
                    const uboResourceTypeModifiers = redirectsCompatibilityTable.getResourceTypeModifiers(convertedRedirectResourceData, GenericPlatform.UboAny);
                    // Special case: noop text resource
                    // If any of resource type is already present, we don't need to add other resource types,
                    // otherwise, add all resource types
                    // TODO: Optimize this logic
                    // Check if the current resource is the noop text resource
                    const isNoopTextResource = convertedRedirectResourceName === UBO_NOOP_TEXT_RESOURCE;
                    // Determine if there are any valid resource types already present
                    const hasValidResourceType = modifierList.children.some((modifier) => {
                        const name = modifier.name.value;
                        if (!isValidResourceType(name)) {
                            return false;
                        }
                        const convertedModifierData = modifiersCompatibilityTable.getFirst(name, GenericPlatform.UboAny);
                        return uboResourceTypeModifiers.has(convertedModifierData?.name ?? name);
                    });
                    // If it's not the noop text resource or if no valid resource types are present
                    if (!isNoopTextResource || !hasValidResourceType) {
                        uboResourceTypeModifiers.forEach((resourceType) => {
                            resourceTypeModifiersToAdd.add(resourceType);
                        });
                    }
                }
                // Check if the modifier name or the redirect resource name is different from the original modifier.
                // If so, add the converted modifier to the list
                if (modifierName !== originalModifierName
                    || (!isUndefined(convertedRedirectResourceName)
                        && convertedRedirectResourceName !== redirectResourceName)) {
                    conversionMap.add(index, createModifierNode(modifierName, 
                    // If the redirect resource name is unknown, fall back to the original one
                    // Later, the validator will throw an error if the resource name is invalid
                    convertedRedirectResourceName || redirectResourceName, modifierNode.exception));
                }
                return;
            }
            // Generic modifier conversion
            if (modifierData && modifierData.name !== originalModifierName) {
                conversionMap.add(index, createModifierNode(modifierData.name, modifierNode.value?.value, modifierNode.exception));
            }
        });
        // Prepare the result if there are any converted modifiers or $csp modifiers
        if (conversionMap.size || resourceTypeModifiersToAdd.size) {
            const modifierListClone = cloneModifierListNode(modifierList);
            // Replace the original modifiers with the converted ones
            // One modifier may be replaced with multiple modifiers, so we need to flatten the array
            modifierListClone.children = modifierListClone.children.map((modifierNode, index) => {
                const conversionRecord = conversionMap.get(index);
                if (conversionRecord) {
                    return conversionRecord;
                }
                return modifierNode;
            }).flat();
            // Before returning the result, remove duplicated modifiers
            modifierListClone.children = modifierListClone.children.filter((modifierNode, index, self) => self.findIndex((m) => m.name.value === modifierNode.name.value
                && m.exception === modifierNode.exception
                && m.value?.value === modifierNode.value?.value) === index);
            if (resourceTypeModifiersToAdd.size) {
                const modifierNameSet = new Set(modifierList.children.map((m) => m.name.value));
                resourceTypeModifiersToAdd.forEach((resourceType) => {
                    if (!modifierNameSet.has(resourceType)) {
                        modifierListClone.children.push(createModifierNode(resourceType));
                    }
                });
            }
            return createConversionResult(modifierListClone, true);
        }
        return createConversionResult(modifierList, false);
    }
}

/**
 * @file Network rule converter
 */
/**
 * Network rule converter class (also known as "basic rule converter")
 *
 * @todo Implement `convertToUbo` and `convertToAbp`
 */
class NetworkRuleConverter extends RuleConverterBase {
    /**
     * Converts a network rule to AdGuard format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToAdg(rule) {
        // TODO: add support for host rules
        if (rule.type !== NetworkRuleType.NetworkRule) {
            throw new Error(`Invalid rule type: ${rule.type}`);
        }
        if (rule.modifiers) {
            const modifiers = NetworkRuleModifierListConverter.convertToAdg(rule.modifiers, rule.exception);
            // If the object reference is different, it means that the modifiers were converted
            // In this case, we should clone the entire rule and replace the modifiers with the converted ones
            if (modifiers.isConverted) {
                return {
                    result: [{
                            category: RuleCategory.Network,
                            type: NetworkRuleType.NetworkRule,
                            syntax: rule.syntax,
                            exception: rule.exception,
                            pattern: {
                                type: 'Value',
                                value: rule.pattern.value,
                            },
                            modifiers: modifiers.result,
                        }],
                    isConverted: true,
                };
            }
        }
        // If the modifiers were not converted, return the original rule
        return createNodeConversionResult([rule], false);
    }
    /**
     * Converts a network rule to uBlock format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToUbo(rule) {
        // TODO: add support for host rules
        if (rule.type !== NetworkRuleType.NetworkRule) {
            throw new Error(`Invalid rule type: ${rule.type}`);
        }
        if (rule.modifiers) {
            const modifiers = NetworkRuleModifierListConverter.convertToUbo(rule.modifiers, rule.exception);
            // If the object reference is different, it means that the modifiers were converted
            // In this case, we should clone the entire rule and replace the modifiers with the converted ones
            if (modifiers.isConverted) {
                return {
                    result: [{
                            category: RuleCategory.Network,
                            type: NetworkRuleType.NetworkRule,
                            syntax: rule.syntax,
                            exception: rule.exception,
                            pattern: {
                                type: 'Value',
                                value: rule.pattern.value,
                            },
                            modifiers: modifiers.result,
                        }],
                    isConverted: true,
                };
            }
        }
        // If the modifiers were not converted, return the original rule
        return createNodeConversionResult([rule], false);
    }
}

/**
 * @file Adblock rule converter
 *
 * This file is the entry point for all rule converters
 * which automatically detects the rule type and calls
 * the corresponding "sub-converter".
 */
/**
 * Adblock filtering rule converter class
 *
 * @todo Implement `convertToUbo` and `convertToAbp`
 */
class RuleConverter extends RuleConverterBase {
    /**
     * Converts an adblock filtering rule to AdGuard format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToAdg(rule) {
        // Delegate conversion to the corresponding sub-converter
        // based on the rule category
        switch (rule.category) {
            case RuleCategory.Comment:
                return CommentRuleConverter.convertToAdg(rule);
            case RuleCategory.Cosmetic:
                return CosmeticRuleConverter.convertToAdg(rule);
            case RuleCategory.Network:
                // TODO: Handle hosts rules later
                if (rule.type === NetworkRuleType.HostRule) {
                    return createConversionResult([rule], false);
                }
                return NetworkRuleConverter.convertToAdg(rule);
            case RuleCategory.Invalid:
            case RuleCategory.Empty:
                // Just forward the rule as is
                return createConversionResult([rule], false);
            default:
                // Never happens during normal operation
                throw new RuleConversionError('Unknown rule category');
        }
    }
    /**
     * Converts an adblock filtering rule to uBlock Origin format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    // TODO: Add support for other rule types
    static convertToUbo(rule) {
        if (rule.category === RuleCategory.Cosmetic) {
            return CosmeticRuleConverter.convertToUbo(rule);
        }
        if (rule.category === RuleCategory.Network) {
            return NetworkRuleConverter.convertToUbo(rule);
        }
        return createConversionResult([rule], false);
    }
}

/**
 * @file Adblock filter list converter
 */
/**
 * Adblock filter list converter class
 *
 * This class just provides an extra layer on top of the {@link RuleConverter}
 * and can be used to convert entire filter lists.
 *
 * @todo Implement `convertToUbo` and `convertToAbp`
 * @todo Implement tolerant mode, which will allow to convert a filter list
 * even if some of its rules are invalid
 */
class FilterListConverter extends ConverterBase {
    /**
     * Converts an adblock filter list to AdGuard format, if possible.
     *
     * @param filterListNode Filter list node to convert
     * @param tolerant Indicates whether the converter should be tolerant to invalid rules. If enabled and a rule is
     * invalid, it will be left as is. If disabled and a rule is invalid, the whole filter list will be failed.
     * Defaults to `true`.
     * @returns An object which follows the {@link ConversionResult} interface. Its `result` property contains
     * the converted node, and its `isConverted` flag indicates whether the original node was converted.
     * If the node was not converted, the result will contain the original node with the same object reference
     * @throws If the filter list is invalid or cannot be converted (if the tolerant mode is disabled)
     */
    static convertToAdg(filterListNode, tolerant = true) {
        // Prepare a map to store the converted rules by their index in the filter list
        const conversionMap = new MultiValueMap();
        // Iterate over the filtering rules and convert them one by one, then add them to the result (one conversion may
        // result in multiple rules)
        for (let i = 0; i < filterListNode.children.length; i += 1) {
            try {
                const convertedRules = RuleConverter.convertToAdg(filterListNode.children[i]);
                // Add the converted rules to the map if they were converted
                if (convertedRules.isConverted) {
                    conversionMap.add(i, ...convertedRules.result);
                }
            }
            catch (error) {
                // If the tolerant mode is disabled, we should throw an error, this will fail the whole filter list
                // conversion.
                // Otherwise, we just ignore the error and leave the rule as is
                if (!tolerant) {
                    throw error;
                }
            }
        }
        // If the conversion map is empty, it means that no rules were converted, so we can return the original filter
        // list
        if (conversionMap.size === 0) {
            return createConversionResult(filterListNode, false);
        }
        // Otherwise, create a new filter list node with the converted rules
        const convertedFilterList = {
            type: 'FilterList',
            children: [],
        };
        // Iterate over the original rules again and add them to the converted filter list, replacing the converted
        // rules with the new ones at the specified indexes
        for (let i = 0; i < filterListNode.children.length; i += 1) {
            const rules = conversionMap.get(i);
            if (rules) {
                convertedFilterList.children.push(...rules);
            }
            else {
                // We clone the unconverted rules to avoid mutating the original filter list if we return the converted
                // one
                convertedFilterList.children.push(clone(filterListNode.children[i]));
            }
        }
        return createConversionResult(convertedFilterList, true);
    }
}

/**
 * @file Filter list converter for raw filter lists
 *
 * Technically, this is a wrapper around `FilterListConverter` that works with nodes instead of strings.
 */
/**
 * Adblock filter list converter class.
 *
 * You can use this class to convert string-based filter lists, since most of the converters work with nodes.
 * This class just provides an extra layer on top of the {@link FilterListConverter} and calls the parser/serializer
 * before/after the conversion internally.
 *
 * @todo Implement `convertToUbo` and `convertToAbp`
 */
class RawFilterListConverter extends ConverterBase {
    /**
     * Converts an adblock filter list text to AdGuard format, if possible.
     *
     * @param rawFilterList Raw filter list text to convert
     * @param tolerant Indicates whether the converter should be tolerant to invalid rules. If enabled and a rule is
     * invalid, it will be left as is. If disabled and a rule is invalid, the whole filter list will be failed.
     * Defaults to `true`.
     * @returns An object which follows the {@link ConversionResult} interface. Its `result` property contains
     * the array of converted filter list text, and its `isConverted` flag indicates whether the original rule was
     * converted. If the rule was not converted, the original filter list text will be returned
     * @throws If the filter list is invalid or cannot be converted (if the tolerant mode is disabled)
     */
    static convertToAdg(rawFilterList, tolerant = true) {
        const conversionResult = FilterListConverter.convertToAdg(FilterListParser.parse(rawFilterList, {
            ...defaultParserOptions,
            isLocIncluded: false,
            tolerant,
        }), tolerant);
        // If the filter list was not converted, return the original text
        if (!conversionResult.isConverted) {
            return createConversionResult(rawFilterList, false);
        }
        // Otherwise, serialize the filter list and return the result
        return createConversionResult(FilterListParser.generate(conversionResult.result), true);
    }
}

/**
 * @file Rule converter for raw rules
 *
 * Technically, this is a wrapper around `RuleConverter` that works with nodes instead of strings.
 */
/**
 * Adblock filtering rule converter class.
 *
 * You can use this class to convert string-based adblock rules, since most of the converters work with nodes.
 * This class just provides an extra layer on top of the {@link RuleConverter} and calls the parser/serializer
 * before/after the conversion internally.
 *
 * @todo Implement `convertToUbo` and `convertToAbp`
 */
class RawRuleConverter extends ConverterBase {
    /**
     * Converts an adblock filtering rule to AdGuard format, if possible.
     *
     * @param rawRule Raw rule text to convert
     * @returns An object which follows the {@link ConversionResult} interface. Its `result` property contains
     * the array of converted rule texts, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the original rule text will be returned
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToAdg(rawRule) {
        const conversionResult = RuleConverter.convertToAdg(RuleParser.parse(rawRule));
        // If the rule was not converted, return the original rule text
        if (!conversionResult.isConverted) {
            return createConversionResult([rawRule], false);
        }
        // Otherwise, serialize the converted rule nodes
        return createConversionResult(conversionResult.result.map(RuleParser.generate), true);
    }
}

/**
 * @file Binary schema version.
 */
/**
 * Binary schema version.
 * This version number is used to ensure that the binary format is compatible with the current library version.
 * We increment this number if the serialized format changes in a way that is not backwards-compatible.
 */
const BINARY_SCHEMA_VERSION = 1;

/**
 * @file Utility functions for logical expression node.
 */
const ERROR_PREFIX = {
    UNEXPECTED_NODE_TYPE: 'Unexpected node type',
    UNEXPECTED_OPERATOR: 'Unexpected operator',
};
/**
 * Utility functions for logical expression node.
 */
class LogicalExpressionUtils {
    /**
     * Get all variables in the expression.
     *
     * @param node Logical expression node
     * @returns List of variables in the expression (nodes)
     * @example
     * If the expression is `a && b || c`, the returned list will be
     * nodes for `a`, `b`, and `c`.
     */
    static getVariables(node) {
        if (node.type === NodeType.Variable) {
            return [node];
        }
        if (node.type === NodeType.Operator) {
            const leftVars = LogicalExpressionUtils.getVariables(node.left);
            const rightVars = node.right ? LogicalExpressionUtils.getVariables(node.right) : [];
            return [...leftVars, ...rightVars];
        }
        if (node.type === NodeType.Parenthesis) {
            return LogicalExpressionUtils.getVariables(node.expression);
        }
        throw new Error(ERROR_PREFIX.UNEXPECTED_NODE_TYPE);
    }
    /**
     * Evaluate the parsed logical expression. You'll need to provide a
     * variable table.
     *
     * @param node Logical expression node
     * @param table Variable table (key: variable name, value: boolean)
     * @returns Evaluation result
     * @example
     * If the expression is `a && b`, and the variable table is
     * `{ a: true, b: false }`, the result will be `false`.
     *
     * Example code:
     * ```js
     * LogicalExpressionUtils.evaluate(
     *     LogicalExpressionParser.parse('a && b'),
     *     { a: true, b: false }
     * );
     * ```
     */
    static evaluate(node, table) {
        if (node.type === NodeType.Variable) {
            return !!table[node.name];
        }
        if (node.type === NodeType.Operator) {
            if (node.operator === OperatorValue.And || node.operator === OperatorValue.Or) {
                if (!node.right) {
                    throw new Error(`${ERROR_PREFIX.UNEXPECTED_OPERATOR} '${node.operator}'`);
                }
                if (node.operator === OperatorValue.And) {
                    // eslint-disable-next-line max-len
                    return LogicalExpressionUtils.evaluate(node.left, table) && LogicalExpressionUtils.evaluate(node.right, table);
                }
                if (node.operator === OperatorValue.Or) {
                    // eslint-disable-next-line max-len
                    return LogicalExpressionUtils.evaluate(node.left, table) || LogicalExpressionUtils.evaluate(node.right, table);
                }
            }
            else if (node.operator === OperatorValue.Not) {
                return !LogicalExpressionUtils.evaluate(node.left, table);
            }
        }
        else if (node.type === NodeType.Parenthesis) {
            return LogicalExpressionUtils.evaluate(node.expression, table);
        }
        throw new Error(`${ERROR_PREFIX.UNEXPECTED_NODE_TYPE} '${node.type}'`);
    }
}

/**
 * @file Position provider class.
 */
/**
 * Class responsible for converting a character offset in source code into a line and column position.
 * This conversion is particularly needed in linters and VSCode extensions,
 * where line and column numbers are more human-friendly and intuitive than character offsets.
 * Moreover, the VSCode diagnostics API does not directly support character offsets,
 * it also requires line and column numbers.
 */
class PositionProvider {
    /**
     * Maps a character offset to a line number.
     */
    offsetToLine;
    /**
     * Maps a line number to the starting character offset of that line.
     */
    lineStartOffsets;
    /**
     * Constructs a new PositionProvider instance.
     *
     * @param sourceCode The source code as a string.
     */
    constructor(sourceCode) {
        this.offsetToLine = [];
        this.lineStartOffsets = [0];
        let currentLine = 0;
        for (let i = 0; i < sourceCode.length; i += 1) {
            this.offsetToLine[i] = currentLine;
            // Handle different types of line breaks: LF, FF, and CR
            if (sourceCode[i] === LF || sourceCode[i] === FF || sourceCode[i] === CR) {
                currentLine += 1;
                this.lineStartOffsets[currentLine] = (sourceCode[i] === CR && sourceCode[i + 1] === LF)
                    ? i + 2
                    : i + 1;
                if (sourceCode[i] === CR && sourceCode[i + 1] === LF) {
                    // Skip the '\n' in a '\r\n' sequence
                    i += 1;
                }
            }
        }
        // Handle the case where the last offset is at the end of the source code
        this.offsetToLine[sourceCode.length] = currentLine;
    }
    /**
     * Converts a character offset to a line and column position.
     *
     * @param offset The zero-based character offset in the source code.
     * @returns A Position object containing the 1-based line and column number, or null if the offset is out of range.
     */
    convertOffsetToPosition(offset) {
        if (offset < 0 || offset > this.offsetToLine.length - 1) {
            return null;
        }
        const line = this.offsetToLine[offset];
        const lineStartOffset = this.lineStartOffsets[line];
        return {
            line: line + 1,
            column: offset - lineStartOffset + 1,
        };
    }
}

/* eslint-disable no-bitwise */
/**
 * @file Core ByteBuffer implementation for handling binary data in chunks.
 */
/**
 * Core ByteBuffer implementation for handling binary data in chunks.
 * This class allows for efficient byte storage and manipulation by organizing data into chunks
 * and providing methods to read and write bytes.
 */
class ByteBuffer {
    /**
     * The size of each chunk in bytes (32 KB).
     */
    // ! IMPORTANT: If you ever change this value, make sure to update optimized bitwise operations in the code.
    static CHUNK_SIZE = 32768; // 32 * 1024
    /**
     * An array of Uint8Array chunks that make up the buffer.
     */
    chunks;
    /**
     * The total number of chunks in the buffer.
     */
    chunksLength;
    /**
     * Constructs a new ByteBuffer instance.
     *
     * @param chunks Optional array of chunks to initialize the ByteBuffer with.
     * @param cloneChunks Flag indicating if the chunks should be cloned. For performance reasons,
     * its default value is `false`. If the original chunks are guaranteed not to change,
     * leave this flag as `false` to avoid unnecessary copying.
     */
    constructor(chunks, cloneChunks = false) {
        const chunksToUse = chunks ?? [];
        this.chunks = cloneChunks ? chunksToUse.map((chunk) => new Uint8Array(chunk)) : chunksToUse;
        this.chunksLength = chunks?.length ?? 0;
    }
    /**
     * Ensures that the buffer has enough capacity to accommodate a given position.
     * This method adjusts the `chunks` array size to ensure it can hold the specified position.
     *
     * @param position The position to ensure capacity for.
     */
    ensureCapacity(position) {
        // same as Math.floor(position / chunk size), just optimized for the 32 KB chunk size
        const requiredChunkIndex = position >>> 0x000F;
        for (let i = this.chunksLength; i <= requiredChunkIndex; i += 1) {
            this.chunks.push(new Uint8Array(ByteBuffer.CHUNK_SIZE));
            this.chunksLength += 1;
        }
    }
    /**
     * Writes a byte to the buffer at the specified position.
     * If the position is outside of the buffer's current size, the buffer is resized to accommodate it.
     *
     * @param position The position at which to write the byte.
     * @param value The byte value to write (0-255).
     */
    writeByte(position, value) {
        // same as Math.floor(position / chunk size), just optimized for the 32 KB chunk size
        const chunkIndex = position >>> 0x000F;
        // same as position % chunk size, just optimized for the 32 KB chunk size
        const chunkOffset = position & 0x7FFF;
        if (chunkIndex >= this.chunksLength) {
            this.ensureCapacity(position);
        }
        this.chunks[chunkIndex][chunkOffset] = value;
    }
    /**
     * Reads a byte from the specified position in the buffer.
     * Returns `undefined` if the position is outside of the buffer's current size.
     *
     * @param position The position from which to read the byte.
     * @returns The read byte value, or `undefined` if the position is out of bounds.
     */
    readByte(position) {
        const chunkIndex = position >>> 0x000F;
        const chunkOffset = position & 0x7FFF;
        if (chunkIndex >= this.chunksLength) {
            return undefined;
        }
        return this.chunks[chunkIndex][chunkOffset];
    }
}

/**
 * A simple function to check if the current browser is Chromium-based.
 *
 * @returns `true` if the current browser is Chromium-based, `false` otherwise.
 * @see {@link https://stackoverflow.com/a/62797156}
 */
const isChromium = () => {
    return typeof window !== 'undefined'
        && (Object.prototype.hasOwnProperty.call(window, 'chrome')
            || (typeof window.navigator !== 'undefined'
                && /chrome/i.test(window.navigator.userAgent)));
};

/* eslint-disable no-param-reassign */
/* eslint-disable no-bitwise */
/**
 * @file Utility for encoding strings to byte sequences.
 */
/**
 * Checks if the given code point is an ASCII code point.
 *
 * @param codePoint Code point to check.
 * @returns `true` if the given code point is an ASCII code point, `false` otherwise.
 * @see {@link https://infra.spec.whatwg.org/#ascii-code-point}
 */
const isAsciiCodePoint = (codePoint) => {
    return codePoint >= 0x0000 && codePoint <= 0x007F;
};
const OFFSETS = [0xC0, 0xE0, 0xF0];
/**
 * Encodes an UTF-8 string into a byte sequence according to the WHATWG spec.
 *
 * @param str String to encode.
 * @param buffer Buffer to write the encoded bytes to.
 * @returns Number of bytes written to the buffer.
 * @see {@link https://encoding.spec.whatwg.org/#utf-8-encoder}
 * @note Bytes written maybe larger than the string length, but never smaller.
 * For example, the string 'ä½ å¥½' has a length of 2, but its byte representation has a length of 6.
 */
const encodeIntoPolyfill = (str, buffer) => {
    const { length } = buffer;
    let read = 0;
    let written = 0;
    for (let i = 0; i < str.length;) {
        const codePoint = str.codePointAt(i) || 0;
        let bytesNeeded = 1;
        if (isAsciiCodePoint(codePoint)) {
            if (written >= length)
                break; // Stop if no space in buffer
            buffer[written] = codePoint;
            written += 1;
            read += 1; // Increment read for ASCII
            i += 1;
        }
        else {
            if (codePoint >= 0x0080 && codePoint <= 0x07FF) {
                bytesNeeded = 2;
            }
            else if (codePoint >= 0x0800 && codePoint <= 0xFFFF) {
                bytesNeeded = 3;
            }
            else if (codePoint >= 0x10000 && codePoint <= 0x10FFFF) {
                bytesNeeded = 4;
            }
            if (written + bytesNeeded - 1 >= length) {
                // Stop if no space for the whole encoding
                break;
            }
            let count = bytesNeeded - 1;
            const offset = OFFSETS[bytesNeeded - 2];
            buffer[written] = (codePoint >> (6 * count)) + offset;
            written += 1;
            while (count > 0) {
                buffer[written] = 0x80 | ((codePoint >> (6 * (count - 1))) & 0x3F);
                written += 1;
                count -= 1;
            }
            read += codePoint >= 0x10000 ? 2 : 1; // Increment read by 1 or 2 depending on code point
            i += codePoint >= 0x10000 ? 2 : 1; // Move i by 1 or 2
        }
    }
    return { read, written };
};

/* eslint-disable no-plusplus */
/* eslint-disable no-bitwise */
/**
 * @file Output byte buffer for writing binary data.
 */
/**
 * Output byte buffer for writing binary data.
 *
 * @note Internally, this class uses a {@link ByteBuffer} instance, just providing a convenient API for reading data.
 */
class OutputByteBuffer extends ByteBuffer {
    /**
     * Current offset in the buffer for writing.
     */
    offset;
    /**
     * Size of the shared buffer for encoding strings in bytes.
     * This is a divisor of ByteBuffer.CHUNK_SIZE and experience shows that this value works optimally.
     * This is sufficient for most strings that occur in filter lists (we checked average string length in popular
     * filter lists).
     */
    static ENCODER_BUFFER_SIZE = 8192;
    /**
     * Length threshold for using a shared buffer for encoding strings.
     * This temp buffer is needed because we write the short strings in it
     * (so there is no need to constantly allocate a new buffer).
     * The reason for dividing ENCODER_BUFFER_SIZE by 4 is to ensure that the encoded string fits in the buffer,
     * if we also take into account the worst possible case (each character is encoded with 4 bytes).
     */
    static SHORT_STRING_THRESHOLD = 2048; // 8192 / 4
    /**
     * Represents the maximum value that can be written as a 'storage optimized' unsigned integer.
     * 0x1FFFFFFF means 29 bits â€” 32 bits minus 3 bits â€” because the last bit in each byte is a flag indicating
     * if there are more bytes (except for the last byte).
     */
    static MAX_OPTIMIZED_UINT = 0x1FFFFFFF;
    /**
     * Shared buffer for encoding strings.
     */
    sharedBuffer;
    /**
     * Shared native encoder for encoding strings.
     */
    sharedNativeEncoder;
    /**
     * Flag indicating if the current environment is Chromium.
     * This is used for performance optimizations, because Chromium's TextEncoder/TextDecoder has a relatively
     * large marshalling overhead for small strings.
     */
    isChromium;
    /**
     * Constructs a new OutputByteBuffer instance.
     */
    // TODO: add chunks as a parameter, if ever needed
    constructor() {
        super();
        this.sharedBuffer = new Uint8Array(OutputByteBuffer.ENCODER_BUFFER_SIZE);
        this.sharedNativeEncoder = new TextEncoder();
        this.isChromium = isChromium();
        // write the schema version at the beginning of the buffer
        this.writeUint32ToIndex(BINARY_SCHEMA_VERSION, 0);
        this.offset = 4; // schema version is already written
    }
    /**
     * Writes a 8-bit unsigned integer to the buffer.
     *
     * @param value Value to write.
     * @returns Number of bytes written to the buffer.
     */
    writeUint8(value) {
        this.writeByte(this.offset++, value);
        return 1;
    }
    /**
     * Writes a 16-bit unsigned integer to the buffer.
     *
     * @param value Value to write.
     * @returns Number of bytes written to the buffer.
     */
    writeUint16(value) {
        this.writeByte(this.offset++, value >> 8);
        this.writeByte(this.offset++, value);
        return 2;
    }
    /**
     * Writes a 32-bit unsigned integer to the buffer at a specific index.
     *
     * @param value Value to write.
     * @param index Index to write the value to.
     * @returns Number of bytes written to the buffer.
     */
    writeUint32ToIndex(value, index) {
        this.writeByte(index, value >> 24);
        this.writeByte(index + 1, value >> 16);
        this.writeByte(index + 2, value >> 8);
        this.writeByte(index + 3, value);
        return 4;
    }
    /**
     * Writes a 32-bit unsigned integer to the buffer.
     *
     * @param value Value to write.
     * @returns Number of bytes written to the buffer.
     */
    writeUint32(value) {
        this.writeUint32ToIndex(value, this.offset);
        this.offset += 4;
        return 4;
    }
    /**
     * Writes a 32-bit signed integer to the buffer.
     *
     * @param value Value to write.
     * @returns Number of bytes written to the buffer.
     */
    writeInt32(value) {
        return this.writeUint32(value ? value >>> 0 : 0);
    }
    /**
     * Writes a Uint8Array to the byte buffer.
     *
     * @param buffer Buffer to write.
     */
    writeBuffer(buffer) {
        const { length } = buffer;
        this.ensureCapacity(this.offset + length);
        let chunkIndex = this.offset >>> 0x000F;
        let chunkOffset = this.offset & 0x7FFF;
        let remainingBytes = length;
        while (remainingBytes) {
            const leftInChunk = ByteBuffer.CHUNK_SIZE - chunkOffset;
            const bytesToWrite = Math.min(remainingBytes, leftInChunk);
            this.chunks[chunkIndex].set(buffer.subarray(length - remainingBytes, length - remainingBytes + bytesToWrite), chunkOffset);
            remainingBytes -= bytesToWrite;
            chunkIndex += 1;
            chunkOffset = 0;
        }
    }
    /**
     * Writes a string to the buffer.
     *
     * @param value Value to write.
     * @returns Number of bytes written to the buffer.
     */
    writeString(value) {
        const start = this.offset;
        if (value.length <= OutputByteBuffer.SHORT_STRING_THRESHOLD) {
            let bytesWritten;
            if (this.isChromium) {
                bytesWritten = encodeIntoPolyfill(value, this.sharedBuffer).written ?? 0;
            }
            else {
                bytesWritten = this.sharedNativeEncoder.encodeInto(value, this.sharedBuffer).written ?? 0;
            }
            this.writeOptimizedUint(bytesWritten);
            this.writeBuffer(this.sharedBuffer.subarray(0, bytesWritten));
            this.offset += bytesWritten;
            return this.offset - start;
        }
        // TODO: Optimize for long strings, if needed. Not a common case for our use case
        const buffer = this.sharedNativeEncoder.encode(value);
        const bytesWritten = buffer.length;
        this.writeOptimizedUint(bytesWritten);
        this.writeBuffer(buffer);
        this.offset += bytesWritten;
        return this.offset - start;
    }
    /**
     * Writes chunks to the storage.
     *
     * @param storage Storage to write the chunks to.
     * @param key Key to write the chunks to.
     * @note For performance reasons, chunks are passed by reference and not copied.
     * @throws If the storage write operation throws.
     */
    async writeChunksToStorage(storage, key) {
        await storage.set(key, this.chunks);
    }
    /**
     * Writes an 'optimized' unsigned integer to the buffer.
     * 'Optimized' means smaller storage usage for smaller numbers.
     * Except for the last byte, each byte's most significant bit is a flag indicating if there are more bytes.
     *
     * @param value Value to write.
     * @returns Number of bytes written to the buffer.
     * @throws If the value exceeds the 29-bit limit.
     */
    writeOptimizedUint(value) {
        if (value < 0 || value > OutputByteBuffer.MAX_OPTIMIZED_UINT) {
            throw new Error('Value exceeds 29-bit limit');
        }
        let remainingValue = value;
        const startOffset = this.offset;
        while (remainingValue >= 0x80) {
            const byteValue = remainingValue & 0x7F;
            remainingValue >>>= 7;
            this.writeByte(this.offset++, byteValue | 0x80);
        }
        this.writeByte(this.offset++, remainingValue);
        return this.offset - startOffset;
    }
    /**
     * Gets the current offset in the buffer for writing.
     *
     * @returns Current offset in the buffer for writing.
     */
    get currentOffset() {
        return this.offset;
    }
}

/* eslint-disable no-plusplus */
/* eslint-disable no-bitwise */
/**
 * @file Optimized utility for decoding strings from byte sequences.
 */
const REPLACEMENT_CHAR = String.fromCodePoint(0xFFFD);
/**
 * Decodes a byte sequence into an UTF-8 string according to the WHATWG spec.
 * Optimized for performance.
 *
 * @param buffer Buffer to read the bytes from.
 * @param start Start offset in the buffer.
 * @param end End offset in the buffer.
 * @returns Decoded string.
 * @see {@link https://encoding.spec.whatwg.org/#utf-8-decoder}
 */
const decodeTextPolyfill = (buffer, start = 0, end = -1) => {
    let codePoint = 0;
    let bytesSeen = 0;
    let bytesNeeded = 0;
    let lowerBoundary = 0x0080;
    let upperBoundary = 0x00BF;
    let i = start;
    const { length } = buffer;
    const realEnd = end === -1 ? length : Math.min(end, length);
    const result = new Array(realEnd - start);
    let resIdx = 0;
    for (; i < realEnd; i += 1) {
        const byte = buffer[i];
        if (bytesNeeded === 0) {
            if (byte <= 0x007F) {
                codePoint = byte & 0x00FF;
            }
            else if (byte >= 0x00C2 && byte <= 0x00DF) {
                bytesNeeded = 1;
                codePoint = byte & 0x001F;
            }
            else if (byte >= 0x00E0 && byte <= 0x00EF) {
                bytesNeeded = 2;
                codePoint = byte & 0x000F;
                if (byte === 0x00E0) {
                    // Adjust lower boundary for exclusion of overlong sequences
                    lowerBoundary = 0x00A0;
                }
                else if (byte === 0x00ED) {
                    // Adjust upper boundary to exclude surrogates
                    upperBoundary = 0x009F;
                }
            }
            else if (byte >= 0x00F0 && byte <= 0x00F4) {
                bytesNeeded = 3;
                codePoint = byte & 0x0007;
                if (byte === 0x00F0) {
                    // Adjust lower boundary for exclusion of overlong sequences
                    lowerBoundary = 0x0090;
                }
                else if (byte === 0x00F4) {
                    // Adjust upper boundary to limit to valid Unicode range
                    upperBoundary = 0x008F;
                }
            }
            else {
                // For bytes that are not valid initial bytes of UTF-8 sequences, add replacement character
                result[resIdx++] = REPLACEMENT_CHAR;
                continue;
            }
        }
        else {
            // For subsequent bytes in a multibyte sequence, check if the byte is in the expected range
            if (!(byte >= lowerBoundary && byte <= upperBoundary)) {
                // Reset the state for illegal sequences and add replacement character
                bytesNeeded = 0;
                bytesSeen = 0;
                lowerBoundary = 0x0080;
                upperBoundary = 0x00BF;
                result[resIdx++] = REPLACEMENT_CHAR;
                // Decrement `i` to re-evaluate this byte as the start of a new sequence
                i -= 1;
                continue;
            }
            codePoint = (codePoint << 6) | (byte & 0x003F);
            // Reset boundaries for next bytes
            lowerBoundary = 0x0080;
            upperBoundary = 0x00BF;
            bytesSeen += 1;
        }
        if (bytesSeen === bytesNeeded) {
            // Complete the code point assembly and add it to the result
            result[resIdx++] = String.fromCodePoint(codePoint);
            // Reset for the next character
            bytesNeeded = 0;
            bytesSeen = 0;
            codePoint = 0;
        }
    }
    return result.join(EMPTY);
};

/* eslint-disable max-len */
/* eslint-disable no-plusplus */
/* eslint-disable no-bitwise */
/**
 * @file Input byte buffer for reading binary data.
 */
/**
 * Input byte buffer for reading binary data.
 *
 * @note Internally, this class uses a {@link ByteBuffer} instance, just providing a convenient API for reading data.
 */
class InputByteBuffer extends ByteBuffer {
    /**
     * Current offset in the buffer for reading.
     */
    offset;
    /**
     * Shared native decoder for decoding strings.
     */
    sharedNativeDecoder;
    /**
     * Flag indicating if the current environment is Chromium.
     * This is used for performance optimizations, because Chromium's TextEncoder/TextDecoder has a relatively
     * large marshalling overhead for small strings.
     */
    isChromium;
    /**
     * Constructs a new `InputByteBuffer` instance.
     *
     * @param chunks Array of chunks to initialize the ByteBuffer with.
     * @param cloneChunks Flag indicating if the chunks should be cloned. For performance reasons,
     * its default value is `false`. If the original chunks are guaranteed not to change,
     * leave this flag as `false` to avoid unnecessary copying.
     * @param initialOffset Initial offset in the buffer for reading.
     *
     * @throws If the specified chunks array is empty.
     * @throws If the binary schema version in the buffer is not equal to the expected version.
     * @throws If the initial offset is out of bounds.
     */
    constructor(chunks, cloneChunks = false, initialOffset = 0) {
        super(chunks, cloneChunks);
        // Check binary schema version
        if (chunks.length === 0) {
            throw new Error('No data in the buffer');
        }
        const actualVersion = this.readSchemaVersion();
        if (actualVersion !== BINARY_SCHEMA_VERSION) {
            throw new BinarySchemaMismatchError(BINARY_SCHEMA_VERSION, actualVersion);
        }
        // Throw an error if the initial offset is out of bounds
        if (initialOffset < 0 || initialOffset > this.chunks.length * ByteBuffer.CHUNK_SIZE) {
            throw new Error(`Invalid offset: ${initialOffset}`);
        }
        // Schema version is always stored at the beginning of the buffer - skip it, because it is already processed
        this.offset = Math.max(4, initialOffset);
        this.sharedNativeDecoder = new TextDecoder();
        this.isChromium = isChromium();
    }
    /**
     * Creates a new InputByteBuffer instance from a Storage instance by reading chunks from the storage.
     *
     * @param storage Storage instance.
     * @param key Key to read from the storage.
     * @returns New InputByteBuffer instance.
     * @note For performance reasons, chunks are passed by reference and not copied.
     */
    static async createFromStorage(storage, key) {
        const chunks = await storage.get(key);
        if (!isArrayOfUint8Arrays(chunks)) {
            throw new Error('The data from storage is not an array of Uint8Arrays');
        }
        return new InputByteBuffer(chunks);
    }
    /**
     * Reads a 8-bit unsigned integer from the buffer.
     *
     * @returns 8-bit unsigned integer from the buffer.
     */
    readUint8() {
        const result = this.readByte(this.offset++) ?? 0;
        return result;
    }
    /**
     * Reads a 16-bit unsigned integer from the buffer.
     *
     * @returns 16-bit unsigned integer from the buffer.
     */
    readUint16() {
        const result = (((this.readByte(this.offset++) ?? 0) << 8)
            | ((this.readByte(this.offset++) ?? 0))) >>> 0;
        return result;
    }
    /**
     * Reads a 32-bit unsigned integer from the buffer at the specified index.
     *
     * @param index Index to read the 32-bit unsigned integer from.
     *
     * @returns 32-bit unsigned integer from the buffer.
     */
    readUint32FromIndex(index) {
        const result = (((this.readByte(index) ?? 0) << 24)
            | ((this.readByte(index + 1) ?? 0) << 16)
            | ((this.readByte(index + 2) ?? 0) << 8)
            | ((this.readByte(index + 3) ?? 0))) >>> 0;
        return result;
    }
    /**
     * Reads a 32-bit unsigned integer from the buffer.
     *
     * @returns 32-bit unsigned integer from the buffer.
     */
    readUint32() {
        const result = this.readUint32FromIndex(this.offset);
        this.offset += 4;
        return result;
    }
    /**
     * Reads schema version from the buffer.
     *
     * @returns 32-bit unsigned integer from the buffer.
     * @note Schema version is always stored at the beginning of the buffer.
     */
    readSchemaVersion() {
        return this.readUint32FromIndex(0);
    }
    /**
     * Reads a 32-bit signed integer from the buffer.
     *
     * @returns 32-bit signed integer from the buffer.
     */
    readInt32() {
        const result = this.readUint32();
        return result > 0x7fffffff ? result - 0x100000000 : result;
    }
    /**
     * Reads an optimized unsigned integer from the buffer.
     * 'Optimized' means that the integer is stored in a variable number of bytes, depending on its value,
     * so that smaller numbers occupy less space.
     *
     * @returns Decoded unsigned integer from the buffer.
     */
    readOptimizedUint() {
        let result = 0;
        let shift = 0;
        while (shift <= 28) {
            const byteValue = this.readByte(this.offset++) ?? 0;
            result |= (byteValue & 0x7F) << shift;
            shift += 7;
            if ((byteValue & 0x80) === 0) {
                break;
            }
        }
        return result;
    }
    /**
     * Reads a string from the buffer.
     *
     * @returns Decoded string from the buffer.
     */
    readString() {
        const length = this.readOptimizedUint();
        let chunkIndex = this.offset >>> 0x000F;
        const chunkOffset = this.offset & 0x7FFF; // offset is only relevant for the first chunk
        const endOffset = chunkOffset + length;
        // In most cases, the string is stored in the current chunk
        if (endOffset < ByteBuffer.CHUNK_SIZE) {
            this.offset += length;
            if (this.isChromium) {
                return decodeTextPolyfill(this.chunks[chunkIndex], chunkOffset, endOffset);
            }
            return this.sharedNativeDecoder.decode(this.chunks[chunkIndex].subarray(chunkOffset, endOffset));
        }
        const result = [];
        result.push(this.sharedNativeDecoder.decode(this.chunks[chunkIndex++].subarray(chunkOffset), { stream: true }));
        let remaining = length - (ByteBuffer.CHUNK_SIZE - chunkOffset);
        while (remaining) {
            const chunk = this.chunks[chunkIndex];
            if (!chunk) {
                break;
            }
            const toRead = Math.min(remaining, ByteBuffer.CHUNK_SIZE);
            result.push(this.sharedNativeDecoder.decode(chunk.subarray(0, toRead), { stream: true }));
            remaining -= toRead;
            chunkIndex += 1;
        }
        // Finish decoding, if something is left
        result.push(this.sharedNativeDecoder.decode());
        this.offset += length;
        return result.join('');
    }
    /**
     * Reads a 8-bit unsigned integer from the buffer without advancing the offset.
     *
     * @returns 8-bit unsigned integer from the buffer.
     */
    peekUint8() {
        return this.readByte(this.offset) ?? 0;
    }
    /**
     * Helper method for asserting the next 8-bit unsigned integer in the buffer.
     *
     * @param value Expected value.
     * @throws If the next value in the buffer is not equal to the expected value.
     */
    assertUint8(value) {
        const result = this.readUint8();
        if (result !== value) {
            throw new Error(`Expected ${value}, but got ${result}`);
        }
    }
    /**
     * Creates a new `InputByteBuffer` instance with the given initial offset.
     *
     * @param initialOffset Initial offset for the new buffer.
     * @param cloneChunks Flag indicating if the chunks should be cloned. For performance reasons,
     * its default value is `false`. If the original chunks are guaranteed not to change,
     * leave this flag as `false` to avoid unnecessary copying.
     *
     * @returns New `InputByteBuffer` instance with the given initial offset.
     *
     * @note This method is useful if you want to read some data from a specific index.
     */
    createCopyWithOffset(initialOffset, cloneChunks = false) {
        return new InputByteBuffer(this.chunks, cloneChunks, initialOffset);
    }
    /**
     * Gets the current offset in the buffer for reading.
     *
     * @returns Current offset in the buffer for reading.
     */
    get currentOffset() {
        return this.offset;
    }
    /**
     * Gets the capacity of the buffer.
     *
     * @returns Capacity of the buffer.
     */
    get capacity() {
        return this.chunks.length * ByteBuffer.CHUNK_SIZE;
    }
}

/**
 * Utility functions for categorizing rules.
 */
// TODO: Optimize functions to avoid produce unnecessary data (currently, most of node data is not used).
// TODO: Add support for other rule categories, like network rules (when needed).
class RuleCategorizer {
    /**
     * Determines the type of a given raw cosmetic rule.
     *
     * @param rawRule Raw rule to check.
     *
     * @returns Type of the cosmetic rule or `null` if the rule is cannot be parsed as a cosmetic rule.
     */
    static getCosmeticRuleType(rawRule) {
        try {
            const node = CosmeticRuleParser.parse(rawRule, {
                ...defaultParserOptions,
                isLocIncluded: false,
                includeRaws: false,
            });
            // If rule cannot be recognized as a cosmetic rule, return null.
            if (isNull(node)) {
                return null;
            }
            return node.type;
        }
        catch {
            // Be tolerant to parsing errors and simply return null.
            return null;
        }
    }
}

const version = "2.1.2";

/**
 * @file AGTree version
 */
// ! Notice:
// Don't export version from package.json directly, because if you run
// `tsc` in the root directory, it will generate `dist/types/src/version.d.ts`
// with wrong relative path to `package.json`. So we need this little "hack"
const AGTREE_VERSION = version;

export { ADBLOCK_URL_SEPARATOR, ADBLOCK_URL_SEPARATOR_REGEX, ADBLOCK_URL_START, ADBLOCK_URL_START_REGEX, ADBLOCK_WILDCARD, ADBLOCK_WILDCARD_REGEX, ADG_SCRIPTLET_MASK, AGLINT_COMMAND_PREFIX, AGTREE_VERSION, AdblockSyntax, AdblockSyntaxError, AgentCommentRuleParser, AgentParser, AppListParser, BINARY_SCHEMA_VERSION, BinarySchemaMismatchError, ByteBuffer, COMMA_DOMAIN_LIST_SEPARATOR, CommentMarker, CommentRuleParser, CommentRuleType, ConfigCommentRuleParser, CosmeticRuleParser, CosmeticRuleSeparator, CosmeticRuleSeparatorUtils, CosmeticRuleType, DomainListParser, DomainUtils, EXT_CSS_LEGACY_ATTRIBUTES, EXT_CSS_PSEUDO_CLASSES, FORBIDDEN_CSS_FUNCTIONS, FilterListConverter, FilterListParser, GenericPlatform, HINT_MARKER, HintCommentRuleParser, HintParser, HostRuleParser, IF, INCLUDE, InputByteBuffer, KNOWN_METADATA_HEADERS, LogicalExpressionParser, LogicalExpressionUtils, MODIFIERS_SEPARATOR, MODIFIER_ASSIGN_OPERATOR, MetadataCommentRuleParser, MethodListParser, ModifierListParser, ModifierParser, NEGATION_MARKER, NETWORK_RULE_EXCEPTION_MARKER, NETWORK_RULE_SEPARATOR, NetworkRuleParser, NetworkRuleType, NotImplementedError, OutputByteBuffer, PIPE_MODIFIER_SEPARATOR, PREPROCESSOR_MARKER, ParameterListParser, PositionProvider, PreProcessorCommentRuleParser, QuoteType, QuoteUtils, RawFilterListConverter, RawRuleConverter, RegExpUtils, ResourceType, RuleCategorizer, RuleCategory, RuleConversionError, RuleConverter, RuleParser, SAFARI_CB_AFFINITY, SPECIAL_REGEX_SYMBOLS, SpecificPlatform, StealthOptionListParser, UBO_SCRIPTLET_MASK, decodeTextPolyfill, defaultParserOptions, encodeIntoPolyfill, getPlatformId, getResourceTypeModifier, getSpecificPlatformName, isGenericPlatform, isValidResourceType, modifierValidator, modifiersCompatibilityTable, parseRawPlatforms, redirectsCompatibilityTable, scriptletsCompatibilityTable };
